[
  {
    "file": "/root/development/rtchat/lib/share_channel.dart",
    "content": "import 'package:flutter/services.dart';\n\nclass ShareChannel {\n  void Function(String)? onDataReceived;\n\n  ShareChannel() {\n    // If sharing resumes the app we will check to see if we received any shared data\n    SystemChannels.lifecycle.setMessageHandler((msg) async {\n      if (msg?.contains(\"resumed\") ?? false) {\n        getSharedText().then((String data) {\n          // Nothing was shared with us :(\n          if (data.isEmpty) {\n            return;\n          }\n          // We got something! Inform our listener.\n          onDataReceived?.call(data);\n        });\n      }\n      return;\n    });\n  }\n\n  static const _channel = MethodChannel('com.rtirl.chat/share');\n  Future<String> getSharedText() async {\n    return await _channel.invokeMethod<String>('getSharedData') ?? '';\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/urls.dart",
    "content": "import 'package:flutter_custom_tabs/flutter_custom_tabs.dart' as customtabs;\nimport 'package:url_launcher/url_launcher.dart';\n\nFuture<void> openUrl(Uri url) async {\n  if (!url.hasScheme) {\n    await customtabs.launch(url.replace(scheme: 'http').toString());\n  } else if (url.isScheme(\"http\") || url.isScheme(\"https\")) {\n    await customtabs.launch(url.toString());\n  } else {\n    await launchUrl(url);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/tts_plugin.dart",
    "content": "import 'dart:async';\nimport 'dart:collection';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\nimport 'package:rtchat/main.dart';\nimport 'package:rtchat/notifications_plugin.dart';\n\nclass TextToSpeechPlugin {\n  static const MethodChannel channel = MethodChannel('ttsPlugin');\n\n  static Future<void> updateTTSPreferences(double pitch, double speed) async {\n    try {\n      await channel.invokeMethod(\n          'updateTTSPreferences', {'pitch': pitch, 'speed': speed});\n    } catch (e) {\n      debugPrint(\"updateTTSPreferences error: $e\");\n    }\n  }\n\n  static Future<void> speak(String text,\n      {double? speed, double? volume}) async {\n    try {\n      await channel.invokeMethod(\n          'speak', {'text': text, 'speed': speed, 'volume': volume});\n    } catch (e) {\n      debugPrint(\"speak error: $e\");\n    }\n  }\n\n  static Future<Map<String, String>> getLanguages() async {\n    try {\n      final Map<dynamic, dynamic> languageMap =\n          await channel.invokeMethod('getLanguages');\n      return Map<String, String>.from(languageMap);\n    } catch (e) {\n      debugPrint(\"getLanguages error: $e\");\n      return <String, String>{};\n    }\n  }\n\n  static Future<void> stopSpeaking() async {\n    try {\n      await channel.invokeMethod('stopSpeaking');\n    } catch (e) {\n      debugPrint(\"stopSpeaking error: $e\");\n    }\n  }\n\n  static Future<void> disableTTS() async {\n    try {\n      await channel.invokeMethod('disableTTS');\n    } catch (e) {\n      debugPrint(\"disableTTS error: $e\");\n    }\n  }\n\n  static Future<void> clear() async {\n    try {\n      await channel.invokeMethod('clear');\n    } catch (e) {\n      debugPrint(\"clear error: $e\");\n    }\n  }\n}\n\nclass TTSQueue {\n  final Queue<TTSQueueElement> queue = Queue<TTSQueueElement>();\n  var _lastMessageTime = DateTime.now();\n\n  bool get isEmpty => queue.isEmpty;\n  int get length => queue.length;\n\n  Future<void> speak(String id, String text,\n      {double? speed, double? volume, DateTime? timestamp}) async {\n    final completer = Completer<void>();\n    final element = TTSQueueElement(id: id, text: text, completer: completer);\n\n    if (timestamp != null && timestamp.isBefore(_lastMessageTime)) {\n      return;\n    }\n    _lastMessageTime = timestamp ?? DateTime.now();\n\n    if (queue.length >= 20 && !readUserName) {\n      queue.clear();\n      await clear();\n      await disableTts();\n      await TextToSpeechPlugin.stopSpeaking();\n      await TextToSpeechPlugin.speak(\n          \"There are too many messages. Text to speech disabled\");\n      NotificationsPlugin.cancelNotification();\n      return;\n    }\n\n    if (queue.isNotEmpty) {\n      final previous = queue.last;\n      queue.addLast(element);\n      await previous.completer.future;\n      if (queue.firstOrNull != element) {\n        throw Exception('Message was deleted');\n      }\n      await TextToSpeechPlugin.speak(text, speed: speed ?? 1.5, volume: volume);\n      completer.complete();\n    } else {\n      queue.addLast(element);\n      await TextToSpeechPlugin.speak(text, speed: speed ?? 1.5, volume: volume);\n      completer.complete();\n    }\n    queue.remove(element);\n  }\n\n  bool get readUserName => queue.length < 10;\n\n  void delete(String id) {\n    if (queue.isNotEmpty && queue.first.id != id) {\n      queue.removeWhere((element) => element.id == id);\n    }\n  }\n\n  Future<void> clear() async {\n    queue.clear();\n  }\n\n  TTSQueueElement? peek() {\n    return queue.isNotEmpty ? queue.first : null;\n  }\n\n  Future<void> disableTts() async {\n    updateChannelSubscription(\"\");\n    TextToSpeechPlugin.disableTTS();\n  }\n}\n\nclass TTSQueueElement {\n  final String id;\n  final String text;\n  final Completer<void> completer;\n\n  TTSQueueElement(\n      {required this.id, required this.text, required this.completer});\n}"
  },
  {
    "file": "/root/development/rtchat/lib/notifications_plugin.dart",
    "content": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\nimport 'package:rtchat/main.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/tts_plugin.dart';\n\nclass NotificationsPlugin {\n  static const MethodChannel _channel = MethodChannel('tts_notifications');\n\n  static Future<void> showNotification() async {\n    try {\n      await _channel.invokeMethod('showNotification');\n    } catch (e) {\n      debugPrint(e.toString());\n    }\n  }\n\n  static Future<void> listenToTts(TtsModel model) async {\n    try {\n      debugPrint(\"Listening to TTS\");\n\n      _channel.setMethodCallHandler((call) async {\n        if (call.method == \"disableTTs\") {\n          model.newTtsEnabled = false;\n\n          updateChannelSubscription(\"\");\n          await TextToSpeechPlugin.speak(\"Text to speech disabled\");\n          await TextToSpeechPlugin.disableTTS();\n        }\n      });\n    } catch (e) {\n      debugPrint(\"Error listening to TTS : $e\");\n    }\n  }\n\n  static Future<void> cancelNotification() async {\n    try {\n      await _channel.invokeMethod('dismissNotification');\n    } catch (e) {\n      debugPrint(e.toString());\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/eager_drag_recognizer.dart",
    "content": "import 'package:flutter/gestures.dart';\n\n// HorizontalDragGestureRecognizer with priority in the gesture arena.\nclass EagerHorizontalDragRecognizer extends HorizontalDragGestureRecognizer {\n  @override\n  void addAllowedPointer(PointerDownEvent event) {\n    super.addAllowedPointer(event);\n    resolve(GestureDisposition.accepted);\n  }\n\n  @override\n  String get debugDescription => 'eager horizontal drag';\n}"
  },
  {
    "file": "/root/development/rtchat/lib/firebase_options.dart",
    "content": "// File generated by FlutterFire CLI.\n// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members\nimport 'package:firebase_core/firebase_core.dart' show FirebaseOptions;\nimport 'package:flutter/foundation.dart'\n    show defaultTargetPlatform, kIsWeb, TargetPlatform;\n\n/// Default [FirebaseOptions] for use with your Firebase apps.\n///\n/// Example:\n/// ```dart\n/// import 'firebase_options.dart';\n/// // ...\n/// await Firebase.initializeApp(\n///   options: DefaultFirebaseOptions.currentPlatform,\n/// );\n/// ```\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      throw UnsupportedError(\n        'DefaultFirebaseOptions have not been configured for web - '\n        'you can reconfigure this by running the FlutterFire CLI again.',\n      );\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for macos - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.windows:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for windows - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.linux:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for linux - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      default:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions are not supported for this platform.',\n        );\n    }\n  }\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'AIzaSyDv7Q7_HDpx9Us4LAMObNPV7k8XyCmJQVA',\n    appId: '1:832669896677:android:9a9d7b799cea587c60290c',\n    messagingSenderId: '832669896677',\n    projectId: 'rtchat-47692',\n    databaseURL: 'https://rtchat-47692-default-rtdb.firebaseio.com',\n    storageBucket: 'rtchat-47692.appspot.com',\n  );\n\n  static const FirebaseOptions ios = FirebaseOptions(\n    apiKey: 'AIzaSyBxXobwS3h1USRLIrhzyb_85CoRyPZHdoo',\n    appId: '1:832669896677:ios:59504132193d3b4e60290c',\n    messagingSenderId: '832669896677',\n    projectId: 'rtchat-47692',\n    databaseURL: 'https://rtchat-47692-default-rtdb.firebaseio.com',\n    storageBucket: 'rtchat-47692.appspot.com',\n    androidClientId:\n        '832669896677-bsjr7u9hpn4m7fg2nl0mgb6uvrjudct1.apps.googleusercontent.com',\n    iosClientId:\n        '832669896677-30itsabb94b1i9qd2uoo601tp4d4tlks.apps.googleusercontent.com',\n    iosBundleId: 'com.rtirl.chat',\n  );\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/tts/languages.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/header_search_bar.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/tts/language.dart';\n\nclass LanguagesScreen extends StatefulWidget {\n  const LanguagesScreen({super.key});\n\n  @override\n  State<LanguagesScreen> createState() => LanguagesScreenState();\n}\n\nclass LanguagesScreenState extends State<LanguagesScreen> {\n  var _isSearching = false;\n  late final HeaderSearchBar searchBarWidget;\n  List<String> filteredLanguages = [];\n  Widget animatedHeader = const Align(\n    alignment: Alignment.centerLeft,\n    child: Text('Languages'),\n  );\n\n  Future<List<String>> filterList(\n      List<String> list, String searchBarText) async {\n    return list\n        .where((String element) => Language(element)\n            .displayName(context)\n            .toLowerCase()\n            .contains(searchBarText.toLowerCase()))\n        .toList();\n  }\n\n  void onFilteredByText(String searchBarText) {\n    if (searchBarText.isEmpty) {\n      setState(() {\n        filteredLanguages = supportedLanguages;\n      });\n    } else {\n      Future.wait([\n        filterList(supportedLanguages, searchBarText)\n            .then((value) => filteredLanguages = value),\n      ]);\n      setState(() {\n        filteredLanguages = filteredLanguages;\n      });\n    }\n  }\n\n  @override\n  void initState() {\n    filteredLanguages.addAll(supportedLanguages);\n    searchBarWidget = HeaderSearchBar(\n      onFilterBySearchBarText: onFilteredByText,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      resizeToAvoidBottomInset: false,\n      appBar: AppBar(\n        title: AnimatedSwitcher(\n          duration: const Duration(milliseconds: 100),\n          child: animatedHeader,\n        ),\n        actions: [\n          IconButton(\n            onPressed: () {\n              setState(() {\n                _isSearching = !_isSearching;\n                if (_isSearching) {\n                  animatedHeader = searchBarWidget;\n                } else {\n                  filteredLanguages = supportedLanguages;\n                  animatedHeader = const Align(\n                    alignment: Alignment.centerLeft,\n                    child: Text(\n                      'Languages',\n                    ),\n                  );\n                }\n              });\n            },\n            icon: !_isSearching\n                ? const Icon(Icons.search)\n                : const Icon(Icons.close),\n            tooltip: !_isSearching ? 'Search languages' : 'Close search',\n          )\n        ],\n      ),\n      body: SafeArea(\n        child: Consumer<TtsModel>(\n          builder: (context, model, child) {\n            return ListView.builder(\n              itemBuilder: (BuildContext context, int index) {\n                final language = Language(filteredLanguages[index]);\n                return ListTile(\n                  title: Text(language.displayName(context)),\n                  onTap: () {\n                    model.language = language;\n                    Navigator.pop(context);\n                  },\n                );\n              },\n              itemCount: filteredLanguages.length,\n            );\n          },\n        ),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/tts/cloud_tts_purchases.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_markdown/flutter_markdown.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/product.dart';\nimport 'package:rtchat/models/purchases.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/product_list.dart';\n\nclass CloudTtsPurchasesScreen extends StatelessWidget {\n  const CloudTtsPurchasesScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    var purchases = context.watch<Purchases>();\n    Widget storeWidget;\n    switch (purchases.storeState) {\n      case StoreState.available:\n        storeWidget = const _ProductPage();\n        break;\n      case StoreState.loading:\n        storeWidget = const Center(child: CircularProgressIndicator());\n        break;\n      case StoreState.notAvailable:\n        storeWidget = Center(\n          child: Text(\n            \"Store not available\",\n            style: Theme.of(context).textTheme.headlineSmall,\n          ),\n        );\n        purchases.loadPurchases();\n        break;\n    }\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Text to speech\")),\n      body: storeWidget,\n    );\n  }\n}\n\nclass _ProductPage extends StatelessWidget {\n  const _ProductPage();\n\n  @override\n  Widget build(BuildContext context) {\n    var purchases = context.watch<Purchases>();\n    Product? product = purchases.getProduct(cloudTtsSubscription);\n    return SafeArea(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              Padding(\n                padding:\n                    const EdgeInsets.symmetric(horizontal: 24, vertical: 16),\n                child: MarkdownBody(\n                  data: '''# High-Quality Text-to-Speech Voices\n                        \n* Unique voices for all of your viewers\n                        \n* Access to all Twitch-supported languages and more\n                        \n* No more robot speech!''',\n                  styleSheet: MarkdownStyleSheet(\n                    listBullet: Theme.of(context).textTheme.titleLarge,\n                    p: Theme.of(context).textTheme.titleLarge,\n                  ),\n                ),\n              ),\n            ],\n          ),\n          Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              const SizedBox(height: 16),\n              Padding(\n                padding: const EdgeInsets.symmetric(horizontal: 16),\n                child: Consumer<UserModel>(\n                  builder: (context, userModel, child) {\n                    String buttonText = 'Unavailable';\n                    switch (product?.status) {\n                      case ProductStatus.purchasable:\n                        buttonText = 'Subscribe';\n                        break;\n                      case ProductStatus.pending:\n                        buttonText = 'Pending';\n                        break;\n                      case ProductStatus.purchased:\n                        buttonText = 'Subscribed';\n                        break;\n                      default:\n                        break;\n                    }\n                    if (!userModel.isSignedIn()) {\n                      buttonText = 'Please Sign In';\n                    }\n\n                    return ElevatedButton(\n                      onPressed: userModel.isSignedIn() &&\n                              product!.status == ProductStatus.purchasable\n                          ? () => purchases.buy(product)\n                          : null,\n                      style: ElevatedButton.styleFrom(\n                        minimumSize: const Size.fromHeight(0),\n                        padding: const EdgeInsets.all(20),\n                        shape: RoundedRectangleBorder(\n                          borderRadius: BorderRadius.circular(24),\n                          side: const BorderSide(color: Colors.transparent),\n                        ),\n                      ),\n                      child: Text(\n                        buttonText,\n                        style: Theme.of(context)\n                            .textTheme\n                            .headlineSmall\n                            ?.copyWith(\n                              color: Theme.of(context).colorScheme.onPrimary,\n                            ),\n                      ),\n                    );\n                  },\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(\n                  '${product != null ? '${product.price}/mo   ' : ''}Cancel at any time.',\n                ),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/tts/voices.dart",
    "content": "import 'dart:convert';\n\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:flutter/material.dart';\nimport 'package:just_audio/just_audio.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/tts/bytes_audio_source.dart';\n\nclass VoicesScreen extends StatelessWidget {\n  const VoicesScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final audioPlayer = AudioPlayer();\n    return Scaffold(\n      appBar: AppBar(title: const Text('Voices')),\n      body: Consumer<TtsModel>(\n        builder: (context, model, child) {\n          return ListView.builder(\n            itemBuilder: (BuildContext context, int index) => ListTile(\n              title: Text(model.voices[index]),\n              trailing: IconButton(\n                onPressed: () async {\n                  final response = await FirebaseFunctions.instance\n                      .httpsCallable(\"synthesize\")({\n                    \"voice\": model.voices[index],\n                    \"text\": \"kevin calmly and collectively consumes cheesecake\",\n                  });\n                  final bytes = const Base64Decoder().convert(response.data);\n                  audioPlayer.setAudioSource(BytesAudioSource(bytes));\n                  audioPlayer.play();\n                },\n                icon: const Icon(Icons.play_arrow),\n                tooltip: 'Play sample',\n              ),\n              onTap: () {\n                model.voice = model.voices[index];\n                Navigator.pop(context);\n              },\n            ),\n            itemCount: model.voices.length,\n          );\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/backup.dart",
    "content": "import 'package:flutter/material.dart';\n\nclass BackupScreen extends StatefulWidget {\n  const BackupScreen({super.key});\n\n  @override\n  State<BackupScreen> createState() => _BackupScreenState();\n}\n\nclass _BackupScreenState extends State<BackupScreen> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Settings backup and restore\")),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [\n          Text(\"Cloud backup\",\n              style: TextStyle(\n                color: Theme.of(context).colorScheme.secondary,\n                fontWeight: FontWeight.bold,\n              )),\n          const Text(\"Last backup: never\"),\n          Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: [\n            ElevatedButton.icon(\n                icon: const Icon(Icons.cloud_upload),\n                label: const Text(\"Back up\"),\n                onPressed: () {}),\n            ElevatedButton.icon(\n                icon: const Icon(Icons.cloud_download),\n                label: const Text(\"Restore\"),\n                onPressed: () {}),\n          ]),\n          const Divider(),\n          Text(\"Local backup\",\n              style: TextStyle(\n                color: Theme.of(context).colorScheme.secondary,\n                fontWeight: FontWeight.bold,\n              )),\n          Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: [\n            ElevatedButton.icon(\n                icon: const Icon(Icons.file_download),\n                label: const Text(\"Export\"),\n                onPressed: () {}),\n            ElevatedButton.icon(\n                icon: const Icon(Icons.file_upload),\n                label: const Text(\"Import\"),\n                onPressed: () {}),\n          ]),\n          const Divider(),\n        ]),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/twitch/badges.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/image/cross_fade_image.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/adapters/chat_state.dart';\nimport 'package:rtchat/models/messages/twitch/badge.dart';\n\nclass TwitchBadgesScreen extends StatelessWidget {\n  const TwitchBadgesScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<TwitchBadgeModel>(builder: (context, model, child) {\n      final badges = model.badgeSets;\n      badges.sort(badgePriorityComparator);\n      return Scaffold(\n        appBar: AppBar(\n          title: Text(AppLocalizations.of(context)!.twitchBadges),\n          actions: [\n            GestureDetector(\n              onTap: () => model.setAllEnabled(model.enabledCount == 0),\n              child: Row(children: [\n                Text(AppLocalizations.of(context)!.selectAll),\n                Checkbox.adaptive(\n                  tristate: true,\n                  value: model.enabledCount == 0\n                      ? false\n                      : (model.enabledCount == model.badgeCount ? true : null),\n                  onChanged: (value) {\n                    model.setAllEnabled(value ?? false);\n                  },\n                ),\n                const SizedBox(width: 20),\n              ]),\n            ),\n          ],\n        ),\n        body: ListView.builder(\n          itemCount: badges.length,\n          itemBuilder: (context, index) {\n            final badge = badges[index];\n            final lastVersion = badge.versions.last;\n            final image =\n                ResilientNetworkImage(Uri.parse(lastVersion.imageUrl4x));\n            return CheckboxListTile.adaptive(\n                secondary: CrossFadeImage(\n                    alignment: Alignment.center,\n                    placeholder: image.placeholderImage,\n                    image: image,\n                    width: 36,\n                    height: 36),\n                title: Text(lastVersion.title, overflow: TextOverflow.ellipsis),\n                subtitle: lastVersion.description == lastVersion.title ||\n                        lastVersion.description.trim().isEmpty\n                    ? null\n                    : Text(lastVersion.description,\n                        overflow: TextOverflow.ellipsis),\n                value: model.isEnabled(badge.setId),\n                onChanged: (value) {\n                  model.setEnabled(badge.setId, value ?? false);\n                });\n          },\n        ),\n      );\n    });\n  }\n\n  static int badgePriorityComparator(TwitchBadgeInfo a, TwitchBadgeInfo b) {\n    const highPriorityBadges = ['Moderator', 'VIP'];\n    var titleA = a.versions.last.title;\n    var titleB = b.versions.last.title;\n    var isAHighPriority = highPriorityBadges.contains(titleA);\n    var isBHighPriority = highPriorityBadges.contains(titleB);\n\n    if (isAHighPriority && isBHighPriority) {\n      return titleA\n          .compareTo(titleB); // If both are high priority, sort alphabetically.\n    } else if (isAHighPriority) {\n      return -1; // a is high priority, so it comes first.\n    } else if (isBHighPriority) {\n      return 1; // b is high priority, so it comes first.\n    } else {\n      return titleA.compareTo(titleB); // Otherwise, sort alphabetically.\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/hypetrain.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass HypetrainEventScreen extends StatelessWidget {\n  const HypetrainEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Hypetrain Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin duration after hypetrain is over\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.hypetrainEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.hypetrainEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setHypetrainEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.hypetrainEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setHypetrainEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/cheer.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass CheerEventScreen extends StatelessWidget {\n  const CheerEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Cheer Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.cheerEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.cheerEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setCheerEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.cheerEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setCheerEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/host.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass HostEventScreen extends StatelessWidget {\n  const HostEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Host Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.hostEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.hostEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setHostEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.hostEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setHostEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/channel_point.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass ChannelPointRedemptionEventScreen extends StatelessWidget {\n  const ChannelPointRedemptionEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Channel Point Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.channelPointRedemptionEventConfig\n                          .eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.channelPointRedemptionEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setChannelPointRedemptionEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    Text(\"Additional Pin Duration for Unfulfilled Rewards\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.channelPointRedemptionEventConfig\n                          .unfulfilledAdditionalDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.channelPointRedemptionEventConfig.unfulfilledAdditionalDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model\n                            .setChannelPointRedemptionEventUnfulfilledAdditionalDuration(\n                                Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.channelPointRedemptionEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setChannelPointRedemptionEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              )\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/follow.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass FollowEventScreen extends StatelessWidget {\n  const FollowEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Follow Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.followEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.followEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setFollowEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.followEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setFollowEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/raiding.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass RaidingEventScreen extends StatelessWidget {\n  const RaidingEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Outgoing Raid Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.raidingEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 150,\n                      divisions: 15,\n                      label:\n                          \"${model.raidingEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setRaidingEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.raidingEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setRaidingEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/prediction.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass PredictionEventScreen extends StatelessWidget {\n  const PredictionEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text('Prediction Configuration'),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text('Pin Duration',\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.predictionEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          '${model.predictionEventConfig.eventDuration.inSeconds} seconds',\n                      onChanged: (value) {\n                        model.setPredictionEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.predictionEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setPredictionEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/raid.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass RaidEventScreen extends StatelessWidget {\n  const RaidEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Raid Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.raidEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.raidEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setRaidEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.raidEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setRaidEventShowable(value);\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable shoutouts'),\n                      subtitle: const Text(\n                          'Send a link to the raiding channel to chat'),\n                      value: model.raidEventConfig.enableShoutoutButton,\n                      onChanged: (value) {\n                        model.setRaidEventEnableShoutoutButton(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/subscription.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass SubscriptionEventScreen extends StatelessWidget {\n  const SubscriptionEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Subscription Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin Duration\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model\n                          .subscriptionEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.subscriptionEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setSubscriptionEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.subscriptionEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setSubscriptionEventShowable(value);\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title:\n                          const Text('Enable individual gifted subscriptions'),\n                      subtitle:\n                          const Text('Show every subscription that is gifted'),\n                      value: model.subscriptionEventConfig.showIndividualGifts,\n                      onChanged: (value) {\n                        model.setGiftSubscriptionStatus(value);\n                      },\n                    )\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/events/poll.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nclass PollEventScreen extends StatelessWidget {\n  const PollEventScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"Poll Configuration\"),\n        ),\n        body: Consumer<EventSubConfigurationModel>(\n            builder: (context, model, child) {\n          return Column(\n            children: [\n              Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\"Pin duration after the result is finalized\",\n                        style: TextStyle(\n                          color: Theme.of(context).colorScheme.secondary,\n                          fontWeight: FontWeight.bold,\n                        )),\n                    Slider.adaptive(\n                      value: model.pollEventConfig.eventDuration.inSeconds\n                          .toDouble(),\n                      min: 0,\n                      max: 30,\n                      divisions: 15,\n                      label:\n                          \"${model.pollEventConfig.eventDuration.inSeconds} seconds\",\n                      onChanged: (value) {\n                        model.setPollEventDuration(\n                            Duration(seconds: value.toInt()));\n                      },\n                    ),\n                    SwitchListTile.adaptive(\n                      title: const Text('Enable event'),\n                      subtitle: const Text('Show event in chat history'),\n                      value: model.pollEventConfig.showEvent,\n                      onChanged: (value) {\n                        model.setPollEventShowable(value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          );\n        }));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/tts.dart",
    "content": "import 'dart:convert';\n\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:just_audio/just_audio.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/tts/bytes_audio_source.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass TextToSpeechScreen extends StatelessWidget {\n  const TextToSpeechScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final audioPlayer = AudioPlayer();\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Text to speech\")),\n      body: Consumer<TtsModel>(builder: (context, model, child) {\n        return ListView(\n          children: [\n            if (kDebugMode)\n              Column(\n                children: [\n                  SwitchListTile.adaptive(\n                    title: const Text('Cloud TTS'),\n                    value: model.isCloudTtsEnabled,\n                    onChanged: (value) {\n                      model.isCloudTtsEnabled = value;\n                    },\n                  ),\n                  if (model.isCloudTtsEnabled)\n                    Column(\n                      children: [\n                        Padding(\n                          padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),\n                          child: Column(\n                            crossAxisAlignment: CrossAxisAlignment.start,\n                            children: [\n                              if (!model.isSupportedLanguage)\n                                Column(\n                                  crossAxisAlignment: CrossAxisAlignment.start,\n                                  children: [\n                                    Text(\n                                      \"Languages\",\n                                      style: TextStyle(\n                                        color: Theme.of(context)\n                                            .colorScheme\n                                            .secondary,\n                                        fontWeight: FontWeight.bold,\n                                      ),\n                                    ),\n                                    OutlinedButton(\n                                      onPressed: () => Navigator.pushNamed(\n                                        context,\n                                        '/settings/text-to-speech/languages',\n                                      ),\n                                      style: OutlinedButton.styleFrom(\n                                        side: BorderSide(\n                                            width: 2,\n                                            color:\n                                                Theme.of(context).dividerColor),\n                                      ),\n                                      child: Align(\n                                        alignment: Alignment.centerLeft,\n                                        child: Text(\n                                          model.language.displayName(context),\n                                          style: Theme.of(context)\n                                              .textTheme\n                                              .titleLarge,\n                                        ),\n                                      ),\n                                    ),\n                                  ],\n                                ),\n                              Align(\n                                alignment: Alignment.centerLeft,\n                                child: Text(\"Voices\",\n                                    style: TextStyle(\n                                      color: Theme.of(context)\n                                          .colorScheme\n                                          .secondary,\n                                      fontWeight: FontWeight.bold,\n                                    )),\n                              ),\n                            ],\n                          ),\n                        ),\n                        SwitchListTile.adaptive(\n                          title: const Text('Per-viewer voice'),\n                          subtitle:\n                              const Text('Identify your viewers by voice'),\n                          value: model.isRandomVoiceEnabled,\n                          onChanged: (value) {\n                            model.isRandomVoiceEnabled = value;\n                          },\n                        ),\n                        Padding(\n                          padding: const EdgeInsets.symmetric(horizontal: 16),\n                          child: Column(\n                            crossAxisAlignment: CrossAxisAlignment.start,\n                            children: [\n                              OutlinedButton(\n                                onPressed: model.isRandomVoiceEnabled\n                                    ? null\n                                    : () {\n                                        Navigator.pushNamed(context,\n                                            '/settings/text-to-speech/voices');\n                                      },\n                                style: OutlinedButton.styleFrom(\n                                  textStyle:\n                                      Theme.of(context).textTheme.titleLarge,\n                                  side: BorderSide(\n                                      width: 2,\n                                      color: Theme.of(context).dividerColor),\n                                ).copyWith(\n                                  foregroundColor:\n                                      WidgetStateProperty.resolveWith<Color>(\n                                    (Set<WidgetState> states) =>\n                                        states.contains(WidgetState.disabled)\n                                            ? Theme.of(context)\n                                                .colorScheme\n                                                .onSurface\n                                                .withOpacity(0.6)\n                                            : Theme.of(context)\n                                                .colorScheme\n                                                .onSurface,\n                                  ),\n                                ),\n                                child: Align(\n                                  alignment: Alignment.centerLeft,\n                                  child: Text(\n                                    model.isRandomVoiceEnabled\n                                        ? 'Random'\n                                        : model.voice,\n                                  ),\n                                ),\n                              ),\n                            ],\n                          ),\n                        ),\n                      ],\n                    ),\n                ],\n              ),\n            const SizedBox(height: 8),\n            Center(\n              child: ElevatedButton(\n                onPressed: () async {\n                  if (model.isCloudTtsEnabled) {\n                    final response = await FirebaseFunctions.instance\n                        .httpsCallable(\"synthesize\")({\n                      \"voice\": model.voice,\n                      \"rate\": model.speed * 1.5 + 0.5,\n                      \"pitch\": model.pitch * 4 - 2,\n                      \"text\": AppLocalizations.of(context)!.sampleMessage,\n                    });\n                    final bytes = const Base64Decoder().convert(response.data);\n                    audioPlayer.setAudioSource(BytesAudioSource(bytes));\n                    audioPlayer.play();\n                  } else {\n                    model.say(\n                        AppLocalizations.of(context)!,\n                        SystemMessageModel(\n                          text: AppLocalizations.of(context)!.sampleMessage,\n                        ),\n                        force: true);\n                  }\n                },\n                child: const Text(\"Play sample message\"),\n              ),\n            ),\n            const SizedBox(height: 8),\n            Padding(\n              padding: const EdgeInsets.symmetric(horizontal: 16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\"Text to Speech Rate\",\n                      style: TextStyle(\n                        color: Theme.of(context).colorScheme.secondary,\n                        fontWeight: FontWeight.bold,\n                      )),\n                  Slider.adaptive(\n                    value: model.speed,\n                    min: 0.0,\n                    max: 1.0,\n                    label: \"speed: ${model.speed}\",\n                    onChanged: (value) {\n                      model.speed = value;\n                    },\n                  ),\n                  Text(\"Text to Speech Pitch\",\n                      style: TextStyle(\n                        color: Theme.of(context).colorScheme.secondary,\n                        fontWeight: FontWeight.bold,\n                      )),\n                  Slider.adaptive(\n                    value: model.pitch,\n                    min: 0.1,\n                    max: 2,\n                    label: \"${model.pitch}\",\n                    onChanged:\n                        model.isRandomVoiceEnabled && model.isCloudTtsEnabled\n                            ? null\n                            : (value) {\n                                model.pitch = value;\n                              },\n                  ),\n                  if (kDebugMode && !model.isCloudTtsEnabled)\n                    Column(\n                      children: [\n                        const SizedBox(height: 8),\n                        Center(\n                          child: ElevatedButton(\n                            onPressed: () => Navigator.pushNamed(\n                              context,\n                              '/settings/text-to-speech/cloud-tts',\n                            ),\n                            child: Text.rich(\n                              TextSpan(\n                                children: [\n                                  const TextSpan(\n                                      text: 'Unlock high-quality voices'),\n                                  const WidgetSpan(child: SizedBox(width: 8)),\n                                  WidgetSpan(\n                                    child: Icon(\n                                      Icons.lock_open_outlined,\n                                      color: Theme.of(context)\n                                          .colorScheme\n                                          .onPrimary,\n                                    ),\n                                  ),\n                                ],\n                              ),\n                            ),\n                          ),\n                        ),\n                      ],\n                    ),\n                ],\n              ),\n            ),\n            SwitchListTile.adaptive(\n              title: const Text('Mute text to speech for bots'),\n              value: model.isBotMuted,\n              onChanged: (value) {\n                model.isBotMuted = value;\n              },\n            ),\n            SwitchListTile.adaptive(\n              title: const Text('Mute all emotes in text to speech'),\n              value: model.isEmoteMuted,\n              onChanged: (value) {\n                model.isEmoteMuted = value;\n              },\n            ),\n            SwitchListTile.adaptive(\n              title: const Text(\"Mute viewer names in text to speech\"),\n              value: model.isPreludeMuted,\n              onChanged: (value) {\n                model.isPreludeMuted = value;\n              },\n            )\n          ],\n        );\n      }),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/qr.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:qr_flutter/qr_flutter.dart';\nimport 'package:rtchat/models/qr_code.dart';\nimport 'package:rtchat/models/user.dart';\n\nclass QRDisplay extends StatelessWidget {\n  const QRDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final querySize = MediaQuery.of(context).size;\n\n    final isLandScape = querySize.width > querySize.height;\n\n    return Consumer<UserModel>(builder: (context, userModel, child) {\n      final userChannel = userModel.userChannel;\n\n      final inviteLink =\n          \"https://www.twitch.tv/${userModel.userChannel?.displayName ?? \"\"}\";\n\n      return Consumer<QRModel>(\n        builder: (context, qrModel, child) {\n          return GestureDetector(\n            onTap: () {\n              qrModel.changeGradient();\n            },\n            child: Column(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                Flexible(\n                  child: Container(\n                    padding: EdgeInsets.only(\n                      top: querySize.height * 0.03,\n                    ),\n                    child: Container(\n                      padding: EdgeInsets.only(\n                        top: querySize.height * 0.02,\n                      ),\n                      decoration: BoxDecoration(\n                        color: Colors.white,\n                        borderRadius: BorderRadius.circular(25),\n                      ),\n                      child: Stack(\n                        alignment: Alignment.center,\n                        children: [\n                          QrImageView(\n                            data: inviteLink,\n                            eyeStyle: const QrEyeStyle(\n                              eyeShape: QrEyeShape.square,\n                              color: Colors.black,\n                            ),\n                            dataModuleStyle: const QrDataModuleStyle(\n                              dataModuleShape: QrDataModuleShape.square,\n                              color: Colors.black,\n                            ),\n                          ),\n                          CircleAvatar(\n                            radius: isLandScape ? 25 : 30,\n                            backgroundImage: userChannel?.profilePicture,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                ),\n                Padding(\n                  padding: EdgeInsets.only(top: querySize.height * 0.01),\n                  child: Text(\n                    \"/${userModel.userChannel?.displayName ?? \"\"}\",\n                    overflow: TextOverflow.fade,\n                    style: const TextStyle(\n                      color: Colors.white,\n                      fontSize: 29,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n          );\n        },\n      );\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/dismissible_delete_background.dart",
    "content": "import 'package:flutter/material.dart';\n\nclass DismissibleDeleteBackground extends StatelessWidget {\n  const DismissibleDeleteBackground({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n        color: Colors.red,\n        child: const Padding(\n            padding: EdgeInsets.symmetric(horizontal: 16),\n            child: Row(\n                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                children: [Icon(Icons.delete), Icon(Icons.delete)])));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/activity_feed.dart",
    "content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/scanner_error.dart';\nimport 'package:rtchat/components/scanner_settings.dart';\nimport 'package:rtchat/models/activity_feed.dart';\nimport 'package:rtchat/models/layout.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\nimport 'package:webview_flutter_android/webview_flutter_android.dart';\nimport 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';\n\nenum ActivityFeedType { disabled, standard, custom }\n\nclass ActivityFeedScreen extends StatefulWidget {\n  const ActivityFeedScreen({super.key});\n\n  @override\n  State<ActivityFeedScreen> createState() => _ActivityFeedScreenState();\n}\n\nclass _ActivityFeedScreenState extends State<ActivityFeedScreen> {\n  final _textEditingController = TextEditingController();\n  late final WebViewController _controller;\n  var _showControls = true;\n  final _formKey = GlobalKey<FormState>();\n  MobileScannerController _scanController = MobileScannerController(\n    // facing: CameraFacing.back,\n    // torchEnabled: false,\n    detectionSpeed: DetectionSpeed.noDuplicates,\n  );\n\n  @override\n  void initState() {\n    super.initState();\n\n    _textEditingController.text =\n        Provider.of<ActivityFeedModel>(context, listen: false).customUrl;\n\n    if (WebViewPlatform.instance is WebKitWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          WebKitWebViewControllerCreationParams(\n        allowsInlineMediaPlayback: true,\n        mediaTypesRequiringUserAction: const {},\n      ));\n    } else if (WebViewPlatform.instance is AndroidWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          AndroidWebViewControllerCreationParams());\n    } else {\n      throw UnsupportedError(\"Unsupported platform\");\n    }\n\n    _controller\n      ..setJavaScriptMode(JavaScriptMode.unrestricted)\n      ..enableZoom(false);\n  }\n\n  @override\n  void dispose() {\n    _textEditingController.dispose();\n\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: _showControls\n          ? AppBar(\n              title: Text(AppLocalizations.of(context)!.activityFeed),\n              actions: [\n                IconButton(\n                  icon: const Icon(Icons.cookie_outlined),\n                  tooltip: AppLocalizations.of(context)!.clearCookies,\n                  onPressed: () async {\n                    final cookieManager = WebViewCookieManager();\n                    if (await cookieManager.clearCookies()) {\n                      _controller.reload();\n                    }\n                  },\n                ),\n              ],\n            )\n          : null,\n      body: SafeArea(\n        child: Consumer3<ActivityFeedModel, UserModel, LayoutModel>(builder:\n            (context, activityFeedModel, userModel, layoutModel, child) {\n          Uri? uri;\n\n          final channel = userModel.userChannel;\n          if (activityFeedModel.isCustom) {\n            final tryUri = Uri.tryParse(activityFeedModel.customUrl);\n            if (tryUri != null) {\n              uri = tryUri.scheme.isEmpty\n                  ? Uri.tryParse(\"https://$tryUri\")\n                  : tryUri;\n            }\n          } else if (channel != null) {\n            switch (channel.provider) {\n              case \"twitch\":\n                uri = Uri.tryParse(\n                    \"https://dashboard.twitch.tv/popout/u/${channel.displayName}/stream-manager/activity-feed\");\n            }\n          }\n\n          if (uri != null) {\n            _controller.loadRequest(uri);\n          } else {\n            _controller.loadHtmlString(\" \");\n          }\n\n          return Column(children: [\n            if (_showControls)\n              RadioListTile(\n                title: Text(AppLocalizations.of(context)!.disabled),\n                value: true,\n                groupValue: !activityFeedModel.isEnabled,\n                onChanged: (value) {\n                  activityFeedModel.isEnabled = false;\n                  layoutModel.isShowNotifications = false;\n                },\n              ),\n            if (_showControls)\n              RadioListTile(\n                title: Text(AppLocalizations.of(context)!.twitchActivityFeed),\n                subtitle: userModel.isSignedIn()\n                    ? null\n                    : Text(AppLocalizations.of(context)!.signInToEnable),\n                value: true,\n                groupValue:\n                    activityFeedModel.isEnabled && !activityFeedModel.isCustom,\n                onChanged: userModel.isSignedIn()\n                    ? (value) {\n                        activityFeedModel.isEnabled = true;\n                        activityFeedModel.isCustom = false;\n                      }\n                    : null,\n              ),\n            if (_showControls)\n              RadioListTile(\n                title: Form(\n                  key: _formKey,\n                  child: TextFormField(\n                      controller: _textEditingController,\n                      decoration: InputDecoration(\n                          hintText: AppLocalizations.of(context)!.customUrl,\n                          suffixIcon: IconButton(\n                            icon: const Icon(Icons.qr_code_scanner),\n                            onPressed: () {\n                              final messenger = ScaffoldMessenger.of(context);\n\n                              showModalBottomSheet(\n                                isScrollControlled: true,\n                                context: context,\n                                builder: (ctx) {\n                                  return Stack(\n                                    children: [\n                                      MobileScanner(\n                                        errorBuilder: (context, error, child) {\n                                          return ScannerErrorWidget(\n                                              error: error);\n                                        },\n                                        controller: _scanController,\n                                        onDetect: (capture) {\n                                          final List<Barcode> barcodes =\n                                              capture.barcodes;\n\n                                          if (barcodes.isEmpty) {\n                                            messenger.showSnackBar(SnackBar(\n                                                content: Text(\n                                                    AppLocalizations.of(\n                                                            context)!\n                                                        .invalidUrlErrorText)));\n                                          }\n\n                                          final barcode = barcodes.first;\n\n                                          if (barcode.rawValue == null ||\n                                              barcode.rawValue!.isEmpty) {\n                                            messenger.showSnackBar(SnackBar(\n                                                content: Text(\n                                                    AppLocalizations.of(\n                                                            context)!\n                                                        .invalidUrlErrorText)));\n\n                                            Navigator.pop(ctx);\n                                          }\n\n                                          _textEditingController.text =\n                                              '${barcode.rawValue}';\n\n                                          Navigator.pop(ctx);\n                                        },\n                                      ),\n                                      Positioned(\n                                        top: 50,\n                                        left: 0,\n                                        right: 0,\n                                        child: ScannerSettings(\n                                            scanController: _scanController),\n                                      ),\n                                    ],\n                                  );\n                                },\n                              ).then((value) {\n                                _scanController.dispose();\n\n                                //re initialize controller\n                                _scanController = MobileScannerController(\n                                  detectionSpeed: DetectionSpeed.noDuplicates,\n                                );\n                              });\n                            },\n                          ),\n                          errorText:\n                              Uri.tryParse(activityFeedModel.customUrl) == null\n                                  ? \"That's not a valid URL\"\n                                  : null),\n                      validator: (value) {\n                        if (value != null && Uri.tryParse(value) == null) {\n                          return AppLocalizations.of(context)!\n                              .invalidUrlErrorText;\n                        }\n                        return null;\n                      },\n                      onChanged: (value) {\n                        activityFeedModel.isEnabled =\n                            Uri.tryParse(value) != null;\n                        activityFeedModel.customUrl = value;\n                        activityFeedModel.isCustom = true;\n                        _formKey.currentState?.validate();\n                      }),\n                ),\n                value: true,\n                groupValue:\n                    activityFeedModel.isEnabled && activityFeedModel.isCustom,\n                onChanged: (value) {\n                  final uri = Uri.tryParse(activityFeedModel.customUrl);\n                  activityFeedModel.isEnabled = uri != null;\n                  activityFeedModel.isCustom = true;\n                },\n              ),\n            GestureDetector(\n                onTap: () {\n                  setState(() {\n                    _showControls = !_showControls;\n                  });\n                },\n                child: Padding(\n                    padding: const EdgeInsets.only(top: 16),\n                    child: Row(\n                        mainAxisAlignment: MainAxisAlignment.center,\n                        children: [\n                          Icon(_showControls\n                              ? Icons.unfold_more\n                              : Icons.unfold_less),\n                          Text(AppLocalizations.of(context)!.preview),\n                        ]))),\n            activityFeedModel.isEnabled\n                ? Expanded(\n                    child: Padding(\n                        padding: _showControls\n                            ? const EdgeInsets.all(16)\n                            : const EdgeInsets.only(top: 16),\n                        child: WebViewWidget(\n                          controller: _controller,\n                          gestureRecognizers: {\n                            Factory<OneSequenceGestureRecognizer>(\n                                () => EagerGestureRecognizer()),\n                          },\n                        )),\n                  )\n                : Container(),\n          ]);\n        }),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/audio_sources.dart",
    "content": "import 'dart:io';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:metadata_fetch/metadata_fetch.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/audio_channel.dart';\nimport 'package:rtchat/components/scanner_error.dart';\nimport 'package:rtchat/components/scanner_settings.dart';\nimport 'package:rtchat/models/audio.dart';\nimport 'package:rtchat/screens/settings/dismissible_delete_background.dart';\n\nclass AudioSourcesScreen extends StatefulWidget {\n  const AudioSourcesScreen({super.key});\n\n  @override\n  State<AudioSourcesScreen> createState() => _AudioSourcesScreenState();\n}\n\nclass _AudioSourcesScreenState extends State<AudioSourcesScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _textEditingController = TextEditingController();\n  late final AudioModel _audioModel;\n  MobileScannerController _scanController = MobileScannerController(\n    // facing: CameraFacing.back,\n    // torchEnabled: false,\n    detectionSpeed: DetectionSpeed.noDuplicates,\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    _audioModel = Provider.of<AudioModel>(context, listen: false);\n    // tell the audio model we're on the settings page.\n    _audioModel.isSettingsVisible = true;\n  }\n\n  @override\n  void dispose() {\n    // tell the audio model we're off the settings page.\n    _audioModel.isSettingsVisible = false;\n    super.dispose();\n  }\n\n  void add() async {\n    if (_formKey.currentState!.validate()) {\n      // fetch the title for the page.\n      final url = _textEditingController.text;\n      Metadata? metadata;\n      try {\n        metadata = await MetadataFetch.extract(url);\n      } catch (e) {\n        metadata = null;\n      }\n\n      final title = metadata?.title ?? Uri.parse(url).host;\n\n      if (!mounted) return;\n      final model = Provider.of<AudioModel>(context, listen: false);\n      if (!await AudioChannel.hasPermission()) {\n        if (!mounted) return;\n        await model.showAudioPermissionDialog(context);\n      }\n      await model.addSource(AudioSource(title, Uri.parse(url), false));\n\n      if (!mounted) return;\n      _textEditingController.clear();\n      FocusScope.of(context).unfocus();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(AppLocalizations.of(context)!.audioSources)),\n      body: SafeArea(\n        child: Consumer<AudioModel>(builder: (context, model, child) {\n          return Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                SwitchListTile.adaptive(\n                  title: Text(\n                      AppLocalizations.of(context)!.enableOffStreamSwitchTitle),\n                  subtitle: model.isAlwaysEnabled\n                      ? Text(AppLocalizations.of(context)!\n                          .enableOffStreamSwitchEnabledSubtitle)\n                      : Text(AppLocalizations.of(context)!\n                          .enableOffStreamSwitchDisabledSubtitle),\n                  value: model.isAlwaysEnabled,\n                  onChanged: (value) {\n                    model.isAlwaysEnabled = value;\n                  },\n                ),\n                const Divider(),\n                if (Platform.isIOS)\n                  ListTile(\n                    leading: const Icon(Icons.warning),\n                    title:\n                        Text(AppLocalizations.of(context)!.iosOggWarningTitle),\n                    subtitle: Text(\n                        AppLocalizations.of(context)!.iosOggWarningSubtitle),\n                    tileColor: Colors.yellow,\n                    textColor: Colors.black,\n                  )\n                else\n                  Container(),\n                Expanded(\n                  child: ListView(\n                    children: model.sources.map((source) {\n                      final name = source.name;\n                      return Dismissible(\n                        key: ValueKey(source),\n                        background: const DismissibleDeleteBackground(),\n                        child: CheckboxListTile.adaptive(\n                            title: name == null\n                                ? Text(source.url.toString())\n                                : Text(name),\n                            subtitle: name == null\n                                ? null\n                                : Text(source.url.toString()),\n                            value: !source.muted,\n                            onChanged: (value) {\n                              model.toggleSource(source);\n                            }),\n                        onDismissed: (direction) {\n                          model.removeSource(source);\n                        },\n                      );\n                    }).toList(),\n                  ),\n                ),\n                const Divider(),\n                Padding(\n                  padding: const EdgeInsets.only(left: 16, bottom: 16),\n                  child: Form(\n                    key: _formKey,\n                    child: Row(children: [\n                      Expanded(\n                        child: TextFormField(\n                            controller: _textEditingController,\n                            decoration: InputDecoration(\n                                hintText: AppLocalizations.of(context)!.url,\n                                suffixIcon: IconButton(\n                                    icon: const Icon(Icons.qr_code_scanner),\n                                    onPressed: () {\n                                      final messenger =\n                                          ScaffoldMessenger.of(context);\n\n                                      showModalBottomSheet(\n                                        isScrollControlled: true,\n                                        context: context,\n                                        builder: (ctx) {\n                                          return Stack(\n                                            children: [\n                                              MobileScanner(\n                                                errorBuilder:\n                                                    (context, error, child) {\n                                                  return ScannerErrorWidget(\n                                                      error: error);\n                                                },\n                                                controller: _scanController,\n                                                onDetect: (capture) {\n                                                  final List<Barcode> barcodes =\n                                                      capture.barcodes;\n\n                                                  if (barcodes.isEmpty) {\n                                                    messenger.showSnackBar(SnackBar(\n                                                        content: Text(\n                                                            AppLocalizations.of(\n                                                                    context)!\n                                                                .invalidUrlErrorText)));\n                                                  }\n\n                                                  final barcode =\n                                                      barcodes.first;\n\n                                                  if (barcode.rawValue ==\n                                                          null ||\n                                                      barcode\n                                                          .rawValue!.isEmpty) {\n                                                    messenger.showSnackBar(SnackBar(\n                                                        content: Text(\n                                                            AppLocalizations.of(\n                                                                    context)!\n                                                                .invalidUrlErrorText)));\n\n                                                    Navigator.pop(ctx);\n                                                  }\n\n                                                  _textEditingController.text =\n                                                      '${barcode.rawValue}';\n\n                                                  Navigator.pop(ctx);\n                                                },\n                                              ),\n                                              Positioned(\n                                                  top: 50,\n                                                  left: 0,\n                                                  right: 0,\n                                                  child: ScannerSettings(\n                                                      scanController:\n                                                          _scanController)),\n                                            ],\n                                          );\n                                        },\n                                      ).then((value) {\n                                        _scanController.dispose();\n\n                                        //re initialize controller\n                                        _scanController =\n                                            MobileScannerController(\n                                          detectionSpeed:\n                                              DetectionSpeed.noDuplicates,\n                                        );\n                                      });\n                                    })),\n                            validator: (value) {\n                              if (value == null ||\n                                  value.isEmpty ||\n                                  Uri.tryParse(value) == null) {\n                                return AppLocalizations.of(context)!\n                                    .invalidUrlErrorText;\n                              }\n                              return null;\n                            },\n                            keyboardType: TextInputType.url,\n                            textInputAction: TextInputAction.done,\n                            onEditingComplete: add),\n                      ),\n                      IconButton(icon: const Icon(Icons.add), onPressed: add),\n                    ]),\n                  ),\n                ),\n              ]);\n        }),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/quick_links.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:metadata_fetch/metadata_fetch.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/scanner_error.dart';\nimport 'package:rtchat/components/scanner_settings.dart';\nimport 'package:rtchat/models/quick_links.dart';\nimport 'package:rtchat/screens/settings/dismissible_delete_background.dart';\n\nclass QuickLinksScreen extends StatefulWidget {\n  const QuickLinksScreen({super.key});\n\n  @override\n  State<QuickLinksScreen> createState() => _QuickLinksScreenState();\n}\n\nconst quickLinksIconsMap = {\n  \"home\": Icons.home_outlined,\n  \"manage_accounts\": Icons.manage_accounts_outlined,\n  \"account_balance\": Icons.account_balance_outlined,\n  \"view_list\": Icons.view_list_outlined,\n  \"code\": Icons.code_outlined,\n  \"analytics\": Icons.analytics_outlined,\n  \"store\": Icons.store_outlined,\n  \"receipt\": Icons.receipt_outlined,\n  \"gavel\": Icons.gavel_outlined,\n  \"rule\": Icons.rule_outlined,\n  \"sensors\": Icons.sensors_outlined,\n  \"speaker_notes\": Icons.speaker_notes_outlined,\n  \"settings_input_antenna\": Icons.settings_input_antenna_outlined,\n  \"settings_input_component\": Icons.settings_input_component_outlined,\n  \"donut_small\": Icons.donut_small_outlined,\n  \"online_prediction\": Icons.online_prediction_outlined,\n  \"link\": Icons.link_outlined,\n};\n\nclass _QuickLinksScreenState extends State<QuickLinksScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _textEditingController = TextEditingController();\n  final _labelEditingController = TextEditingController();\n  String _activeIcon = \"view_list\";\n  String _url = \"\";\n  MobileScannerController _scanController = MobileScannerController(\n    // facing: CameraFacing.back,\n    // torchEnabled: false,\n    detectionSpeed: DetectionSpeed.noDuplicates,\n  );\n\n  @override\n  void initState() {\n    super.initState();\n\n    _textEditingController.addListener(() {\n      setState(() => _url = _textEditingController.text);\n    });\n  }\n\n  @override\n  void dispose() {\n    _textEditingController.dispose();\n    _labelEditingController.dispose();\n\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(AppLocalizations.of(context)!.quickLinks)),\n      body: SafeArea(\n        child: Column(children: [\n          Expanded(child:\n              Consumer<QuickLinksModel>(builder: (context, quickLinks, child) {\n            return ReorderableListView(\n              onReorder: quickLinks.swapSource,\n              children: quickLinks.sources.map((source) {\n                return Dismissible(\n                  key: ValueKey(source),\n                  background: const DismissibleDeleteBackground(),\n                  child: Tooltip(\n                      triggerMode: TooltipTriggerMode.tap,\n                      message:\n                          AppLocalizations.of(context)!.swipeToDeleteQuickLinks,\n                      child: ListTile(\n                        key: ValueKey(source),\n                        leading:\n                            Icon(quickLinksIconsMap[source.icon] ?? Icons.link),\n                        title: Text(source.label),\n                        subtitle: Text(source.url.toString()),\n                        trailing: const Icon(Icons.drag_handle),\n                      )),\n                  onDismissed: (direction) {\n                    quickLinks.removeSource(source);\n                  },\n                );\n              }).toList(),\n            );\n          })),\n          const Divider(),\n          Padding(\n            padding: const EdgeInsets.only(bottom: 16),\n            child: Form(\n                key: _formKey,\n                child: Column(children: [\n                  Row(crossAxisAlignment: CrossAxisAlignment.end, children: [\n                    PopupMenuButton<String>(\n                      icon: Icon(quickLinksIconsMap[_activeIcon] ?? Icons.link),\n                      onSelected: (result) {\n                        setState(() {\n                          _activeIcon = result;\n                        });\n                      },\n                      itemBuilder: (context) {\n                        final entries = quickLinksIconsMap.entries.toList()\n                          ..sort((a, b) => a.key.compareTo(b.key));\n                        return entries\n                            .map((entry) => PopupMenuItem(\n                                value: entry.key, child: Icon(entry.value)))\n                            .toList();\n                      },\n                    ),\n                    Expanded(\n                      child: Column(children: [\n                        _url.isNotEmpty\n                            ? FutureBuilder<String>(\n                                future: retrieveName(_url),\n                                builder: (context, snapshot) {\n                                  return TextFormField(\n                                    controller: _labelEditingController,\n                                    decoration: InputDecoration(\n                                      hintText: snapshot.data ??\n                                          AppLocalizations.of(context)!\n                                              .quickLinksLabelHint,\n                                    ),\n                                  );\n                                },\n                              )\n                            : Container(),\n                        TextFormField(\n                            controller: _textEditingController,\n                            decoration: InputDecoration(\n                                hintText: \"URL\",\n                                suffixIcon: IconButton(\n                                    icon: const Icon(Icons.qr_code_scanner),\n                                    onPressed: () {\n                                      final messenger =\n                                          ScaffoldMessenger.of(context);\n\n                                      showModalBottomSheet(\n                                        isScrollControlled: true,\n                                        context: context,\n                                        builder: (ctx) {\n                                          return Stack(\n                                            children: [\n                                              MobileScanner(\n                                                errorBuilder:\n                                                    (context, error, child) {\n                                                  return ScannerErrorWidget(\n                                                      error: error);\n                                                },\n                                                controller: _scanController,\n                                                onDetect: (capture) {\n                                                  final List<Barcode> barcodes =\n                                                      capture.barcodes;\n\n                                                  if (barcodes.isEmpty) {\n                                                    messenger.showSnackBar(SnackBar(\n                                                        content: Text(\n                                                            AppLocalizations.of(\n                                                                    context)!\n                                                                .invalidUrlErrorText)));\n                                                  }\n\n                                                  final barcode =\n                                                      barcodes.first;\n\n                                                  if (barcode.rawValue ==\n                                                          null ||\n                                                      barcode\n                                                          .rawValue!.isEmpty) {\n                                                    messenger.showSnackBar(SnackBar(\n                                                        content: Text(\n                                                            AppLocalizations.of(\n                                                                    context)!\n                                                                .invalidUrlErrorText)));\n\n                                                    Navigator.pop(ctx);\n                                                  }\n\n                                                  _textEditingController.text =\n                                                      '${barcode.rawValue}';\n\n                                                  Navigator.pop(ctx);\n                                                },\n                                              ),\n                                              Positioned(\n                                                top: 50,\n                                                left: 0,\n                                                right: 0,\n                                                child: ScannerSettings(\n                                                    scanController:\n                                                        _scanController),\n                                              ),\n                                            ],\n                                          );\n                                        },\n                                      ).then((value) {\n                                        _scanController.dispose();\n\n                                        //re initialize controller\n                                        _scanController =\n                                            MobileScannerController(\n                                          detectionSpeed:\n                                              DetectionSpeed.noDuplicates,\n                                        );\n                                      });\n                                    })),\n                            validator: (value) {\n                              if (value == null ||\n                                  value.isEmpty ||\n                                  Uri.tryParse(value) == null) {\n                                return AppLocalizations.of(context)!\n                                    .invalidUrlErrorText;\n                              }\n                              final quickLinksModel =\n                                  Provider.of<QuickLinksModel>(context,\n                                      listen: false);\n                              if (quickLinksModel.sources.any((s) =>\n                                  s.url.toString() == Uri.encodeFull(value))) {\n                                return AppLocalizations.of(context)!\n                                    .duplicateUrlErrorText;\n                              }\n                              return null;\n                            },\n                            keyboardType: TextInputType.url,\n                            textInputAction: TextInputAction.done,\n                            onEditingComplete: addLink),\n                      ]),\n                    ),\n                    IconButton(\n                      icon: const Icon(Icons.add),\n                      onPressed: addLink,\n                    )\n                  ]),\n                ])),\n          ),\n        ]),\n      ),\n    );\n  }\n\n  Future<String> retrieveName(String url) async {\n    try {\n      final metadata = await MetadataFetch.extract(url);\n      return metadata?.title ?? url;\n    } catch (e) {\n      return url;\n    }\n  }\n\n  void addLink() async {\n    if (!_formKey.currentState!.validate()) {\n      return;\n    }\n    final model = Provider.of<QuickLinksModel>(context, listen: false);\n    final focus = FocusScope.of(context);\n    final label = _labelEditingController.text.isEmpty\n        ? await retrieveName(_url)\n        : _labelEditingController.text;\n    model.addSource(QuickLinkSource(\n        _activeIcon, Uri.parse(_textEditingController.text), label));\n    _textEditingController.clear();\n    _labelEditingController.clear();\n    focus.unfocus();\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/settings/third_party.dart",
    "content": "import 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:flutter_web_auth/flutter_web_auth.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/scanner_error.dart';\nimport 'package:rtchat/components/scanner_settings.dart';\nimport 'package:rtchat/models/adapters/donations.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/urls.dart';\n\nconst streamlabsCurrencies = [\n  [null, \"Donation's currency\"],\n  ['AUD', 'Australian Dollar'],\n  ['BRL', 'Brazilian Real'],\n  ['CAD', 'Canadian Dollar'],\n  ['CZK', 'Czech Koruna'],\n  ['DKK', 'Danish Krone'],\n  ['EUR', 'Euro'],\n  ['HKD', 'Hong Kong Dollar'],\n  ['ILS', 'Israeli New Sheqel'],\n  ['MYR', 'Malaysian Ringgit'],\n  ['MXN', 'Mexican Peso'],\n  ['NOK', 'Norwegian Krone'],\n  ['NZD', 'New Zealand Dollar'],\n  ['PHP', 'Philippine Peso'],\n  ['PLN', 'Polish Zloty'],\n  ['GBP', 'Pound Sterling'],\n  ['RUB', 'Russian Ruble'],\n  ['SGD', 'Singapore Dollar'],\n  ['SEK', 'Swedish Krona'],\n  ['CHF', 'Swiss Franc'],\n  ['THB', 'Thai Baht'],\n  ['TRY', 'Turkish Lira'],\n  ['USD', 'US Dollar']\n];\n\nclass _RealtimeCashWidget extends StatefulWidget {\n  final String userId;\n\n  const _RealtimeCashWidget({required this.userId});\n\n  @override\n  State<_RealtimeCashWidget> createState() => _RealtimeCashWidgetState();\n}\n\nclass _RealtimeCashWidgetState extends State<_RealtimeCashWidget> {\n  var _scanController = MobileScannerController(\n    // facing: CameraFacing.back,\n    // torchEnabled: false,\n    detectionSpeed: DetectionSpeed.noDuplicates,\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<String?>(\n      stream: DonationsAdapter.instance\n          .forRealtimeChatAddress(userId: widget.userId),\n      builder: (context, snapshot) {\n        return Column(children: [\n          ListTile(\n            leading: const Image(image: AssetImage('assets/realtimecash.png')),\n            title: const Text(\"RealtimeCash\"),\n            subtitle: const Text(\"Connect an ETH or MATIC wallet\"),\n            trailing: SizedBox(\n              width: 24,\n              height: 24,\n              child: snapshot.data != null\n                  ? const Icon(\n                      Icons.check_circle,\n                      color: Colors.green,\n                    )\n                  : const Icon(Icons.help),\n            ),\n            // open https://cash.rtirl.com/\n            onTap: () => openUrl(Uri.parse(\"https://cash.rtirl.com/\")),\n          ),\n          Padding(\n            padding: const EdgeInsets.only(left: 88, right: 16),\n            child: TextField(\n                controller: TextEditingController()..text = snapshot.data ?? \"\",\n                readOnly: true,\n                decoration: InputDecoration(\n                    hintText: \"Wallet address\",\n                    suffixIcon: IconButton(\n                        icon: const Icon(Icons.qr_code_scanner),\n                        onPressed: () {\n                          final messenger = ScaffoldMessenger.of(context);\n\n                          showModalBottomSheet(\n                            isScrollControlled: true,\n                            context: context,\n                            builder: (ctx) {\n                              return Stack(\n                                children: [\n                                  MobileScanner(\n                                    errorBuilder: (context, error, child) {\n                                      return ScannerErrorWidget(error: error);\n                                    },\n                                    controller: _scanController,\n                                    onDetect: (capture) {\n                                      final List<Barcode> barcodes =\n                                          capture.barcodes;\n\n                                      if (barcodes.isEmpty) {\n                                        messenger.showSnackBar(SnackBar(\n                                            content: Text(\n                                                AppLocalizations.of(context)!\n                                                    .invalidUrlErrorText)));\n                                      }\n\n                                      final barcode = barcodes.first;\n\n                                      if (barcode.rawValue == null ||\n                                          barcode.rawValue!.isEmpty) {\n                                        messenger.showSnackBar(SnackBar(\n                                            content: Text(\n                                                AppLocalizations.of(context)!\n                                                    .invalidUrlErrorText)));\n\n                                        Navigator.pop(ctx);\n                                      }\n\n                                      DonationsAdapter.instance\n                                          .setRealtimeCashAddress(\n                                              address: barcode.rawBytes\n                                                  .toString()\n                                                  .toLowerCase());\n\n                                      Navigator.pop(ctx);\n                                    },\n                                  ),\n                                  Positioned(\n                                      top: 50,\n                                      left: 0,\n                                      right: 0,\n                                      child: ScannerSettings(\n                                        scanController: _scanController,\n                                      )),\n                                ],\n                              );\n                            },\n                          ).then((value) {\n                            _scanController.dispose();\n\n                            _scanController = MobileScannerController(\n                              detectionSpeed: DetectionSpeed.noDuplicates,\n                            );\n                          });\n                        })),\n                keyboardType: TextInputType.url),\n          ),\n        ]);\n      },\n    );\n  }\n}\n\nclass _StreamlabsWidget extends StatelessWidget {\n  final String userId;\n\n  const _StreamlabsWidget({required this.userId});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      leading: const Image(image: AssetImage('assets/streamlabs.png')),\n      trailing: SizedBox(\n        width: 24,\n        height: 24,\n        child: StreamBuilder(\n          stream: DonationsAdapter.instance.forStreamlabsConfig(userId: userId),\n          builder: (context, snapshot) {\n            return snapshot.data != null\n                ? const Icon(\n                    Icons.check_circle,\n                    color: Colors.green,\n                  )\n                : Container();\n          },\n        ),\n      ),\n      title: const Text(\"Streamlabs\"),\n      subtitle: const Text(\"See your Streamlabs donations\"),\n      onTap: () async {\n        final messenger = ScaffoldMessenger.of(context);\n        final userModel = Provider.of<UserModel>(context, listen: false);\n        final idToken = await FirebaseAuth.instance.currentUser?.getIdToken();\n        final provider = userModel.userChannel?.provider;\n        if (provider == null) {\n          messenger.showSnackBar(const SnackBar(\n              content: Text(\n                  \"Some strange authentication error occurred. Try signing out, or ask on Discord?\")));\n          return;\n        }\n        final result = await FlutterWebAuth.authenticate(\n            url:\n                \"https://chat.rtirl.com/auth/streamlabs/redirect?token=$idToken&provider=$provider\",\n            callbackUrlScheme: \"com.rtirl.chat\");\n        final token = Uri.parse(result).queryParameters['token'];\n        if (token == null) {\n          messenger.showSnackBar(const SnackBar(\n            content:\n                Text(\"Hmm, that didn't work. Try again, or ask on Discord?\"),\n          ));\n        }\n      },\n    );\n  }\n}\n\nclass _StreamElementsWidget extends StatelessWidget {\n  final String userId;\n\n  const _StreamElementsWidget({required this.userId});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      leading: const Image(image: AssetImage('assets/streamelements.png')),\n      trailing: SizedBox(\n        width: 24,\n        height: 24,\n        child: StreamBuilder(\n          stream:\n              DonationsAdapter.instance.forStreamElementsConfig(userId: userId),\n          builder: (context, snapshot) {\n            return snapshot.data != null\n                ? const Icon(\n                    Icons.check_circle,\n                    color: Colors.green,\n                  )\n                : Container();\n          },\n        ),\n      ),\n      title: const Text(\"StreamElements\"),\n      subtitle: const Text(\"See your StreamElements donations\"),\n      onTap: () async {\n        final messenger = ScaffoldMessenger.of(context);\n        final userModel = Provider.of<UserModel>(context, listen: false);\n        final idToken = await FirebaseAuth.instance.currentUser?.getIdToken();\n        final provider = userModel.userChannel?.provider;\n        if (provider == null) {\n          messenger.showSnackBar(const SnackBar(\n              content: Text(\n                  \"Some strange authentication error occurred. Try signing out, or ask on Discord?\")));\n          return;\n        }\n        final result = await FlutterWebAuth.authenticate(\n            url:\n                \"https://chat.rtirl.com/auth/streamelements/redirect?token=$idToken&provider=$provider\",\n            callbackUrlScheme: \"com.rtirl.chat\");\n        final token = Uri.parse(result).queryParameters['token'];\n        if (token == null) {\n          messenger.showSnackBar(const SnackBar(\n            content:\n                Text(\"Hmm, that didn't work. Try again, or ask on Discord?\"),\n          ));\n        }\n      },\n    );\n  }\n}\n\nclass ThirdPartyScreen extends StatelessWidget {\n  const ThirdPartyScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(title: const Text(\"Third-party services\")),\n        body: Consumer<UserModel>(\n          builder: (context, userModel, child) {\n            final userId = userModel.user?.uid;\n            if (userId == null) {\n              // the user should be signed in at this point.\n              return Container();\n            }\n            return ListView(\n              children: [\n                _RealtimeCashWidget(userId: userId),\n                const Divider(),\n                _StreamlabsWidget(userId: userId),\n                const Divider(),\n                _StreamElementsWidget(userId: userId),\n              ],\n            );\n          },\n        ));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/onboarding.dart",
    "content": "import 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/auth/twitch.dart';\nimport 'package:rtchat/components/channel_search_bottom_sheet.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/themes.dart';\n\nfinal url = Uri.https('chat.rtirl.com', '/auth/twitch/redirect');\n\nclass OnboardingScreen extends StatelessWidget {\n  final void Function(Channel) onChannelSelect;\n\n  const OnboardingScreen({super.key, required this.onChannelSelect});\n\n  @override\n  Widget build(BuildContext context) {\n    return Theme(\n      data: Themes.darkTheme,\n      child: Scaffold(\n          resizeToAvoidBottomInset: false,\n          backgroundColor: Colors.black,\n          body: SafeArea(\n            child: Center(\n              child: Padding(\n                padding: const EdgeInsets.all(4),\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    const Image(\n                        width: 160, image: AssetImage('assets/logo.png')),\n                    Padding(\n                        padding: const EdgeInsets.only(bottom: 32),\n                        child: Text(\"RealtimeChat\",\n                            style: Theme.of(context)\n                                .textTheme\n                                .titleLarge\n                                ?.copyWith(color: Colors.white))),\n                    LoginOptionsWidget(onChannelSelect: onChannelSelect),\n                  ],\n                ),\n              ),\n            ),\n          )),\n    );\n  }\n}\n\nclass LoginOptionsWidget extends StatefulWidget {\n  final void Function(Channel) onChannelSelect;\n\n  const LoginOptionsWidget({super.key, required this.onChannelSelect});\n\n  @override\n  State<LoginOptionsWidget> createState() => _LoginOptionsWidgetState();\n}\n\nclass _LoginOptionsWidgetState extends State<LoginOptionsWidget> {\n  var _isLoading = false;\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isLoading) {\n      return const CircularProgressIndicator();\n    }\n    return Column(children: [\n      SizedBox(\n        width: 400,\n        child: Padding(\n            padding: const EdgeInsets.symmetric(horizontal: 8),\n            child: SignInWithTwitch(\n              onStart: () {\n                setState(() {\n                  _isLoading = true;\n                });\n              },\n              onComplete: () {\n                if (!mounted) {\n                  return;\n                }\n                setState(() {\n                  _isLoading = false;\n                });\n              },\n            )),\n      ),\n      Text(AppLocalizations.of(context)!.or,\n          style: Theme.of(context)\n              .textTheme\n              .titleMedium\n              ?.copyWith(color: Colors.white)),\n      SizedBox(\n        width: 400,\n        child: Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 8),\n          child: ElevatedButton(\n            child: Text(\n              AppLocalizations.of(context)!.continueAsGuest,\n              textAlign: TextAlign.center,\n            ),\n            onPressed: () async {\n              FirebaseAnalytics.instance.logLogin(loginMethod: \"anonymous\");\n              showModalBottomSheet<void>(\n                context: context,\n                isScrollControlled: true,\n                shape: const RoundedRectangleBorder(\n                  borderRadius: BorderRadius.vertical(top: Radius.circular(16)),\n                ),\n                builder: (context) {\n                  return DraggableScrollableSheet(\n                      initialChildSize: 0.8,\n                      maxChildSize: 0.9,\n                      expand: false,\n                      builder: (context, controller) {\n                        return ChannelSearchBottomSheetWidget(\n                            onChannelSelect: widget.onChannelSelect,\n                            controller: controller);\n                      });\n                },\n              );\n            },\n          ),\n        ),\n      )\n    ]);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/screens/home.dart",
    "content": "import 'dart:math' as math;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/audio_channel.dart';\nimport 'package:rtchat/components/activity_feed_panel.dart';\nimport 'package:rtchat/components/auth/twitch.dart';\nimport 'package:rtchat/components/chat_panel.dart';\nimport 'package:rtchat/components/disco.dart';\nimport 'package:rtchat/components/drawer/end_drawer.dart';\nimport 'package:rtchat/components/drawer/sidebar.dart';\nimport 'package:rtchat/components/header_bar.dart';\nimport 'package:rtchat/components/message_input.dart';\nimport 'package:rtchat/components/stream_preview.dart';\nimport 'package:rtchat/eager_drag_recognizer.dart';\nimport 'package:rtchat/main.dart';\nimport 'package:rtchat/models/activity_feed.dart';\nimport 'package:rtchat/models/audio.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/layout.dart';\nimport 'package:rtchat/models/messages/twitch/emote.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/notifications_plugin.dart';\nimport 'package:rtchat/tts_plugin.dart';\nimport 'package:wakelock_plus/wakelock_plus.dart';\n\nclass ResizableWidget extends StatefulWidget {\n  final bool resizable;\n  final double height;\n  final double width;\n  final Function(double) onResizeHeight;\n  final Function(double) onResizeWidth;\n  final Widget child;\n\n  const ResizableWidget(\n      {super.key,\n      required this.resizable,\n      required this.height,\n      required this.width,\n      required this.onResizeHeight,\n      required this.onResizeWidth,\n      required this.child});\n\n  @override\n  State<ResizableWidget> createState() => _ResizableWidgetState();\n}\n\nclass _ResizableWidgetState extends State<ResizableWidget> {\n  double _height = 0;\n  double _width = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _height = widget.height;\n    _width = widget.width;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final orientation = MediaQuery.of(context).orientation;\n    if (orientation == Orientation.portrait) {\n      return Column(children: [\n        SizedBox(\n          height: _height.clamp(\n              57, math.max(57, MediaQuery.of(context).size.height - 300)),\n          child: widget.child,\n        ),\n        if (widget.resizable)\n          GestureDetector(\n            onVerticalDragStart: (details) {\n              setState(() {\n                _height = widget.height;\n              });\n            },\n            onVerticalDragEnd: (details) {\n              widget.onResizeHeight(_height.clamp(\n                  57, math.max(57, MediaQuery.of(context).size.height - 300)));\n            },\n            onVerticalDragUpdate: (details) {\n              setState(() {\n                _height += details.delta.dy;\n              });\n            },\n            child: const SizedBox(\n              width: double.infinity,\n              height: 30,\n              child: Center(\n                child: Icon(Icons.drag_handle_outlined),\n              ),\n            ),\n          )\n        else\n          Container(),\n      ]);\n    } else {\n      return Row(children: [\n        SizedBox(\n          width: _width.clamp(\n              57, math.max(57, MediaQuery.of(context).size.width - 400)),\n          child: widget.child,\n        ),\n        if (widget.resizable)\n          RawGestureDetector(\n            gestures: {\n              EagerHorizontalDragRecognizer:\n                  GestureRecognizerFactoryWithHandlers<\n                      EagerHorizontalDragRecognizer>(\n                () => EagerHorizontalDragRecognizer()\n                  ..onStart = (details) {\n                    setState(() {\n                      _width = widget.width;\n                    });\n                  }\n                  ..onEnd = (details) {\n                    widget.onResizeWidth(\n                      _width.clamp(\n                          57,\n                          math.max(\n                              57, MediaQuery.of(context).size.width - 400)),\n                    );\n                  }\n                  ..onUpdate = (details) {\n                    setState(() {\n                      _width += details.delta.dx;\n                    });\n                  },\n                (instance) {},\n              )\n            },\n            child: const SizedBox(\n              height: double.infinity,\n              width: 30,\n              child: Center(\n                child: Icon(Icons.drag_indicator),\n              ),\n            ),\n          )\n        else\n          Container(),\n      ]);\n    }\n  }\n}\n\nclass HomeScreen extends StatefulWidget {\n  final bool isDiscoModeEnabled;\n  final Channel channel;\n  final void Function(Channel) onChannelSelect;\n\n  const HomeScreen({\n    required this.isDiscoModeEnabled,\n    required this.channel,\n    required this.onChannelSelect,\n    super.key,\n  });\n\n  @override\n  State<HomeScreen> createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {\n  final _scaffoldKey = GlobalKey<ScaffoldState>();\n\n  @override\n  void initState() {\n    super.initState();\n    WakelockPlus.enable();\n    WidgetsBinding.instance.addPostFrameCallback((_) async {\n      debugPrint(\"Post frame callback executed\");\n      if (!mounted) return;\n      debugPrint(\"Post frame callback post executed\");\n      final model = Provider.of<AudioModel>(context, listen: false);\n      final ttsModel = Provider.of<TtsModel>(context, listen: false);\n\n      NotificationsPlugin.listenToTts(ttsModel);\n\n      if (model.sources.isEmpty || (await AudioChannel.hasPermission())) {\n        return;\n      }\n      if (mounted) {\n        debugPrint(\"Conditions passed\");\n        model.showAudioPermissionDialog(context);\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    WakelockPlus.disable();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final mediaQuery = MediaQuery.of(context);\n    final orientation = mediaQuery.orientation;\n    final width = mediaQuery.size.width;\n\n    return GestureDetector(\n      onTap: () => FocusManager.instance.primaryFocus?.unfocus(),\n      child: Consumer<UserModel>(\n        builder: (context, userModel, child) {\n          return Scaffold(\n            key: _scaffoldKey,\n            drawer: Sidebar(channel: widget.channel),\n            endDrawer: userModel.isSignedIn()\n                ? EndDrawerWidget(channel: widget.channel)\n                : null,\n            drawerEdgeDragWidth: MediaQuery.of(context).size.width * 0.6,\n            onDrawerChanged: (isOpened) =>\n                FocusManager.instance.primaryFocus?.unfocus(),\n            onEndDrawerChanged: (isOpened) =>\n                FocusManager.instance.primaryFocus?.unfocus(),\n            appBar: HeaderBarWidget(\n              onChannelSelect: widget.onChannelSelect,\n              channel: widget.channel,\n              actions: [\n                Consumer2<ActivityFeedModel, LayoutModel>(\n                  builder: (context, activityFeedModel, layoutModel, child) {\n                    if (!activityFeedModel.isEnabled) {\n                      return Container();\n                    }\n                    return IconButton(\n                      icon: Icon(layoutModel.isShowNotifications\n                          ? Icons.notifications\n                          : Icons.notifications_outlined),\n                      tooltip: AppLocalizations.of(context)!.activityFeed,\n                      onPressed: () {\n                        layoutModel.isShowNotifications =\n                            !layoutModel.isShowNotifications;\n                      },\n                    );\n                  },\n                ),\n                if (width > 256)\n                  Consumer<LayoutModel>(\n                    builder: (context, layoutModel, child) {\n                      return IconButton(\n                        icon: Icon(layoutModel.isShowPreview\n                            ? Icons.preview\n                            : Icons.preview_outlined),\n                        tooltip: AppLocalizations.of(context)!.streamPreview,\n                        onPressed: () {\n                          layoutModel.isShowPreview =\n                              !layoutModel.isShowPreview;\n                        },\n                      );\n                    },\n                  ),\n                Consumer<TtsModel>(\n                  builder: (context, ttsModel, child) {\n                    return IconButton(\n                      icon: Icon(\n                        !kDebugMode\n                            ? (ttsModel.enabled\n                                ? Icons.record_voice_over\n                                : Icons.voice_over_off)\n                            : (ttsModel.newTtsEnabled\n                                ? Icons.record_voice_over\n                                : Icons.voice_over_off),\n                      ),\n                      tooltip: AppLocalizations.of(context)!.textToSpeech,\n                      onPressed: () async {\n                        if (!kDebugMode) {\n                          ttsModel.setEnabled(AppLocalizations.of(context)!,\n                              ttsModel.enabled ? false : true);\n                          // Toggle newTtsEnabled and notify listeners immediately\n                        } else {\n                          ttsModel.newTtsEnabled = !ttsModel.newTtsEnabled;\n\n                          if (!ttsModel.newTtsEnabled) {\n                            updateChannelSubscription(\"\");\n                            await TextToSpeechPlugin.speak(\n                                \"Text to speech disabled\");\n                            await TextToSpeechPlugin.disableTTS();\n                            NotificationsPlugin.cancelNotification();\n                          } else {\n                            // Start listening to the stream before toggling newTtsEnabled\n                            channelStreamController.stream\n                                .listen((currentChannel) {\n                              if (currentChannel.isEmpty) {\n                                ttsModel.newTtsEnabled = false;\n                              }\n                            });\n                            await TextToSpeechPlugin.speak(\n                                \"Text to speech enabled\");\n                            updateChannelSubscription(\n                              \"${userModel.activeChannel?.provider}:${userModel.activeChannel?.channelId}\",\n                            );\n                            NotificationsPlugin.showNotification();\n                            NotificationsPlugin.listenToTts(ttsModel);\n                          }\n                        }\n                      },\n                    );\n                  },\n                ),\n                if (userModel.isSignedIn() && width > 256)\n                  IconButton(\n                    icon: const Icon(Icons.people),\n                    tooltip: AppLocalizations.of(context)!.currentViewers,\n                    onPressed: () {\n                      _scaffoldKey.currentState?.openEndDrawer();\n                    },\n                  ),\n              ],\n            ),\n            body: Container(\n              height: mediaQuery.size.height,\n              color: Theme.of(context).scaffoldBackgroundColor,\n              child: SafeArea(\n                child: Builder(\n                  builder: (context) {\n                    final chatPanelFooter = Consumer<LayoutModel>(\n                      builder: (context, layoutModel, child) {\n                        return layoutModel.locked ? Container() : child!;\n                      },\n                      child: Builder(\n                        builder: (context) {\n                          if (!userModel.isSignedIn()) {\n                            return Column(\n                              children: [\n                                Row(\n                                  mainAxisAlignment: MainAxisAlignment.center,\n                                  children: [\n                                    const Flexible(child: Divider()),\n                                    Padding(\n                                      padding: const EdgeInsets.all(8),\n                                      child: Text(\n                                        AppLocalizations.of(context)!\n                                            .signInToSendMessages,\n                                        style: Theme.of(context)\n                                            .textTheme\n                                            .labelLarge,\n                                      ),\n                                    ),\n                                    const Flexible(child: Divider()),\n                                  ],\n                                ),\n                                const SignInWithTwitch(),\n                              ],\n                            );\n                          }\n\n                          return FutureBuilder<List<Emote>>(\n                            future: getEmotes(widget.channel),\n                            builder: (context, snapshot) {\n                              return MessageInputWidget(\n                                emotes: snapshot.data ?? [],\n                                channel: widget.channel,\n                              );\n                            },\n                          );\n                        },\n                      ),\n                    );\n                    if (orientation == Orientation.portrait) {\n                      return Consumer<LayoutModel>(\n                        builder: (context, layoutModel, child) {\n                          return Column(\n                            verticalDirection: VerticalDirection.up,\n                            children: [\n                              // reversed direction because of verticalDirection: VerticalDirection.up\n                              chatPanelFooter,\n                              Expanded(\n                                child: DiscoWidget(\n                                  isEnabled: widget.isDiscoModeEnabled,\n                                  child:\n                                      ChatPanelWidget(channel: widget.channel),\n                                ),\n                              ),\n                              Consumer<LayoutModel>(\n                                builder: (context, layoutModel, child) {\n                                  if (layoutModel.isShowNotifications) {\n                                    return ResizableWidget(\n                                      resizable: !layoutModel.locked,\n                                      height: layoutModel.panelHeight,\n                                      width: layoutModel.panelWidth,\n                                      onResizeHeight: (height) {\n                                        layoutModel.panelHeight = height;\n                                      },\n                                      onResizeWidth: (width) {\n                                        layoutModel.panelWidth = width;\n                                      },\n                                      child: const ActivityFeedPanelWidget(),\n                                    );\n                                  } else if (layoutModel.isShowPreview) {\n                                    return AspectRatio(\n                                      aspectRatio: 16 / 9,\n                                      child: StreamPreview(\n                                          channel: widget.channel),\n                                    );\n                                  } else {\n                                    return Container();\n                                  }\n                                },\n                              ),\n                            ],\n                          );\n                        },\n                      );\n                    } else {\n                      // landscape\n                      return Row(\n                        children: [\n                          Consumer<LayoutModel>(\n                            builder: (context, layoutModel, child) {\n                              if (!layoutModel.isShowNotifications &&\n                                  !layoutModel.isShowPreview) {\n                                return Container();\n                              }\n                              return ResizableWidget(\n                                resizable: !layoutModel.locked,\n                                height: layoutModel.panelHeight,\n                                width: layoutModel.panelWidth,\n                                onResizeHeight: (height) {\n                                  layoutModel.panelHeight = height;\n                                },\n                                onResizeWidth: (width) {\n                                  layoutModel.panelWidth = width;\n                                },\n                                child: Consumer<LayoutModel>(\n                                  builder: (context, layoutModel, child) {\n                                    if (layoutModel.isShowNotifications) {\n                                      return const ActivityFeedPanelWidget();\n                                    } else if (layoutModel.isShowPreview) {\n                                      return StreamPreview(\n                                          channel: widget.channel);\n                                    } else {\n                                      return Container();\n                                    }\n                                  },\n                                ),\n                              );\n                            },\n                          ),\n                          Expanded(\n                            child: Column(\n                              children: [\n                                Expanded(\n                                  child: DiscoWidget(\n                                    isEnabled: widget.isDiscoModeEnabled,\n                                    child: ChatPanelWidget(\n                                        channel: widget.channel),\n                                  ),\n                                ),\n                                chatPanelFooter,\n                              ],\n                            ),\n                          ),\n                        ],\n                      );\n                    }\n                  },\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/themes.dart",
    "content": "import 'package:flutter/material.dart';\n\nclass Themes {\n  static final lightTheme = ThemeData(\n    fontFamily: \"Oskari G2\",\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: const Color(0xFF009FDF),\n      tertiary: const Color(0xFF1D1D1F),\n      surface: Colors.white,\n      brightness: Brightness.light,\n    ),\n  );\n\n  static final darkTheme = ThemeData(\n    fontFamily: \"Oskari G2\",\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: const Color(0xFF009FDF),\n      tertiary: const Color(0xFF1D1D1F),\n      surface: Colors.black,\n      brightness: Brightness.dark,\n    ),\n  );\n}"
  },
  {
    "file": "/root/development/rtchat/lib/product_list.dart",
    "content": "// Store identifiers for in app purchases.\nconst cloudTtsSubscription = \"tts0001\";"
  },
  {
    "file": "/root/development/rtchat/lib/models/tts/language.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_localized_locales/flutter_localized_locales.dart';\n\nconst supportedLanguages = [\n  'af', //    Afrikaans\n  'ar', //    Arabic\n  'bn', //    Bengali\n  'bg', //    Bulgarian\n  'ca', //    Catalan\n  'zh', //    Chinese\n  'zh-hk', // Chinese (Hong Kong)\n  'cs', //    Czech\n  'da', //    Danish\n  'nl', //    Dutch\n  'en', //    English\n  'fi', //    Finnish\n  'fr', //    French\n  'de', //    German\n  'el', //    Greek\n  'gu', //    Gujarati\n  'hi', //    Hindi\n  'hu', //    Hungarian\n  'is', //    Icelandic\n  'id', //    Indonesian\n  'it', //    Italian\n  'ja', //    Japanese\n  'kn', //    Kannada\n  'ko', //    Korean\n  'lv', //    Latvian\n  'ms', //    Malay\n  'ml', //    Malayalam\n  'nb', //    Norwegian Bokml\n  'pl', //    Polish\n  'pt', //    Portuguese\n  'pa', //    Punjabi\n  'ro', //    Romanian\n  'ru', //    Russian\n  'sr', //    Serbian\n  'sk', //    Slovak\n  'es', //    Spanish\n  'sv', //    Swedish\n  'tl', //    Tagalog\n  'ta', //    Tamil\n  'te', //    Telugu\n  'th', //    Thai\n  'tr', //    Turkish\n  'uk', //    Ukrainian\n  'vi', //    Vietnamese\n];\n\nclass Language {\n  final String languageCode;\n\n  Language([this.languageCode = 'en']);\n\n  String displayName(BuildContext context) {\n    // LocaleNames requires country codes to be uppercase\n    if (languageCode.contains('-')) {\n      final index = languageCode.indexOf('-');\n      final countryCode = languageCode.substring(index).toUpperCase();\n      final code = languageCode\n          .replaceRange(index, null, countryCode)\n          .replaceAll('-', '_');\n      return LocaleNames.of(context)!.nameOf(code) ?? '';\n    }\n    return LocaleNames.of(context)!.nameOf(languageCode) ?? '';\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/tts/bytes_audio_source.dart",
    "content": "import 'package:just_audio/just_audio.dart';\n\nclass BytesAudioSource extends StreamAudioSource {\n  final List<int> bytes;\n  BytesAudioSource(this.bytes) : super();\n\n  @override\n  Future<StreamAudioResponse> request([int? start, int? end]) async {\n    start ??= 0;\n    end ??= bytes.length;\n    return StreamAudioResponse(\n      sourceLength: bytes.length,\n      contentLength: end - start,\n      offset: start,\n      stream: Stream.value(bytes.sublist(start, end)),\n      contentType: 'audio/mpeg',\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/product.dart",
    "content": "import 'package:in_app_purchase/in_app_purchase.dart';\n\nenum ProductStatus {\n  purchasable,\n  purchased,\n  pending,\n}\n\nclass Product {\n  String get id => productDetails.id;\n  String get title => productDetails.title;\n  String get description => productDetails.description;\n  String get price => productDetails.price;\n  ProductStatus status;\n  ProductDetails productDetails;\n\n  Product(this.productDetails) : status = ProductStatus.purchasable;\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/stream_preview.dart",
    "content": "import 'dart:core';\n\nimport 'package:flutter/material.dart';\n\nclass StreamPreviewModel extends ChangeNotifier {\n  var _isHighDefinition = false;\n  var _volume = 0;\n  var _showBatteryPrompt = true;\n\n  bool get isHighDefinition => _isHighDefinition;\n\n  set isHighDefinition(bool value) {\n    _isHighDefinition = value;\n    notifyListeners();\n  }\n\n  int get volume => _volume;\n\n  set volume(int value) {\n    _volume = value;\n    notifyListeners();\n  }\n\n  bool get showBatteryPrompt => _showBatteryPrompt;\n\n  set showBatteryPrompt(bool value) {\n    _showBatteryPrompt = value;\n    notifyListeners();\n  }\n\n  StreamPreviewModel.fromJson(Map<String, dynamic> json) {\n    if (json['isHighDefinition'] != null) {\n      _isHighDefinition = json['isHighDefinition'];\n    }\n    if (json['volume'] != null) {\n      _volume = json['volume'];\n    }\n    if (json['showBatteryPrompt'] != null) {\n      _showBatteryPrompt = json['showBatteryPrompt'];\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        'isHighDefinition': _isHighDefinition,\n        'volume': _volume,\n        'showBatteryPrompt': _showBatteryPrompt,\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/user.dart",
    "content": "import 'dart:async';\n\nimport 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:rtchat/models/adapters/profiles.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass UserModel extends ChangeNotifier {\n  bool _isLoading = true;\n\n  late final StreamSubscription<void> _userSubscription;\n  StreamSubscription<void>? _profileSubscription;\n\n  User? _user;\n  Channel? _userChannel;\n  Channel? _activeChannel;\n\n  UserModel() {\n    _userSubscription =\n        FirebaseAuth.instance.authStateChanges().listen((user) async {\n      _user = user;\n      _profileSubscription?.cancel();\n      await FirebaseCrashlytics.instance.setUserIdentifier(user?.uid ?? \"\");\n      await FirebaseAnalytics.instance.setUserId(id: user?.uid);\n      if (user == null) {\n        _userChannel = null;\n        _isLoading = false;\n        notifyListeners();\n        return;\n      }\n      _profileSubscription = ProfilesAdapter.instance\n          .getChannel(userId: user.uid, provider: \"twitch\")\n          .listen((channel) {\n        _userChannel = channel;\n        _isLoading = false;\n        notifyListeners();\n        if (channel != null) {\n          FirebaseAnalytics.instance\n              .setUserProperty(name: \"user_provider\", value: channel.provider);\n          FirebaseAnalytics.instance.setUserProperty(\n              name: \"user_channel_id\", value: channel.channelId);\n          FirebaseAnalytics.instance.setUserProperty(\n              name: \"user_display_name\", value: channel.displayName);\n        }\n      });\n    });\n  }\n\n  @override\n  void dispose() {\n    _profileSubscription?.cancel();\n    _userSubscription.cancel();\n    super.dispose();\n  }\n\n  bool isSignedIn() => _user != null;\n\n  User? get user => _user;\n\n  Channel? get userChannel => _userChannel;\n\n  Channel? get activeChannel => _activeChannel ?? _userChannel;\n\n  set activeChannel(Channel? channel) {\n    _activeChannel = channel;\n    notifyListeners();\n  }\n\n  Uri? get activityFeedUri {\n    final channel = _userChannel;\n    if (channel == null) {\n      return null;\n    }\n    switch (channel.provider) {\n      case \"twitch\":\n        return Uri.tryParse(\n            \"https://dashboard.twitch.tv/popout/u/${channel.displayName}/stream-manager/activity-feed\");\n    }\n    return null;\n  }\n\n  bool get isLoading => _isLoading;\n\n  Future<void> signOut() => FirebaseAuth.instance.signOut();\n\n  Future<UserCredential> signIn(String token) =>\n      FirebaseAuth.instance.signInWithCustomToken(token);\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/donations.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:cloud_functions/cloud_functions.dart';\n\nclass StreamlabsConfig {\n  final String? currency;\n\n  StreamlabsConfig({this.currency});\n}\n\nclass StreamElementsConfig {\n  StreamElementsConfig();\n}\n\nclass DonationsAdapter {\n  final FirebaseFirestore db;\n  final FirebaseFunctions functions;\n\n  DonationsAdapter._({required this.db, required this.functions});\n\n  static DonationsAdapter get instance => _instance ??= DonationsAdapter._(\n      db: FirebaseFirestore.instance, functions: FirebaseFunctions.instance);\n  static DonationsAdapter? _instance;\n\n  Stream<String?> forRealtimeChatAddress({required String userId}) {\n    return db\n        .collection(\"realtimecash\")\n        .doc(userId)\n        .snapshots()\n        .map((doc) => doc.exists ? doc.get(\"address\") : null);\n  }\n\n  Future<void> setRealtimeCashAddress({required String address}) {\n    return functions\n        .httpsCallable(\"setRealTimeCashAddress\")({\"address\": address});\n  }\n\n  Stream<StreamlabsConfig?> forStreamlabsConfig({required String userId}) {\n    return db.collection(\"streamlabs\").doc(userId).snapshots().map((doc) {\n      final data = doc.data();\n      if (data == null || data[\"token\"] == null) {\n        return null;\n      }\n      return StreamlabsConfig(currency: data[\"currency\"]);\n    });\n  }\n\n  Stream<StreamElementsConfig?> forStreamElementsConfig(\n      {required String userId}) {\n    return db.collection(\"streamelements\").doc(userId).snapshots().map((doc) {\n      final data = doc.data();\n      if (data == null || data[\"token\"] == null) {\n        return null;\n      }\n      return StreamElementsConfig();\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/chat_state.dart",
    "content": "import 'package:cloud_functions/cloud_functions.dart';\n\nclass Viewers {\n  final List<String> broadcaster;\n  final List<String> moderators;\n  final List<String> vips;\n  final List<String> viewers;\n\n  Viewers({\n    required this.broadcaster,\n    required this.moderators,\n    required this.vips,\n    required this.viewers,\n  });\n\n  // create a new instance that filters to viewers matching a certain substring.\n  Viewers query(String text) {\n    if (text.isEmpty) {\n      return this;\n    }\n    return Viewers(\n      broadcaster: broadcaster\n          .where((name) => name.toLowerCase().contains(text.toLowerCase()))\n          .take(10)\n          .toList(),\n      moderators: moderators\n          .where((name) => name.toLowerCase().contains(text.toLowerCase()))\n          .take(10)\n          .toList(),\n      vips: vips\n          .where((name) => name.toLowerCase().contains(text.toLowerCase()))\n          .take(10)\n          .toList(),\n      viewers: viewers\n          .where((name) => name.toLowerCase().contains(text.toLowerCase()))\n          .take(10)\n          .toList(),\n    );\n  }\n\n  // flatten the viewers to a list\n  List<String> flatten() {\n    return broadcaster + moderators + vips + viewers;\n  }\n}\n\nclass BadgeVersion {\n  final String id;\n  final String imageUrl1x;\n  final String imageUrl2x;\n  final String imageUrl4x;\n  final String description;\n  final String title;\n  final String? clickAction;\n  final String? clickUrl;\n\n  BadgeVersion({\n    required this.id,\n    required this.imageUrl1x,\n    required this.imageUrl2x,\n    required this.imageUrl4x,\n    required this.description,\n    required this.title,\n    required this.clickAction,\n    required this.clickUrl,\n  });\n}\n\nclass TwitchBadgeInfo {\n  final String setId;\n  final List<BadgeVersion> versions;\n\n  TwitchBadgeInfo({\n    required this.setId,\n    required this.versions,\n  });\n}\n\nclass ChatStateAdapter {\n  final FirebaseFunctions functions;\n\n  ChatStateAdapter._({required this.functions});\n\n  static ChatStateAdapter get instance =>\n      _instance ??= ChatStateAdapter._(functions: FirebaseFunctions.instance);\n  static ChatStateAdapter? _instance;\n\n  Future<Viewers> getViewers({required String channelId}) {\n    return functions\n        .httpsCallable(\"getViewerList\")\n        .call(channelId)\n        .then((result) {\n      return Viewers(\n        broadcaster: [...(result.data['broadcaster'] ?? [])],\n        moderators: [...(result.data['moderators'] ?? [])],\n        vips: [...(result.data['vips'] ?? [])],\n        viewers: [...(result.data['viewers'] ?? [])],\n      );\n    });\n  }\n\n  Future<List<TwitchBadgeInfo>> getTwitchBadges({String? channelId}) async {\n    for (int attempt = 0; attempt < 3; attempt++) {\n      try {\n        final result = await functions\n            .httpsCallable(\"getBadges\")\n            .call({\"provider\": \"twitch\", \"channelId\": channelId});\n        if (result.data == null) {\n          return [];\n        }\n        return result.data\n            .map<TwitchBadgeInfo>((badgeInfo) => TwitchBadgeInfo(\n                  setId: badgeInfo[\"set_id\"],\n                  versions: badgeInfo[\"versions\"]\n                      .map<BadgeVersion>((version) => BadgeVersion(\n                            id: version[\"id\"],\n                            imageUrl1x: version[\"image_url_1x\"],\n                            imageUrl2x: version[\"image_url_2x\"],\n                            imageUrl4x: version[\"image_url_4x\"],\n                            description: version[\"description\"],\n                            title: version[\"title\"],\n                            clickAction: version[\"click_action\"],\n                            clickUrl: version[\"click_url\"],\n                          ))\n                      .toList(),\n                ))\n            .toList();\n      } catch (e) {\n        if (e is FirebaseFunctionsException &&\n            e.code == 'unavailable' &&\n            attempt < 2) {\n          await Future.delayed(const Duration(seconds: 1));\n        } else {\n          rethrow;\n        }\n      }\n    }\n    return [];\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/messages.dart",
    "content": "import 'dart:async';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/messages/auxiliary/realtimecash.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamelements.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamlabs.dart';\nimport 'package:rtchat/models/messages/twitch/prediction_event.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/channel_point_redemption_event.dart';\nimport 'package:rtchat/models/messages/twitch/emote.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/messages/twitch/hype_train_event.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/raiding_event.dart';\nimport 'package:rtchat/models/messages/twitch/reply.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_create_event.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_receive_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_gift_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_message_event.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\n\nabstract class DeltaEvent {\n  final DateTime timestamp;\n\n  const DeltaEvent(this.timestamp);\n}\n\nclass AppendDeltaEvent extends DeltaEvent {\n  final MessageModel model;\n\n  AppendDeltaEvent(this.model) : super(model.timestamp);\n}\n\nclass UpdateDeltaEvent extends DeltaEvent {\n  final String messageId;\n  final MessageModel Function(MessageModel) update;\n\n  const UpdateDeltaEvent(this.messageId, DateTime timestamp, this.update)\n      : super(timestamp);\n}\n\nclass UpdateAllDeltaEvent extends DeltaEvent {\n  final MessageModel Function(MessageModel) update;\n\n  const UpdateAllDeltaEvent(super.timestamp, this.update);\n}\n\nclass ClearDeltaEvent extends DeltaEvent {\n  final String messageId;\n\n  const ClearDeltaEvent({\n    required this.messageId,\n    required DateTime timestamp,\n  }) : super(timestamp);\n}\n\n// this is a sentinel event to indicate that the messages that follow are\n// live messages.\nclass LiveStateDeltaEvent extends DeltaEvent {\n  const LiveStateDeltaEvent(super.timestamp);\n}\n\nDeltaEvent? _toDeltaEvent(\n    List<Emote> emotes, DocumentSnapshot<Map<String, dynamic>> doc) {\n  final data = doc.data();\n  if (data == null) {\n    return null;\n  }\n\n  switch (data['type']) {\n    case \"message\":\n      final message = data['message'];\n      final tags = data['tags'];\n\n      final author = TwitchUserModel(\n          userId: tags['user-id'],\n          displayName: tags['display-name'],\n          login: tags['username']);\n\n      final reply = data['reply'] != null\n          ? TwitchMessageReplyModel(\n              messageId: data['reply']['messageId'],\n              message: data['reply']['message'],\n              author: TwitchUserModel(\n                userId: data['reply']['userId'],\n                displayName: data['reply']['displayName'],\n                login: data['reply']['userLogin'],\n              ),\n            )\n          : null;\n\n      final model = TwitchMessageModel(\n          messageId: doc.id,\n          author: author,\n          message: message,\n          reply: reply,\n          tags: tags,\n          annotations:\n              TwitchMessageAnnotationsModel.fromMap(data['annotations']),\n          thirdPartyEmotes: emotes,\n          timestamp: data['timestamp'].toDate(),\n          deleted: false,\n          channelId: data['channelId']);\n\n      return AppendDeltaEvent(model);\n    case \"messagedeleted\":\n      return UpdateDeltaEvent(data['messageId'], data['timestamp'].toDate(),\n          (message) {\n        if (message is! TwitchMessageModel) {\n          return message;\n        }\n        return message.withDeleted(true);\n      });\n    case \"channel.raid\":\n      final model = TwitchRaidEventModel(\n          messageId: doc.id,\n          from: TwitchUserModel(\n              userId: data['event']['from_broadcaster_user_id'],\n              login: data['event']['from_broadcaster_user_login'],\n              displayName: data['event']['from_broadcaster_user_name']),\n          viewers: data['event']['viewers'],\n          timestamp: data['timestamp'].toDate());\n      return AppendDeltaEvent(model);\n    case \"clear\":\n      return ClearDeltaEvent(\n        messageId: doc.id,\n        timestamp: data['timestamp'].toDate(),\n      );\n    case \"userclear\":\n      return UpdateAllDeltaEvent(data['timestamp'].toDate(), (message) {\n        if (message is! TwitchMessageModel ||\n            message.author.userId != data['targetUserId']) {\n          return message;\n        }\n        return message.withDeleted(true);\n      });\n    case \"host\":\n      if (data['hosterChannelId'] == null) {\n        // Since we might have some events saved without this field.\n        return null;\n      }\n      final hosterInfo = data['hosterChannelId'].split(':');\n      final model = TwitchHostEventModel(\n          messageId: doc.id,\n          from: TwitchUserModel(\n              userId: hosterInfo[1],\n              login: data['displayName'],\n              displayName: data['displayName']),\n          viewers: data['viewers'],\n          timestamp: data['timestamp'].toDate());\n      return AppendDeltaEvent(model);\n    case \"channel.subscribe\":\n      final model = TwitchSubscriptionEventModel(\n          timestamp: data['timestamp'].toDate(),\n          messageId: doc.id,\n          subscriberUserName: data['event']['user_name'],\n          isGift: data['event']['is_gift'],\n          tier: data['event']['tier']);\n\n      return AppendDeltaEvent(model);\n    case \"channel.subscription.gift\":\n      final gifterName = data['event']['is_anonymous']\n          ? \"Anonymous Gifter\"\n          : data['event']['user_name'];\n\n      final model = TwitchSubscriptionGiftEventModel(\n          timestamp: data['timestamp'].toDate(),\n          messageId: doc.id,\n          gifterUserName: gifterName,\n          tier: data['event']['tier'],\n          total: data['event']['total'],\n          cumulativeTotal: data['event']['cumulative_total'] ?? 0);\n\n      return AppendDeltaEvent(model);\n    case \"channel.subscription.message\":\n      final model = TwitchSubscriptionMessageEventModel(\n          timestamp: data['timestamp'].toDate(),\n          messageId: doc.id,\n          subscriberUserName: data['event']['user_name'],\n          tier: data['event']['tier'],\n          streakMonths: data['event']['streak_months'],\n          cumulativeMonths: data['event']['cumulative_months'],\n          durationMonths: data['event']['duration_months'],\n          emotes: SubscriptionMessageEventEmote.fromDynamicList(\n              data['event']['message']['emotes']),\n          text: data['event']['message']['text']);\n\n      return AppendDeltaEvent(model);\n    case \"channel.follow\":\n      return AppendDeltaEvent(\n          TwitchFollowEventModel.fromDocumentData(doc.id, data));\n    case \"channel.cheer\":\n      final model = TwitchCheerEventModel(\n          bits: data['event']['bits'],\n          isAnonymous: data['event']['is_anonymous'],\n          cheerMessage: data['event']['message'],\n          giverName: data['event']['user_name'],\n          messageId: doc.id,\n          timestamp: data['timestamp'].toDate());\n      return AppendDeltaEvent(model);\n    case \"channel.poll.begin\":\n      final model = TwitchPollEventModel.fromDocumentData(data);\n      return AppendDeltaEvent(model);\n    case \"channel.poll.progress\":\n      return UpdateDeltaEvent(\n          \"poll${data['event']['id']}\", data['timestamp'].toDate(), (message) {\n        if (message is! TwitchPollEventModel) {\n          return message;\n        }\n        return message.withProgress(data);\n      });\n    case \"channel.poll.end\":\n      return UpdateDeltaEvent(\n          \"poll${data['event']['id']}\", data['timestamp'].toDate(), (message) {\n        if (message is! TwitchPollEventModel) {\n          return message;\n        }\n        return message.withEnd(data);\n      });\n    case \"channel.channel_points_custom_reward_redemption.add\":\n      final model =\n          TwitchChannelPointRedemptionEventModel.fromDocumentData(data);\n      return AppendDeltaEvent(model);\n    case \"channel.channel_points_custom_reward_redemption.update\":\n      return UpdateDeltaEvent(\"channel.point-redemption-${data['event']['id']}\",\n          data['timestamp'].toDate(), (message) {\n        if (message is! TwitchChannelPointRedemptionEventModel) {\n          return message;\n        }\n        return TwitchChannelPointRedemptionEventModel.fromDocumentData(data);\n      });\n    case \"channel.hype_train.begin\":\n      final model = TwitchHypeTrainEventModel.fromDocumentData(data);\n      return AppendDeltaEvent(model);\n    case \"channel.hype_train.progress\":\n      return UpdateDeltaEvent(\"channel.hype_train-${data['event']['id']}\",\n          data['timestamp'].toDate(), (message) {\n        if (message is! TwitchHypeTrainEventModel) {\n          return message;\n        }\n\n        return message.withProgress(data);\n      });\n    case \"channel.hype_train.end\":\n      return UpdateDeltaEvent(\"channel.hype_train-${data['event']['id']}\",\n          data['timestamp'].toDate(), (message) {\n        if (message is! TwitchHypeTrainEventModel) {\n          return message;\n        }\n        return message.withEnd(data);\n      });\n    case \"channel.prediction.begin\":\n      final model = TwitchPredictionEventModel.fromDocumentData(data);\n      return AppendDeltaEvent(model);\n    case \"channel.prediction.progress\":\n      return UpdateDeltaEvent(\"channel.prediction-${data['event']['id']}\",\n          data['timestamp'].toDate(), (message) {\n        if (message is! TwitchPredictionEventModel) {\n          return message;\n        }\n        return TwitchPredictionEventModel.fromDocumentData(data);\n      });\n    case \"channel.prediction.end\":\n      return UpdateDeltaEvent(\"channel.prediction-${data['event']['id']}\",\n          data['timestamp'].toDate(), (message) {\n        if (message is! TwitchPredictionEventModel) {\n          return message;\n        }\n        return TwitchPredictionEventModel.fromEndEvent(data);\n      });\n    case \"stream.online\":\n    case \"stream.offline\":\n      final model = StreamStateEventModel(\n          messageId: doc.id,\n          isOnline: data['type'] == \"stream.online\",\n          timestamp: data['timestamp'].toDate());\n      return AppendDeltaEvent(model);\n    case \"raid_update_v2\":\n      return AppendDeltaEvent(TwitchRaidingEventModel.fromDocumentData(data));\n    case \"raid_cancel_v2\":\n      return UpdateDeltaEvent(\n          \"raiding.${data['raid']['id']}\", data['timestamp'].toDate(),\n          (message) {\n        if (message is! TwitchRaidingEventModel) {\n          return message;\n        }\n        return message.withCancel();\n      });\n    case \"raid_go_v2\":\n      return UpdateDeltaEvent(\n          \"raiding.${data['raid']['id']}\", data['timestamp'].toDate(),\n          (message) {\n        if (message is! TwitchRaidingEventModel) {\n          return message;\n        }\n        return message.withSuccessful();\n      });\n    case \"streamlabs.donation\":\n      final model = StreamlabsDonationEventModel.fromDocumentData(doc.id, data);\n      return AppendDeltaEvent(model);\n    case \"streamelements.tip\":\n      final model = StreamElementsTipEventModel.fromDocumentData(doc.id, data);\n      return AppendDeltaEvent(model);\n    case \"realtimecash.donation\":\n      final model =\n          SimpleRealtimeCashDonationEventModel.fromDocumentData(doc.id, data);\n      return AppendDeltaEvent(model);\n    case \"channel.shoutout.create\":\n      final model =\n          TwitchShoutoutCreateEventModel.fromDocumentData(doc.id, data);\n      return AppendDeltaEvent(model);\n    case \"channel.shoutout.receive\":\n      final model =\n          TwitchShoutoutReceiveEventModel.fromDocumentData(doc.id, data);\n      return AppendDeltaEvent(model);\n  }\n  return null;\n}\n\nclass MessagesAdapter {\n  final FirebaseFirestore db;\n  final FirebaseFunctions functions;\n\n  MessagesAdapter._({required this.db, required this.functions});\n\n  static MessagesAdapter get instance => _instance ??= MessagesAdapter._(\n      db: FirebaseFirestore.instance, functions: FirebaseFunctions.instance);\n  static MessagesAdapter? _instance;\n\n  Future<void> subscribe(Channel channel) async {\n    final subscribe = functions.httpsCallable('subscribe');\n    for (var i = 0; i < 3; i++) {\n      try {\n        await subscribe({\n          \"provider\": channel.provider,\n          \"channelId\": channel.channelId,\n        });\n        return;\n      } catch (e, st) {\n        if (i == 2) {\n          FirebaseCrashlytics.instance.recordError(e, st, fatal: false);\n        } else {\n          await Future.delayed(const Duration(seconds: 1));\n        }\n      }\n    }\n  }\n\n  Future<List<DeltaEvent>> forChannelHistory(\n      Channel channel, DateTime from) async {\n    final emotes = await getEmotes(channel);\n\n    final results = await db\n        .collection(\"channels\")\n        .doc(channel.toString())\n        .collection(\"messages\")\n        .where(\"timestamp\", isLessThan: from)\n        .orderBy(\"timestamp\")\n        .limitToLast(250)\n        .get();\n\n    return results.docs\n        .map((doc) => _toDeltaEvent(emotes, doc))\n        .whereType<DeltaEvent>()\n        .toList();\n  }\n\n  Stream<DeltaEvent> forChannel(Channel channel) {\n    subscribe(channel);\n    final emotes = getEmotes(channel);\n    var isInitialSnapshot = true;\n    return db\n        .collection(\"channels\")\n        .doc(channel.toString())\n        .collection(\"messages\")\n        .orderBy(\"timestamp\")\n        .limitToLast(250)\n        .snapshots()\n        .asyncExpand((snapshot) async* {\n      final changes = snapshot.docChanges\n          .where((change) => change.type == DocumentChangeType.added);\n      for (final change in changes) {\n        try {\n          final event = _toDeltaEvent(await emotes, change.doc);\n          if (event != null) {\n            yield event;\n          }\n        } catch (e, st) {\n          // send this report immediately.\n          FirebaseCrashlytics.instance.recordError(e, st, fatal: true);\n        }\n      }\n      if (isInitialSnapshot &&\n          changes.isNotEmpty &&\n          !snapshot.metadata.isFromCache) {\n        isInitialSnapshot = false;\n        yield LiveStateDeltaEvent(DateTime.now());\n      }\n    });\n  }\n\n  /// Returns a stream of the \"stream online\" time.\n  /// null indicates that the stream is offline.\n  Stream<DateTime?> forChannelUptime(Channel channel, {DateTime? timestamp}) {\n    var query = db\n        .collection(\"channels\")\n        .doc(channel.toString())\n        .collection(\"messages\")\n        .where(\"type\", whereIn: [\"stream.online\", \"stream.offline\"]);\n    if (timestamp != null) {\n      query = query.where(\"timestamp\", isLessThan: timestamp);\n    }\n    return query.orderBy(\"timestamp\").limitToLast(1).snapshots().map((event) {\n      if (event.docs.isEmpty) {\n        return null;\n      }\n      final doc = event.docs.first;\n      final data = doc.data();\n      if (data['type'] == \"stream.offline\") {\n        return null;\n      }\n      return data['timestamp'].toDate();\n    });\n  }\n\n  Future<bool> hasMessages(Channel channel) async {\n    return await db\n        .collection(\"channels\")\n        .doc(channel.toString())\n        .collection(\"messages\")\n        .where(\"channelId\", isEqualTo: channel.toString())\n        .limit(1)\n        .get()\n        .then((snapshot) => snapshot.docs.isNotEmpty);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/profiles.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass ProfilesAdapter {\n  final FirebaseFirestore db;\n\n  ProfilesAdapter._({required this.db});\n\n  static ProfilesAdapter get instance =>\n      _instance ??= ProfilesAdapter._(db: FirebaseFirestore.instance);\n  static ProfilesAdapter? _instance;\n\n  Stream<Channel?> getChannel(\n      {required String userId, required String provider}) {\n    return db.collection(\"profiles\").doc(userId).snapshots().map((event) {\n      if (!event.exists) {\n        return null;\n      }\n      final data = event.data();\n      if (data == null || !data.containsKey(\"twitch\")) {\n        return null;\n      }\n      final twitch = data['twitch'];\n      if (twitch == null) {\n        return null;\n      }\n      return Channel(provider, twitch['id'], twitch['displayName']);\n    });\n  }\n\n  Stream<bool> getIsOnline({required String channelId}) {\n    return db\n        .collection(\"channels\")\n        .doc(channelId)\n        .collection(\"messages\")\n        .where(\"type\", whereIn: [\"stream.online\", \"stream.offline\"])\n        .orderBy(\"timestamp\")\n        .limitToLast(1)\n        .snapshots()\n        .map((event) =>\n            event.docs.isNotEmpty &&\n            event.docs.single.get(\"type\") == \"stream.online\");\n  }\n\n  Stream<bool> getIsAdsEnabled({required String userId}) {\n    return db.collection(\"profiles\").doc(userId).snapshots().map((doc) {\n      return doc.exists && (doc.get(\"claims\")['ads'] ?? false);\n    });\n  }\n\n  Future<String> getCompanionAuthToken({required String sessionUuid}) async {\n    final doc = await db\n        .collection(\"companion-tokens\")\n        .doc(sessionUuid)\n        .snapshots()\n        .firstWhere((event) => event.exists);\n    return doc.data()![\"token\"] as String;\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/actions.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass ActionsAdapter {\n  final FirebaseFirestore firestore;\n  final FirebaseFunctions functions;\n\n  ActionsAdapter._({required this.firestore, required this.functions});\n\n  static ActionsAdapter get instance => _instance ??= ActionsAdapter._(\n      firestore: FirebaseFirestore.instance,\n      functions: FirebaseFunctions.instance);\n  static ActionsAdapter? _instance;\n\n  Future<String?> send(Channel channel, String message) async {\n    final call = functions.httpsCallable('send');\n    final key = firestore.collection('actions').doc().id;\n    for (var i = 0; i < 3; i++) {\n      try {\n        final result = await call({\n          \"id\": key,\n          \"provider\": channel.provider,\n          \"channelId\": channel.channelId,\n          \"message\": message,\n        });\n        return result.data;\n      } catch (e) {\n        FirebaseCrashlytics.instance.recordError(e, StackTrace.current);\n      }\n    }\n    throw Exception(\"Failed to send message\");\n  }\n\n  Future<void> ban(Channel channel, String username) async {\n    final call = functions.httpsCallable('ban');\n    await call({\n      \"provider\": channel.provider,\n      \"channelId\": channel.channelId,\n      \"username\": username,\n    });\n  }\n\n  Future<void> unban(Channel channel, String username) async {\n    final call = functions.httpsCallable('unban');\n    await call({\n      \"provider\": channel.provider,\n      \"channelId\": channel.channelId,\n      \"username\": username,\n    });\n  }\n\n  Future<void> timeout(Channel channel, String username, String reason,\n      Duration duration) async {\n    final call = functions.httpsCallable('timeout');\n    await call({\n      \"provider\": channel.provider,\n      \"channelId\": channel.channelId,\n      \"username\": username,\n      \"reason\": reason,\n      \"length\": duration.inSeconds,\n    });\n  }\n\n  Future<void> delete(Channel channel, String messageId) async {\n    final call = functions.httpsCallable('deleteMessage');\n    await call({\n      \"provider\": channel.provider,\n      \"channelId\": channel.channelId,\n      \"messageId\": messageId,\n    });\n  }\n\n  Future<void> raid(Channel fromChannel, Channel toChannel) async {\n    if (fromChannel.provider != toChannel.provider) {\n      throw ArgumentError(\n          \"Cannot raid between channels of different providers\");\n    }\n    final call = functions.httpsCallable('raid');\n    await call({\n      \"provider\": fromChannel.provider,\n      \"fromChannelId\": fromChannel.channelId,\n      \"toChannelId\": toChannel.channelId,\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/metadata.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\n\nclass MetadataAdapter {\n  final FirebaseFirestore db;\n\n  MetadataAdapter._({required this.db});\n\n  static MetadataAdapter get instance =>\n      _instance ??= MetadataAdapter._(db: FirebaseFirestore.instance);\n  static MetadataAdapter? _instance;\n\n  Stream<String?> getThirdPartyMetadataValue(\n      {required String channelId, required String name, required String key}) {\n    return db\n        .collection(\"channels\")\n        .doc(channelId)\n        .collection(\"third-party\")\n        .where(\"name\", isEqualTo: name)\n        .where(\"key\", isEqualTo: key)\n        .orderBy(\"createdAt\", descending: true)\n        .limit(1)\n        .snapshots()\n        .map((event) {\n      if (event.docs.isEmpty) {\n        return null;\n      }\n      return event.docs.first.get(\"value\");\n    });\n  }\n\n  Stream<List<String>> getAvailableThirdPartyProviders(\n      {required String channelId}) {\n    return db\n        .collection(\"channels\")\n        .doc(channelId)\n        .snapshots()\n        .map((doc) => (doc.get(\"thirdParty\") ?? {}).keys.toList());\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/adapters/channels.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass ChannelMetadata {\n  final DateTime? onlineAt;\n  ChannelMetadata({required this.onlineAt});\n}\n\nclass TwitchChannelMetadata extends ChannelMetadata {\n  final int viewerCount;\n  final int followerCount;\n  final String? language;\n\n  TwitchChannelMetadata(\n      {required this.viewerCount,\n      required this.followerCount,\n      this.language,\n      required super.onlineAt});\n}\n\nclass ChannelsAdapter {\n  final FirebaseFirestore db;\n\n  ChannelsAdapter._({required this.db});\n\n  static ChannelsAdapter get instance =>\n      _instance ??= ChannelsAdapter._(db: FirebaseFirestore.instance);\n  static ChannelsAdapter? _instance;\n\n  Stream<ChannelMetadata> forChannel(Channel channel) {\n    return db\n        .collection(\"channels\")\n        .doc(channel.toString())\n        .snapshots()\n        .map((event) {\n      final data = event.data();\n      if (data == null) {\n        return ChannelMetadata(onlineAt: null);\n      }\n      switch (channel.provider) {\n        case \"twitch\":\n          return TwitchChannelMetadata(\n              onlineAt: (data[\"onlineAt\"] as Timestamp?)?.toDate(),\n              viewerCount: data[\"viewerCount\"] ?? 0,\n              followerCount: data[\"followerCount\"] ?? 0,\n              language: data[\"language\"]);\n        default:\n          return ChannelMetadata(\n              onlineAt: (data[\"onlineAt\"] as Timestamp?)?.toDate());\n      }\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages.dart",
    "content": "import 'dart:async';\nimport 'dart:core';\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/main.dart';\nimport 'package:rtchat/models/adapters/messages.dart';\nimport 'package:rtchat/models/adapters/profiles.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\nimport 'package:rtchat/models/tts.dart';\n\nclass MessagesModel extends ChangeNotifier {\n  StreamSubscription<void>? _subscription;\n  List<DeltaEvent> _events = [];\n  List<MessageModel> _messages = [];\n  Set<int> _separators = {};\n  Function()? onMessagePing;\n  bool _isLive = false;\n  Channel? _channel;\n\n  // it's a bit odd to have this here, but tts only cares about the delta events\n  // so it's easier to wire this way.\n  TtsModel? _tts;\n\n  set channel(Channel? channel) {\n    // ignore if no update\n    if (channel == _channel) {\n      return;\n    }\n    _channel = channel;\n    _messages = [];\n    _separators = {};\n    _events = [];\n    _isLive = false;\n    if (_tts != null) {\n      final localizations = _getLocalizations();\n      if (localizations != null) {\n        _tts!.setEnabled(localizations, false);\n      } else {\n        debugPrint(\"Localizations not available\");\n      }\n    }\n    notifyListeners();\n\n    _subscription?.cancel();\n    if (channel != null) {\n      _subscription =\n          MessagesAdapter.instance.forChannel(channel).listen((event) {\n        _events.add(event);\n        if (event is AppendDeltaEvent) {\n          // check if this event comes after the last message\n          if (_messages.isNotEmpty &&\n              event.model.timestamp.isBefore(_messages.last.timestamp)) {\n            // this message is out of order, so we need to insert it in the right place\n            final index = _messages.indexWhere(\n                (element) => element.timestamp.isAfter(event.model.timestamp));\n            _messages.insert(index, event.model);\n          } else {\n            _messages.add(event.model);\n            // Pass localizations to the TTS say method\n            final localizations = _getLocalizations();\n            if (localizations != null) {\n              _tts?.say(localizations, event.model);\n            } else {\n              debugPrint(\"Localizations not available\");\n            }\n            if (_isLive && shouldPing()) {\n              ProfilesAdapter.instance\n                  .getIsOnline(channelId: channel.toString())\n                  .first\n                  .then((value) {\n                if (value) {\n                  onMessagePing?.call();\n                }\n              });\n            }\n          }\n          // check to see if we should add a separator\n          // always add if it's the first message.\n          if (_messages.length == 1) {\n            _separators.add(0);\n          } else {\n            final lastSeparator =\n                _separators.isEmpty ? 0 : _separators.reduce(max);\n            // add if the last separator was at least 50 away and this was a\n            // chat message.\n            if (_messages.length - lastSeparator >= 50 &&\n                event.model is TwitchMessageModel) {\n              _separators.add(_messages.length - 1);\n            }\n            // add if the difference between this message and the last message\n            // is more than 5 minutes.\n            final cmp = _messages[_messages.length - 2];\n            if (event.model.timestamp.difference(cmp.timestamp).inMinutes > 5) {\n              _separators.add(_messages.length - 1);\n            }\n          }\n        } else if (event is UpdateDeltaEvent) {\n          for (var i = 0; i < _messages.length; i++) {\n            final message = _messages[i];\n            if (message.messageId == event.messageId) {\n              _messages[i] = event.update(message);\n              if (message is TwitchMessageModel && message.deleted) {\n                _tts?.unsay(message.messageId);\n              }\n              break;\n            }\n          }\n        } else if (event is UpdateAllDeltaEvent) {\n          for (var i = 0; i < _messages.length; i++) {\n            final message = event.update(_messages[i]);\n            if (message is TwitchMessageModel && message.deleted) {\n              _tts?.unsay(message.messageId);\n            }\n            _messages[i] = message;\n          }\n        } else if (event is ClearDeltaEvent) {\n          _messages = [\n            ChatClearedEventModel(\n              messageId: event.messageId,\n              timestamp: event.timestamp,\n            )\n          ];\n          _separators = {};\n          _tts?.stop();\n        } else if (event is LiveStateDeltaEvent) {\n          _isLive = true;\n        }\n        notifyListeners();\n      });\n    }\n  }\n\n  List<MessageModel> get messages => _messages;\n\n  Set<int> get separators => _separators;\n\n  bool get isLive => _isLive;\n\n  Set<TwitchUserModel> get authors {\n    return _messages\n        .whereType<TwitchMessageModel>()\n        .map((model) => model.author)\n        .toSet();\n  }\n\n  Future<void> pullMoreMessages() async {\n    final channel = _channel;\n    if (channel == null) {\n      return;\n    }\n    final futureEvents = _events; // this prevents a race.\n    final events = await MessagesAdapter.instance\n        .forChannelHistory(channel, _events.first.timestamp);\n    if (events.isEmpty) {\n      return;\n    }\n    List<MessageModel> messages = []; // rebuild a new message set.\n    _events = [...events, ...futureEvents];\n    for (final event in _events) {\n      // reproduce the message set\n      if (event is AppendDeltaEvent) {\n        // check if this event comes after the last message\n        if (messages.isNotEmpty &&\n            event.model.timestamp.isBefore(messages.last.timestamp)) {\n          // this message is out of order, so we need to insert it in the right place\n          final index = messages.indexWhere(\n              (element) => element.timestamp.isAfter(event.model.timestamp));\n          messages.insert(index, event.model);\n        } else {\n          messages.add(event.model);\n        }\n      } else if (event is UpdateDeltaEvent) {\n        for (var i = 0; i < messages.length; i++) {\n          final message = messages[i];\n          if (message.messageId == event.messageId) {\n            messages[i] = event.update(message);\n            break;\n          }\n        }\n      } else if (event is UpdateAllDeltaEvent) {\n        for (var i = 0; i < messages.length; i++) {\n          messages[i] = event.update(messages[i]);\n        }\n      } else if (event is ClearDeltaEvent) {\n        messages = [\n          ChatClearedEventModel(\n            messageId: event.messageId,\n            timestamp: event.timestamp,\n          )\n        ];\n      }\n    }\n    _messages = messages;\n    notifyListeners();\n  }\n\n  void pruneMessages() {\n    // this doesn't need to notify because it has no impact on the UI\n    if (_messages.length > 1000) {\n      _messages.removeRange(0, _messages.length - 1000);\n      _events.removeWhere(\n          (element) => element.timestamp.isBefore(_messages.first.timestamp));\n    }\n  }\n\n  set tts(TtsModel? tts) {\n    // ignore if no update\n    if (tts == _tts) {\n      return;\n    }\n    _tts = tts;\n    if (_tts != null) {\n      final localizations = _getLocalizations();\n      if (localizations != null) {\n        _tts!.setEnabled(localizations, false);\n      } else {\n        debugPrint(\"Localizations not available\");\n      }\n    }\n    notifyListeners();\n  }\n\n  TtsModel? get tts => _tts;\n\n  Duration _announcementPinDuration = const Duration(seconds: 10);\n\n  set announcementPinDuration(Duration duration) {\n    _announcementPinDuration = duration;\n    notifyListeners();\n  }\n\n  Duration get announcementPinDuration => _announcementPinDuration;\n\n  Duration _pingMinGapDuration = const Duration(days: 10000);\n\n  set pingMinGapDuration(Duration duration) {\n    _pingMinGapDuration = duration;\n    notifyListeners();\n  }\n\n  Duration get pingMinGapDuration => _pingMinGapDuration;\n\n  bool shouldPing() {\n    if (messages.isEmpty) {\n      return false;\n    }\n    if (messages.length == 1) {\n      return messages.last.timestamp\n          .isAfter(DateTime.now().subtract(const Duration(seconds: 1)));\n    }\n    final lastMessage = messages.last;\n    final secondLastMessage = messages[messages.length - 2];\n    final delta = lastMessage.timestamp.difference(secondLastMessage.timestamp);\n    return delta.compareTo(_pingMinGapDuration) > 0;\n  }\n\n  MessagesModel.fromJson(Map<String, dynamic> json) {\n    if (json['announcementPinDuration'] != null) {\n      _announcementPinDuration =\n          Duration(seconds: json['announcementPinDuration'].toInt());\n    }\n    if (json['pingMinGapDuration'] != null) {\n      _pingMinGapDuration =\n          Duration(seconds: json['pingMinGapDuration'].toInt());\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"announcementPinDuration\": _announcementPinDuration.inSeconds.toInt(),\n        \"pingMinGapDuration\": _pingMinGapDuration.inSeconds.toInt(),\n      };\n\n  BuildContext? _getContext() {\n    return navigatorKey.currentContext;\n  }\n\n  AppLocalizations? _getLocalizations() {\n    final context = _getContext();\n    if (context != null) {\n      return AppLocalizations.of(context);\n    }\n    return null;\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/tts.dart",
    "content": "import 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:io';\n\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:just_audio/just_audio.dart';\nimport 'package:rtchat/models/adapters/channels.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/tokens.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\nimport 'package:rtchat/models/tts/language.dart';\nimport 'package:rtchat/models/tts/bytes_audio_source.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:flutter_tts/flutter_tts.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass TtsModel extends ChangeNotifier {\n  var _isCloudTtsEnabled = false;\n  final _tts = FlutterTts()\n    ..setSharedInstance(true)\n    ..setIosAudioCategory(\n        IosTextToSpeechAudioCategory.playback,\n        [IosTextToSpeechAudioCategoryOptions.mixWithOthers],\n        IosTextToSpeechAudioMode.voicePrompt);\n\n  final audioPlayer = AudioPlayer();\n  Future<void> _previousUtterance = Future.value();\n  final Set<String> _pending = {};\n  var _language = Language();\n  List<String> voices = [];\n  final Map<String, dynamic> _voice = {};\n  var _isSupportedLanguage = false;\n  var _isRandomVoiceEnabled = true;\n  var _isBotMuted = false;\n  var _isEmoteMuted = false;\n  var _isPreludeMuted = false;\n  var _speed = Platform.isAndroid ? 0.8 : 0.395;\n  var _pitch = 1.0;\n  var _isEnabled = false;\n  var _isNewTTsEnabled = false;\n  final Set<TwitchUserModel> _mutedUsers = {};\n  // this is used to ignore messages in the past.\n  var _lastMessageTime = DateTime.now();\n  MessageModel? _activeMessage;\n\n  @override\n  void dispose() {\n    audioPlayer.dispose();\n    super.dispose();\n  }\n\n  void update(UserModel model) async {\n    if (kDebugMode) {\n      final channel = model.activeChannel;\n      if (channel == null) {\n        _isSupportedLanguage = false;\n        _language = Language();\n        return;\n      }\n\n      String? streamLanguage =\n          await ChannelsAdapter.instance.forChannel(channel).map((event) {\n        if (event is TwitchChannelMetadata) {\n          return event.language;\n        }\n        throw \"invalid provider\";\n      }).first;\n      if (streamLanguage == null) {\n        _isSupportedLanguage = false;\n        _language = Language();\n        return;\n      }\n\n      _isSupportedLanguage =\n          !(streamLanguage == 'other' || streamLanguage == 'asl');\n      language = _isSupportedLanguage ? Language(streamLanguage) : Language();\n      notifyListeners();\n    }\n  }\n\n  void getVoices() async {\n    if (!isCloudTtsEnabled) {\n      return;\n    }\n    final voicesJson = await FirebaseFunctions.instance\n        .httpsCallable(\"getVoices\")\n        .call(<String, dynamic>{\n      \"language\": _language.languageCode,\n    });\n    final data = voicesJson.data;\n\n    final List<String> voicesList = [];\n    for (LinkedHashMap voice in data) {\n      voicesList.add(voice['name']);\n    }\n    voices = voicesList;\n    if (_voice[language.languageCode] == null) {\n      voice = voicesList[0];\n    }\n    notifyListeners();\n  }\n\n  String getVocalization(AppLocalizations l10n, MessageModel model,\n      {bool includeAuthorPrelude = false}) {\n    if (model is TwitchMessageModel) {\n      final text = model.tokenized\n          .where((token) =>\n              token is TextToken ||\n              (!_isEmoteMuted && token is EmoteToken) ||\n              token is UserMentionToken ||\n              token is LinkToken)\n          .map((token) {\n        if (token is TextToken) {\n          return token.text;\n        } else if (token is EmoteToken) {\n          return token.code;\n        } else if (token is UserMentionToken) {\n          return token.username.replaceAll(\"_\", \" \");\n        } else if (token is LinkToken) {\n          return token.url.host;\n        }\n      }).join(\"\");\n      if (text.trim().isEmpty) {\n        return \"\";\n      }\n      final author = model.author.displayName ?? model.author.login;\n      if (!includeAuthorPrelude || isPreludeMuted) {\n        return text;\n      }\n      return model.isAction\n          ? l10n.actionMessage(author, text)\n          : l10n.saidMessage(author, text);\n    } else if (model is StreamStateEventModel) {\n      final timestamp = model.timestamp;\n      return model.isOnline\n          ? l10n.streamOnline(timestamp, timestamp)\n          : l10n.streamOffline(timestamp, timestamp);\n    } else if (model is SystemMessageModel) {\n      return model.text;\n    }\n    return \"\";\n  }\n\n  bool get newTtsEnabled {\n    return _isNewTTsEnabled;\n  }\n\n  set newTtsEnabled(bool value) {\n    if (value == _isNewTTsEnabled) {\n      return;\n    }\n    _isNewTTsEnabled = value;\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      notifyListeners();\n    });\n  }\n\n  bool get enabled {\n    return _isEnabled;\n  }\n\n  void setEnabled(AppLocalizations localizations, bool value) {\n    if (value == _isEnabled) {\n      return;\n    }\n    _isEnabled = value;\n    if (value) {\n      _lastMessageTime = DateTime.now();\n    }\n    say(\n        localizations,\n        SystemMessageModel(\n            text: value\n                ? localizations.textToSpeechEnabled\n                : localizations.textToSpeechDisabled),\n        force: true);\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      notifyListeners();\n    });\n  }\n\n  Language get language {\n    return _language;\n  }\n\n  set language(Language language) {\n    _language = language;\n    getVoices();\n    notifyListeners();\n  }\n\n  bool get isSupportedLanguage {\n    return _isSupportedLanguage;\n  }\n\n  set isSupportedLanguage(bool isSupportedLanguage) {\n    _isSupportedLanguage = isSupportedLanguage;\n    notifyListeners();\n  }\n\n  String get voice {\n    return _voice[_language.languageCode] ?? voices[0];\n  }\n\n  set voice(String voice) {\n    _voice[_language.languageCode] = voice;\n    notifyListeners();\n  }\n\n  bool get isRandomVoiceEnabled {\n    return _isRandomVoiceEnabled;\n  }\n\n  set isRandomVoiceEnabled(bool value) {\n    _isRandomVoiceEnabled = value;\n    notifyListeners();\n  }\n\n  bool get isBotMuted {\n    return _isBotMuted;\n  }\n\n  set isBotMuted(bool value) {\n    _isBotMuted = value;\n    notifyListeners();\n  }\n\n  bool get isEmoteMuted {\n    return _isEmoteMuted;\n  }\n\n  set isEmoteMuted(bool value) {\n    _isEmoteMuted = value;\n    notifyListeners();\n  }\n\n  bool get isPreludeMuted {\n    return _isPreludeMuted;\n  }\n\n  set isPreludeMuted(bool value) {\n    _isPreludeMuted = value;\n    notifyListeners();\n  }\n\n  bool get isCloudTtsEnabled {\n    return _isCloudTtsEnabled;\n  }\n\n  set isCloudTtsEnabled(bool value) {\n    _isCloudTtsEnabled = value;\n    if (value) {\n      getVoices();\n    }\n    notifyListeners();\n  }\n\n  double get speed {\n    return _speed;\n  }\n\n  set speed(double value) {\n    _speed = value;\n    notifyListeners();\n  }\n\n  double get pitch {\n    return _pitch;\n  }\n\n  set pitch(double value) {\n    _pitch = value;\n    notifyListeners();\n  }\n\n  bool isMuted(TwitchUserModel user) {\n    return _mutedUsers.contains(user);\n  }\n\n  void mute(TwitchUserModel model) {\n    _mutedUsers.add(model);\n    notifyListeners();\n  }\n\n  void unmute(TwitchUserModel model) {\n    if (_mutedUsers.remove(model)) {\n      notifyListeners();\n    }\n  }\n\n  void say(AppLocalizations localizations, MessageModel model,\n      {bool force = false}) async {\n    if (!enabled && !force) {\n      return;\n    }\n\n    if (model is TwitchMessageModel) {\n      if (_mutedUsers.any((user) =>\n          user.displayName?.toLowerCase() ==\n          model.author.displayName?.toLowerCase())) {\n        return;\n      }\n\n      if ((_isBotMuted && model.author.isBot) || model.isCommand) {\n        return;\n      }\n    }\n\n    // make sure the message is in the future.\n    if (model is SystemMessageModel) {\n      if (model.timestamp.isBefore(_lastMessageTime)) {\n        return;\n      }\n      _lastMessageTime = model.timestamp;\n    }\n\n    final activeMessage = _activeMessage;\n    var includeAuthorPrelude = true;\n    if (activeMessage is TwitchMessageModel && model is TwitchMessageModel) {\n      includeAuthorPrelude = !(activeMessage.author == model.author);\n    }\n\n    final vocalization = getVocalization(\n      localizations,\n      model,\n      includeAuthorPrelude: includeAuthorPrelude,\n    );\n\n    // if the vocalization is empty, skip the message\n    if (vocalization.isEmpty) {\n      return;\n    }\n\n    final previous = _previousUtterance;\n    final completer = Completer();\n\n    _previousUtterance = completer.future;\n    _pending.add(model.messageId);\n\n    await previous;\n\n    _activeMessage = model;\n\n    if ((_isEnabled || model is SystemMessageModel) &&\n        _pending.contains(model.messageId)) {\n      // TODO: replace with subscription logic\n      if (!_isCloudTtsEnabled) {\n        try {\n          await _tts.setSpeechRate(_speed);\n          await _tts.setPitch(_pitch);\n          await _tts.awaitSpeakCompletion(true);\n          await _tts.speak(vocalization);\n        } catch (e, st) {\n          FirebaseCrashlytics.instance.recordError(e, st);\n        }\n      } else {\n        String? voice;\n        double? pitch;\n        if (model is TwitchMessageModel) {\n          if (isRandomVoiceEnabled) {\n            final name = model.author.displayName;\n            final hash = name.hashCode;\n            voice = voices[hash % voices.length];\n            pitch = (hash % 21) / 5 - 2;\n          } else {\n            voice = _voice[_language.languageCode];\n            pitch = _pitch * 4 - 2;\n          }\n        }\n        final response =\n            await FirebaseFunctions.instance.httpsCallable(\"synthesize\")({\n          \"voice\": voice ?? \"en-US-WaveNet-F\",\n          \"text\": vocalization,\n          \"rate\": _speed * 1.5 + 0.5,\n          \"pitch\": pitch ?? 0,\n        });\n        final bytes = const Base64Decoder().convert(response.data);\n        await audioPlayer.setAudioSource(BytesAudioSource(bytes));\n        await audioPlayer.play();\n        await Future.delayed(audioPlayer.duration ?? const Duration());\n      }\n    }\n\n    _activeMessage = null;\n\n    completer.complete();\n    _pending.remove(model.messageId);\n  }\n\n  void unsay(String messageId) {\n    _pending.remove(messageId);\n  }\n\n  void stop() {\n    _pending.clear();\n  }\n\n  void updateFromJson(Map<String, dynamic> json) {\n    _updateFromJsonInternal(json);\n    notifyListeners();\n  }\n\n  void _updateFromJsonInternal(Map<String, dynamic> json) {\n    if (json['isBotMuted'] != null) {\n      _isBotMuted = json['isBotMuted'];\n    }\n    if (json['pitch'] != null) {\n      _pitch = json['pitch'];\n    }\n    if (json['speed'] != null) {\n      _speed = json['speed'];\n    }\n    if (json['isEmoteMuted'] != null) {\n      _isEmoteMuted = json['isEmoteMuted'];\n    }\n    if (json['isPreludeMuted'] != null) {\n      _isPreludeMuted = json['isPreludeMuted'];\n    }\n    if (json['isRandomVoiceEnabled'] != null) {\n      _isRandomVoiceEnabled = json['isRandomVoiceEnabled'];\n    }\n    if (json['language'] != null) {\n      _language = Language(json['language']);\n    }\n    if (json['voice'] != null) {\n      _voice.addAll(json['voice']);\n    }\n    final userJson = json['mutedUsers'];\n    if (userJson != null) {\n      for (var user in userJson) {\n        _mutedUsers.add(TwitchUserModel.fromJson(user));\n      }\n    }\n  }\n\n  TtsModel.fromJson(Map<String, dynamic> json) {\n    _updateFromJsonInternal(json);\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"isBotMuted\": isBotMuted,\n        \"isEmoteMuted\": isEmoteMuted,\n        \"isPreludeMuted\": isPreludeMuted,\n        \"isRandomVoiceEnabled\": isRandomVoiceEnabled,\n        \"language\": language.languageCode,\n        \"pitch\": pitch,\n        \"speed\": speed,\n        \"voice\": _voice,\n        'mutedUsers': _mutedUsers.map((e) => e.toJson()).toList(),\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/audio.dart",
    "content": "import 'dart:async';\nimport 'dart:core';\n\nimport 'package:audioplayers/audioplayers.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/audio_channel.dart';\nimport 'package:rtchat/models/adapters/profiles.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass AudioSource {\n  final String? name;\n  final Uri url;\n  final bool muted;\n\n  AudioSource(this.name, this.url, this.muted);\n\n  AudioSource withMuted(bool muted) => AudioSource(name, url, muted);\n\n  @override\n  bool operator ==(other) => other is AudioSource && other.url == url;\n\n  @override\n  int get hashCode => url.hashCode;\n\n  AudioSource.fromJson(Map<String, dynamic> json)\n      : name = json['name'],\n        url = Uri.parse(json['url']),\n        muted = json['muted'];\n\n  Map<String, dynamic> toJson() => {\n        \"name\": name,\n        \"url\": url.toString(),\n        \"muted\": muted,\n      };\n\n  @override\n  String toString() => url.toString();\n}\n\nclass AudioModel extends ChangeNotifier {\n  final List<AudioSource> _sources = [];\n  late final Timer _speakerDisconnectTimer;\n\n  bool _isOnline = false;\n  bool _isSettingsVisible = false;\n  bool _isAlwaysEnabled = false;\n\n  Channel? _hostChannel;\n  StreamSubscription? _hostChannelStateSubscription;\n\n  @override\n  void dispose() {\n    _hostChannelStateSubscription?.cancel();\n    _speakerDisconnectTimer.cancel();\n\n    super.dispose();\n  }\n\n  Channel? get hostChannel => _hostChannel;\n\n  set hostChannel(Channel? channel) {\n    _hostChannel = channel;\n    _hostChannelStateSubscription?.cancel();\n    if (_hostChannel == null) {\n      _hostChannelStateSubscription = null;\n      _isOnline = false;\n      _syncWebViews();\n      notifyListeners();\n      return;\n    }\n    _hostChannelStateSubscription = ProfilesAdapter.instance\n        .getIsOnline(channelId: _hostChannel.toString())\n        .listen((isOnline) {\n      _isOnline = isOnline;\n      _syncWebViews();\n      notifyListeners();\n    });\n  }\n\n  bool get isSettingsVisible => _isSettingsVisible;\n\n  set isSettingsVisible(bool value) {\n    _isSettingsVisible = value;\n    // this is just a signal from the view so don't trigger a notification.\n    _syncWebViews();\n  }\n\n  bool get isAlwaysEnabled => _isAlwaysEnabled;\n\n  set isAlwaysEnabled(bool value) {\n    _isAlwaysEnabled = value;\n    notifyListeners();\n  }\n\n  List<AudioSource> get sources => _sources;\n\n  bool get enabled => _isOnline || _isSettingsVisible || _isAlwaysEnabled;\n\n  Future<void> addSource(AudioSource source) async {\n    if (_sources.contains(source)) {\n      return;\n    }\n    _sources.add(source);\n    _syncWebViews();\n    notifyListeners();\n  }\n\n  Future<void> removeSource(AudioSource source) async {\n    _sources.remove(source);\n    _syncWebViews();\n    notifyListeners();\n  }\n\n  Future<void> toggleSource(AudioSource source) async {\n    final index = _sources.indexOf(source);\n    if (index != -1) {\n      _sources[index] = source.withMuted(!source.muted);\n      _syncWebViews();\n      notifyListeners();\n    }\n  }\n\n  Future<int> refreshAllSources() async {\n    final activeSources = _sources.where((element) => !element.muted).toList();\n    for (final source in activeSources) {\n      await AudioChannel.reload(source.url.toString());\n    }\n    return activeSources.length;\n  }\n\n  void _syncWebViews() {\n    if (enabled) {\n      AudioChannel.set(_sources\n          .where((element) => !element.muted)\n          .map((element) => element.url.toString())\n          .toList());\n    } else {\n      AudioChannel.set([]);\n    }\n  }\n\n  showAudioPermissionDialog(BuildContext context) {\n    return showDialog<void>(\n        context: context,\n        barrierDismissible: false, // user must tap button!\n        builder: (context) {\n          return AlertDialog(\n            title: Text(\n                AppLocalizations.of(context)!.audioSourcesRequirePermissions),\n            content: Text(AppLocalizations.of(context)!\n                .audioSourcesRequirePermissionsMessage),\n            actions: <Widget>[\n              TextButton(\n                child: Text(\n                    AppLocalizations.of(context)!.audioSourcesRemoveButton),\n                onPressed: () {\n                  _sources.clear();\n                  Navigator.of(context).pop();\n                },\n              ),\n              TextButton(\n                child: Text(AppLocalizations.of(context)!\n                    .audioSourcesOpenSettingsButton),\n                onPressed: () async {\n                  Navigator.of(context).pop();\n                  await AudioChannel.requestPermission();\n                },\n              ),\n            ],\n          );\n        });\n  }\n\n  AudioModel.fromJson(Map<String, dynamic> json) {\n    final player = AudioPlayer();\n    _speakerDisconnectTimer = Timer.periodic(\n      const Duration(minutes: 5),\n      (_) => player.play(AssetSource(\"silence.mp3\")),\n    );\n    final sources = json['sources'];\n    if (sources != null) {\n      for (dynamic source in sources) {\n        _sources.add(AudioSource.fromJson(source));\n      }\n      notifyListeners();\n    }\n    if (json['isAlwaysEnabled'] != null) {\n      _isAlwaysEnabled = json['isAlwaysEnabled'];\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"sources\": _sources.map((source) => source.toJson()).toList(),\n        \"isAlwaysEnabled\": _isAlwaysEnabled,\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/layout.dart",
    "content": "import 'dart:core';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nenum PreferredOrientation {\n  portrait,\n  landscape,\n  system,\n}\n\nextension _OrientationPreferenceJson on PreferredOrientation {\n  int toJson() {\n    switch (this) {\n      case PreferredOrientation.portrait:\n        return 0;\n      case PreferredOrientation.landscape:\n        return 1;\n      case PreferredOrientation.system:\n        return 2;\n    }\n  }\n\n  static PreferredOrientation fromJson(dynamic json) {\n    switch (json) {\n      case 0:\n        return PreferredOrientation.portrait;\n      case 1:\n        return PreferredOrientation.landscape;\n      case 2:\n        return PreferredOrientation.system;\n    }\n    return PreferredOrientation.system;\n  }\n}\n\nextension _ThemeModeJson on ThemeMode {\n  int toJson() {\n    switch (this) {\n      case ThemeMode.light:\n        return 0;\n      case ThemeMode.dark:\n        return 1;\n      case ThemeMode.system:\n        return 2;\n    }\n  }\n\n  static ThemeMode fromJson(dynamic json) {\n    switch (json) {\n      case 0:\n        return ThemeMode.light;\n      case 1:\n        return ThemeMode.dark;\n      case 2:\n        return ThemeMode.system;\n    }\n    return ThemeMode.system;\n  }\n}\n\nclass LayoutModel extends ChangeNotifier {\n  double _panelHeight = 300.0;\n  double _panelWidth = 300.0;\n  bool _isStatsVisible = true;\n  bool _locked = false;\n  double _onDragStartHeight = 300.0;\n  PreferredOrientation _orientationPreference = PreferredOrientation.system;\n  bool _isShowNotifications = false;\n  bool _isShowPreview = false;\n  ThemeMode _themeMode = ThemeMode.system;\n\n  void updatePanelHeight({required double dy}) {\n    _panelHeight += dy;\n    notifyListeners();\n  }\n\n  void updatePanelWidth({required double dx}) {\n    _panelWidth += dx;\n    notifyListeners();\n  }\n\n  set panelHeight(double panelHeight) {\n    _panelHeight = panelHeight;\n    notifyListeners();\n  }\n\n  double get panelHeight => _panelHeight;\n\n  double get panelWidth => _panelWidth;\n\n  set panelWidth(double panelWidth) {\n    _panelWidth = panelWidth;\n    notifyListeners();\n  }\n\n  double get onDragStartHeight => _onDragStartHeight;\n\n  set onDragStartHeight(double onDragStartHeight) {\n    _onDragStartHeight = onDragStartHeight;\n    notifyListeners();\n  }\n\n  bool get locked => _locked;\n\n  set locked(bool locked) {\n    _locked = locked;\n    notifyListeners();\n  }\n\n  bool get isStatsVisible => _isStatsVisible;\n\n  set isStatsVisible(bool value) {\n    _isStatsVisible = value;\n    notifyListeners();\n  }\n\n  PreferredOrientation get preferredOrientation => _orientationPreference;\n\n  set preferredOrientation(PreferredOrientation value) {\n    _orientationPreference = value;\n    _bindOrientationPreference();\n    notifyListeners();\n  }\n\n  ThemeMode get themeMode => _themeMode;\n\n  set themeMode(ThemeMode value) {\n    _themeMode = value;\n    notifyListeners();\n  }\n\n  bool get isShowNotifications => _isShowNotifications;\n\n  set isShowNotifications(bool value) {\n    _isShowPreview = false;\n    _isShowNotifications = value;\n    notifyListeners();\n  }\n\n  bool get isShowPreview => _isShowPreview;\n\n  set isShowPreview(bool value) {\n    _isShowNotifications = false;\n    _isShowPreview = value;\n    notifyListeners();\n  }\n\n  void _bindOrientationPreference() async {\n    switch (_orientationPreference) {\n      case PreferredOrientation.portrait:\n        await SystemChrome.setPreferredOrientations([\n          DeviceOrientation.portraitUp,\n          DeviceOrientation.portraitDown,\n        ]);\n        break;\n      case PreferredOrientation.landscape:\n        await SystemChrome.setPreferredOrientations([\n          DeviceOrientation.landscapeLeft,\n          DeviceOrientation.landscapeRight,\n        ]);\n        break;\n      case PreferredOrientation.system:\n        await SystemChrome.setPreferredOrientations([]);\n        break;\n    }\n  }\n\n  LayoutModel.fromJson(Map<String, dynamic> json) {\n    if (json['panelHeight'] != null) {\n      _panelHeight = json['panelHeight'];\n    }\n    if (json['panelWidth'] != null) {\n      _panelWidth = json['panelWidth'];\n    }\n    if (json['locked'] != null) {\n      _locked = json['locked'];\n    }\n    if (json['isStatsVisible'] != null) {\n      _isStatsVisible = json['isStatsVisible'];\n    }\n    if (json['orientationPreference'] != null) {\n      _orientationPreference =\n          _OrientationPreferenceJson.fromJson(json['orientationPreference']);\n      _bindOrientationPreference();\n    }\n    if (json['isShowNotifications'] != null) {\n      _isShowNotifications = json['isShowNotifications'];\n    }\n    if (json['isShowPreview'] != null) {\n      _isShowPreview = json['isShowPreview'];\n    }\n    if (json['themeMode'] != null) {\n      _themeMode = _ThemeModeJson.fromJson(json['themeMode']);\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"panelHeight\": _panelHeight,\n        \"panelWidth\": _panelWidth,\n        \"locked\": _locked,\n        \"isStatsVisible\": _isStatsVisible,\n        \"orientationPreference\": _orientationPreference.toJson(),\n        \"isShowNotifications\": _isShowNotifications,\n        \"isShowPreview\": _isShowPreview,\n        \"themeMode\": _themeMode.toJson(),\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/purchases.dart",
    "content": "import 'dart:async';\n\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:in_app_purchase/in_app_purchase.dart';\nimport 'package:rtchat/models/product.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/product_list.dart';\n\nclass IAPConnection {\n  static InAppPurchase? _instance;\n  static set instance(InAppPurchase value) {\n    _instance = value;\n  }\n\n  static InAppPurchase get instance {\n    _instance ??= InAppPurchase.instance;\n    return _instance!;\n  }\n}\n\nenum StoreState {\n  loading,\n  available,\n  notAvailable,\n}\n\nclass Purchases extends ChangeNotifier {\n  TtsModel ttsModel;\n  StoreState storeState = StoreState.loading;\n  late StreamSubscription<List<PurchaseDetails>> _subscription;\n  final iapConnection = IAPConnection.instance;\n  List<Product> products = [];\n\n  Purchases(this.ttsModel) {\n    final purchaseUpdated = iapConnection.purchaseStream;\n    _subscription = purchaseUpdated.listen(\n      _onPurchaseUpdate,\n      onDone: _updateStreamOnDone,\n      onError: _updateStreamOnError,\n    );\n    loadPurchases();\n  }\n\n  Future<void> loadPurchases() async {\n    final available = await iapConnection.isAvailable();\n    if (!available) {\n      if (storeState == StoreState.notAvailable) {\n        return;\n      }\n      storeState = StoreState.notAvailable;\n      notifyListeners();\n      return;\n    }\n    const ids = <String>{\n      cloudTtsSubscription,\n    };\n    final response = await iapConnection.queryProductDetails(ids);\n    for (var element in response.notFoundIDs) {\n      FirebaseCrashlytics.instance\n          .recordError('Purchase $element not found', StackTrace.current);\n    }\n    products = response.productDetails.map((e) => Product(e)).toList();\n    storeState = StoreState.available;\n    notifyListeners();\n  }\n\n  Product? getProduct(String productId) {\n    return products.firstWhere((product) => product.id == productId);\n  }\n\n  @override\n  void dispose() {\n    _subscription.cancel();\n    super.dispose();\n  }\n\n  Future<void> buy(Product product) async {\n    final purchaseParam = PurchaseParam(productDetails: product.productDetails);\n    switch (product.id) {\n      case cloudTtsSubscription:\n        await iapConnection.buyNonConsumable(purchaseParam: purchaseParam);\n        break;\n      default:\n        throw ArgumentError.value(\n            product.productDetails, '${product.id} is not a known product');\n    }\n  }\n\n  void _onPurchaseUpdate(List<PurchaseDetails> purchaseDetailsList) {\n    purchaseDetailsList.forEach(_handlePurchase);\n    notifyListeners();\n  }\n\n  void _handlePurchase(PurchaseDetails purchaseDetails) {\n    if (purchaseDetails.status == PurchaseStatus.purchased) {\n      switch (purchaseDetails.productID) {\n        case cloudTtsSubscription:\n          ttsModel.isCloudTtsEnabled = true;\n          break;\n      }\n    }\n\n    if (purchaseDetails.pendingCompletePurchase) {\n      iapConnection.completePurchase(purchaseDetails);\n    }\n  }\n\n  void _updateStreamOnDone() {\n    _subscription.cancel();\n  }\n\n  void _updateStreamOnError(Object e, StackTrace trace) {\n    FirebaseCrashlytics.instance.recordError(e, trace);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/qr_code.dart",
    "content": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/widgets.dart';\n\nfinal gradientMap = <String, Gradient>{\n  \"warmFlame\": FlutterLinearGradients.warmFlame(),\n  \"nightFade\": FlutterLinearGradients.nightFade(),\n  \"juicyPeach\": FlutterLinearGradients.juicyPeach(),\n  \"springWarmth\": FlutterLinearGradients.springWarmth(),\n  \"youngPassion\": FlutterLinearGradients.youngPassion(),\n  \"sunnyMorning\": FlutterLinearGradients.sunnyMorning(),\n  \"ladyLips\": FlutterLinearGradients.ladyLips(),\n  \"rainyAshville\": FlutterLinearGradients.rainyAshville(),\n  \"frozenDreams\": FlutterLinearGradients.frozenDreams(),\n  \"temptingAzure\": FlutterLinearGradients.temptingAzure(),\n  \"dustyGrass\": FlutterLinearGradients.dustyGrass(),\n  \"winterNeva\": FlutterLinearGradients.winterNeva(),\n};\n\nclass QRModel extends ChangeNotifier {\n  int _currentGradient = 0;\n\n  Gradient get currentGradient {\n    var keyName = gradientMap.keys.toList()[_currentGradient];\n    return gradientMap[keyName]!;\n  }\n\n  void changeGradient() {\n    _currentGradient = (_currentGradient + 1) % gradientMap.length;\n    notifyListeners();\n  }\n\n  QRModel.fromJson(Map<String, dynamic> json) {\n    if (json[\"currentGradient\"] != null) {\n      _currentGradient = json[\"currentGradient\"];\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"currentGradient\": _currentGradient,\n      };\n}\n\nclass FlutterLinearGradients {\n  static Gradient warmFlame({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        colors: const [Color(0xffff9a9e), Color(0xfffad0c4), Color(0xfffad0c4)],\n        stops: const [0.0, 0.99, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient nightFade({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(-pi / 2),\n        colors: const [Color(0xffa18cd1), Color(0xfffbc2eb)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient springWarmth({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(-pi / 2),\n        colors: const [Color(0xfffad0c4), Color(0xfffad0c4), Color(0xffffd1ff)],\n        stops: const [0.0, 0.01, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient juicyPeach({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(0.0),\n        colors: const [Color(0xffffecd2), Color(0xfffcb69f)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient youngPassion({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(0.0),\n        colors: const [\n          Color(0xffff8177),\n          Color(0xffff867a),\n          Color(0xffff8c7f),\n          Color(0xfff99185),\n          Color(0xffcf556c),\n          Color(0xffb12a5b)\n        ],\n        stops: const [0.0, 0.0, 0.21, 0.52, 0.78, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient ladyLips({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(pi / 2),\n        colors: const [Color(0xffff9a9e), Color(0xfffecfef), Color(0xfffecfef)],\n        stops: const [0.0, 0.99, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient sunnyMorning({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(pi / 6),\n        colors: const [Color(0xfff6d365), Color(0xfffda085)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient rainyAshville({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(-pi / 2),\n        colors: const [Color(0xfffbc2eb), Color(0xffa6c1ee)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient frozenDreams({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(-pi / 2),\n        colors: const [Color(0xfffdcbf1), Color(0xfffdcbf1), Color(0xffe6dee9)],\n        stops: const [0.0, 0.01, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient winterNeva({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(pi / 6),\n        colors: const [Color(0xffa1c4fd), Color(0xffc2e9fb)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient dustyGrass({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(pi / 6),\n        colors: const [Color(0xffd4fc79), Color(0xff96e6a1)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n\n  static Gradient temptingAzure({TileMode tileMode = TileMode.clamp}) =>\n      LinearGradient(\n        transform: gradientRotation(pi / 6),\n        colors: const [Color(0xff84fab0), Color(0xff8fd3f4)],\n        stops: const [0.0, 1.0],\n        tileMode: tileMode,\n      );\n}\n\nGradientRotation gradientRotation(double angle) {\n  return GradientRotation(angle * (pi / 180));\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/commands.dart",
    "content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nclass Command {\n  final String command;\n  final DateTime timeLastUsed;\n  static const daysToLive = Duration(days: 7);\n\n  Command(this.command, this.timeLastUsed);\n\n  bool get isDead => DateTime.now().difference(timeLastUsed) >= daysToLive;\n\n  @override\n  int get hashCode => command.hashCode;\n\n  @override\n  bool operator ==(other) => other is Command && other.command == command;\n\n  @override\n  String toString() => '$command:$timeLastUsed';\n\n  Command.fromJson(Map<String, dynamic> json)\n      : command = json['command'],\n        timeLastUsed = DateTime.parse(json['timeLastUsed']);\n\n  Map<String, dynamic> toJson() => {\n        'command': command,\n        'timeLastUsed': timeLastUsed.toString(),\n      };\n}\n\nclass CommandsModel extends ChangeNotifier {\n  List<Command> commandList = [];\n  static const maxNumberOfCommands = 15;\n\n  void clear() {\n    commandList.clear();\n    notifyListeners();\n  }\n\n  void addCommand(Command command) {\n    if (commandList.contains(command)) {\n      commandList.remove(command);\n    }\n    if (commandList.length >= maxNumberOfCommands) {\n      commandList.removeLast();\n    }\n    commandList.insert(0, command);\n    notifyListeners();\n  }\n\n  CommandsModel.fromJson(Map<String, dynamic> json) {\n    if (json['commandList'] != null) {\n      for (var item in json['commandList']) {\n        Command command = Command.fromJson(item);\n        if (!command.isDead) {\n          commandList.add(command);\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  Map<String, dynamic> toJson() => {'commandList': commandList};\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/message.dart",
    "content": "import 'dart:io';\n\nimport 'package:flutter/foundation.dart';\n\nclass AdHelper {\n  static String get chatHistoryAdId {\n    if (kDebugMode) {\n      if (Platform.isAndroid) {\n        return 'ca-app-pub-3940256099942544/6300978111';\n      } else if (Platform.isIOS) {\n        return 'ca-app-pub-3940256099942544/2934735716';\n      }\n      throw UnsupportedError(\"Unsupported platform\");\n    }\n    if (Platform.isAndroid) {\n      return 'ca-app-pub-2604378007164700/7379157643';\n    } else if (Platform.isIOS) {\n      return 'ca-app-pub-2604378007164700/6776274993';\n    } else {\n      throw UnsupportedError('Unsupported platform');\n    }\n  }\n}\n\nabstract class MessageModel {\n  final DateTime timestamp;\n  final String messageId;\n\n  const MessageModel({required this.timestamp, required this.messageId});\n}\n\nvar nativeMessageIdCounter = 0;\n\nclass StreamStateEventModel extends MessageModel {\n  final bool isOnline;\n\n  const StreamStateEventModel(\n      {required super.messageId,\n      required this.isOnline,\n      required super.timestamp});\n}\n\nclass SystemMessageModel extends MessageModel {\n  final String text;\n\n  SystemMessageModel({required this.text})\n      : super(\n            messageId: 'system-${nativeMessageIdCounter++}',\n            timestamp: DateTime.now());\n}\n\nclass ChatClearedEventModel extends MessageModel {\n  ChatClearedEventModel({required super.messageId, required super.timestamp});\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/auxiliary/streamlabs.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\nclass StreamlabsDonationEventModel extends MessageModel {\n  final String name;\n  final String formattedAmount;\n  final String? message;\n  final String currency;\n\n  const StreamlabsDonationEventModel(\n      {required this.name,\n      required this.formattedAmount,\n      required this.message,\n      required this.currency,\n      required super.messageId,\n      required super.timestamp});\n\n  static StreamlabsDonationEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return StreamlabsDonationEventModel(\n        name: data['name'],\n        formattedAmount: data['formattedAmount'],\n        message: data['message'],\n        currency: data['currency'],\n        messageId: messageId,\n        timestamp: data['timestamp'].toDate());\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/auxiliary/realtimecash.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/models/messages/message.dart';\n\nclass SimpleRealtimeCashDonationEventModel extends MessageModel {\n  final AssetImage image;\n  final String currency;\n  final double value;\n  final String hash;\n  final String? donor;\n  final String? message;\n\n  const SimpleRealtimeCashDonationEventModel(\n      {required this.currency,\n      required this.image,\n      required this.value,\n      required this.hash,\n      required this.donor,\n      required this.message,\n      required super.messageId,\n      required super.timestamp});\n\n  static SimpleRealtimeCashDonationEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return SimpleRealtimeCashDonationEventModel(\n        currency: data['activity']['asset'] ?? \"UNKNOWN\",\n        value: double.parse(data['activity']['value'].toString()),\n        hash: data['activity']['hash'],\n        donor: data['donor'],\n        message: data['message'],\n        messageId: messageId,\n        timestamp: data['timestamp'].toDate(),\n        image:\n            AssetImage(\"assets/${data['activity']['asset'] ?? \"UNKNOWN\"}.png\"));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/auxiliary/streamelements.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\nclass StreamElementsTipEventModel extends MessageModel {\n  final String name;\n  final String formattedAmount;\n  final String? message;\n  final String currency;\n\n  const StreamElementsTipEventModel(\n      {required this.name,\n      required this.formattedAmount,\n      required this.message,\n      required this.currency,\n      required super.messageId,\n      required super.timestamp});\n\n  static StreamElementsTipEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return StreamElementsTipEventModel(\n        name: data['name'],\n        formattedAmount: data['formattedAmount'],\n        message: data['message'],\n        currency: data['currency'],\n        messageId: messageId,\n        timestamp: data['timestamp'].toDate());\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/hype_train_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\nclass TwitchHypeTrainEventModel extends MessageModel {\n  final int level;\n  final int progress;\n  final int goal;\n  final int total;\n  final bool isSuccessful;\n  final bool hasEnded;\n  final DateTime startTimestamp;\n  final DateTime endTimestamp;\n\n  const TwitchHypeTrainEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.level,\n      required this.progress,\n      required this.goal,\n      required this.total,\n      required this.startTimestamp,\n      required this.endTimestamp,\n      this.isSuccessful = false,\n      this.hasEnded = false});\n\n  static TwitchHypeTrainEventModel fromDocumentData(Map<String, dynamic> data) {\n    return TwitchHypeTrainEventModel(\n        timestamp: data['timestamp'].toDate(),\n        messageId: \"channel.hype_train-${data['event']['id']}\",\n        level: data['event']['level'] ?? 1,\n        progress: data['event']['progress'],\n        goal: data['event']['goal'],\n        total: data['event']['total'],\n        startTimestamp: DateTime.parse(data['event']['started_at']),\n        endTimestamp: DateTime.parse(data['event']['expires_at']));\n  }\n\n  TwitchHypeTrainEventModel withProgress(Map<String, dynamic> data) {\n    final level = data['event']['level'];\n    final total = data['event']['total'];\n\n    if (this.level > level || this.total > total) {\n      return this;\n    }\n\n    return fromDocumentData(data);\n  }\n\n  TwitchHypeTrainEventModel withEnd(Map<String, dynamic> data) {\n    final level = data['event']['level'];\n    final total = data['event']['total'];\n\n    final wasSuccessful = level > 1;\n    final previousLevel = level == 1 ? 1 : level - 1;\n    final endLevel = progress >= goal ? level : previousLevel;\n\n    return TwitchHypeTrainEventModel(\n        timestamp: data['timestamp'].toDate(),\n        messageId: messageId,\n        level: endLevel,\n        progress: progress,\n        goal: goal,\n        total: total,\n        isSuccessful: wasSuccessful,\n        hasEnded: true,\n        startTimestamp: DateTime.parse(data['event']['started_at']),\n        endTimestamp: DateTime.parse(data['event']['ended_at']));\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      other is TwitchHypeTrainEventModel &&\n      other.level == level &&\n      other.progress == progress &&\n      other.goal == goal &&\n      other.total == total &&\n      other.isSuccessful == isSuccessful &&\n      other.hasEnded == hasEnded;\n\n  @override\n  int get hashCode => Object.hash(\n      level, progress, goal.hashCode, total, isSuccessful, hasEnded);\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/prediction_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/models/messages/message.dart';\n\nclass TwitchPredictionOutcomeModel {\n  final String id;\n  final int points;\n  final String color;\n  final String title;\n\n  TwitchPredictionOutcomeModel(this.id, this.points, this.color, this.title);\n\n  MaterialColor get widgetColor => color == \"pink\" ? Colors.pink : Colors.blue;\n}\n\nclass TwitchPredictionEventModel extends MessageModel {\n  final String title;\n  final String? status;\n  final String? winningOutcomeId;\n  final DateTime endTime;\n  final List<TwitchPredictionOutcomeModel> outcomes;\n\n  const TwitchPredictionEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.title,\n      this.status,\n      this.winningOutcomeId,\n      required this.endTime,\n      required this.outcomes});\n\n  static TwitchPredictionEventModel fromDocumentData(\n      Map<String, dynamic> data) {\n    return TwitchPredictionEventModel(\n        timestamp: data['timestamp'].toDate(),\n        messageId: \"channel.prediction-${data['event']['id']}\",\n        title: data['event']['title'],\n        status: \"in_progress\",\n        endTime: DateTime.parse(data['event']['locks_at']),\n        outcomes: data['event']['outcomes']\n            .map<TwitchPredictionOutcomeModel>((outcome) {\n          return TwitchPredictionOutcomeModel(\n              outcome['id'],\n              outcome['channel_points'] ?? 0,\n              outcome['color'],\n              outcome['title']);\n        }).toList());\n  }\n\n  static TwitchPredictionEventModel fromEndEvent(Map<String, dynamic> data) {\n    return TwitchPredictionEventModel(\n        timestamp: data['timestamp'].toDate(),\n        messageId: \"channel.prediction-${data['event']['id']}\",\n        title: data['event']['title'],\n        status: data['event']['status'],\n        winningOutcomeId: data['event']['winning_outcome_id'],\n        endTime: DateTime.parse(data['event']['ended_at']),\n        outcomes: data['event']['outcomes']\n            .map<TwitchPredictionOutcomeModel>((outcome) {\n          return TwitchPredictionOutcomeModel(outcome['id'],\n              outcome['channel_points'], outcome['color'], outcome['title']);\n        }).toList());\n  }\n\n  int get totalPoints {\n    return outcomes.fold(0, (sum, outcome) => sum + outcome.points);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/raiding_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\n\nclass RaidingEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  RaidingEventConfig(this.showEvent, this.eventDuration);\n\n  RaidingEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass TwitchRaidingEventModel extends MessageModel {\n  // we don't populate viewer count because it's not accurate anyways.\n  final Duration duration;\n  final TwitchUserModel targetUser;\n  final bool isComplete;\n  final bool isSuccessful;\n\n  const TwitchRaidingEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.duration,\n      required this.targetUser,\n      this.isComplete = false,\n      this.isSuccessful = false});\n\n  static TwitchRaidingEventModel fromDocumentData(Map<String, dynamic> data) {\n    return TwitchRaidingEventModel(\n      timestamp: data['timestamp'].toDate(),\n      messageId: \"raiding.${data['raid']['id']}\",\n      duration:\n          Duration(seconds: data['raid']['force_raid_now_seconds'].toInt()),\n      targetUser: TwitchUserModel(\n        userId: data['raid']['target_id'],\n        displayName: data['raid']['target_display_name'],\n        login: data['raid']['target_login'],\n      ),\n    );\n  }\n\n  TwitchRaidingEventModel withSuccessful() {\n    return TwitchRaidingEventModel(\n      timestamp: timestamp,\n      messageId: messageId,\n      duration: duration,\n      targetUser: targetUser,\n      isComplete: true,\n      isSuccessful: true,\n    );\n  }\n\n  TwitchRaidingEventModel withCancel() {\n    return TwitchRaidingEventModel(\n      timestamp: timestamp,\n      messageId: messageId,\n      duration: duration,\n      targetUser: targetUser,\n      isComplete: true,\n      isSuccessful: false,\n    );\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      other is TwitchRaidingEventModel &&\n      other.duration == duration &&\n      other.targetUser == targetUser &&\n      other.isComplete == isComplete &&\n      other.isSuccessful == isSuccessful;\n\n  @override\n  int get hashCode =>\n      Object.hash(duration, targetUser, isComplete, isSuccessful);\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/eventsub_configuration.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/models/messages/twitch/raiding_event.dart';\n\nclass FollowEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  FollowEventConfig(this.showEvent, this.eventDuration);\n\n  FollowEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass SubscriptionEventConfig {\n  bool showEvent;\n  bool showIndividualGifts;\n  Duration eventDuration;\n\n  SubscriptionEventConfig(\n      this.showEvent, this.showIndividualGifts, this.eventDuration);\n\n  SubscriptionEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        showIndividualGifts = json['showIndividualGifts'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"showIndividualGifts\": showIndividualGifts,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass CheerEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  CheerEventConfig(this.showEvent, this.eventDuration);\n\n  CheerEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass RaidEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n  bool enableShoutoutButton;\n\n  RaidEventConfig(\n      this.showEvent, this.eventDuration, this.enableShoutoutButton);\n\n  RaidEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt()),\n        enableShoutoutButton = json['enableShoutoutButton'] ?? false;\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n        \"enableShoutoutButton\": enableShoutoutButton,\n      };\n}\n\nclass HostEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  HostEventConfig(this.showEvent, this.eventDuration);\n\n  HostEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass ChannelPointRedemptionEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n  Duration unfulfilledAdditionalDuration;\n\n  ChannelPointRedemptionEventConfig(\n      this.showEvent, this.eventDuration, this.unfulfilledAdditionalDuration);\n\n  ChannelPointRedemptionEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt()),\n        unfulfilledAdditionalDuration =\n            Duration(seconds: json['unfulfilledAdditionalDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n        \"unfulfilledAdditionalDuration\":\n            unfulfilledAdditionalDuration.inSeconds.toInt(),\n      };\n}\n\nclass PollEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  PollEventConfig(this.showEvent, this.eventDuration);\n\n  PollEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass HypetrainEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  HypetrainEventConfig(this.showEvent, this.eventDuration);\n\n  HypetrainEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass PredictionEventConfig {\n  bool showEvent;\n  Duration eventDuration;\n\n  PredictionEventConfig(this.showEvent, this.eventDuration);\n\n  PredictionEventConfig.fromJson(Map<String, dynamic> json)\n      : showEvent = json['showEvent'],\n        eventDuration = Duration(seconds: json['eventDuration'].toInt());\n\n  Map<String, dynamic> toJson() => {\n        \"showEvent\": showEvent,\n        \"eventDuration\": eventDuration.inSeconds.toInt(),\n      };\n}\n\nclass EventSubConfigurationModel extends ChangeNotifier {\n  FollowEventConfig followEventConfig =\n      FollowEventConfig(true, const Duration(seconds: 2));\n  SubscriptionEventConfig subscriptionEventConfig =\n      SubscriptionEventConfig(true, false, const Duration(seconds: 6));\n  CheerEventConfig cheerEventConfig =\n      CheerEventConfig(true, const Duration(seconds: 6));\n  RaidEventConfig raidEventConfig =\n      RaidEventConfig(true, const Duration(seconds: 6), false);\n  HostEventConfig hostEventConfig =\n      HostEventConfig(true, const Duration(seconds: 6));\n  ChannelPointRedemptionEventConfig channelPointRedemptionEventConfig =\n      ChannelPointRedemptionEventConfig(\n          true, const Duration(seconds: 6), const Duration(seconds: 0));\n  PollEventConfig pollEventConfig =\n      PollEventConfig(true, const Duration(seconds: 6));\n  HypetrainEventConfig hypetrainEventConfig =\n      HypetrainEventConfig(true, const Duration(seconds: 6));\n  PredictionEventConfig predictionEventConfig =\n      PredictionEventConfig(true, const Duration(seconds: 6));\n  RaidingEventConfig\n      raidingEventConfig = // 90 seconds for raid + 10 for join prompt.\n      RaidingEventConfig(true, const Duration(seconds: 100));\n  // other configs\n  // final HypeTrainEventConfig;\n\n  setFollowEventDuration(Duration duration) {\n    followEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setFollowEventShowable(bool value) {\n    followEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setCheerEventDuration(Duration duration) {\n    cheerEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setCheerEventShowable(bool value) {\n    cheerEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setSubscriptionEventDuration(Duration duration) {\n    subscriptionEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setSubscriptionEventShowable(bool value) {\n    subscriptionEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setGiftSubscriptionStatus(bool value) {\n    subscriptionEventConfig.showIndividualGifts = value;\n    notifyListeners();\n  }\n\n  setRaidEventDuration(Duration duration) {\n    raidEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setRaidEventShowable(bool value) {\n    raidEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setRaidEventEnableShoutoutButton(bool value) {\n    raidEventConfig.enableShoutoutButton = value;\n    notifyListeners();\n  }\n\n  setChannelPointRedemptionEventDuration(Duration value) {\n    channelPointRedemptionEventConfig.eventDuration = value;\n    notifyListeners();\n  }\n\n  setChannelPointRedemptionEventShowable(bool value) {\n    channelPointRedemptionEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setChannelPointRedemptionEventUnfulfilledAdditionalDuration(Duration value) {\n    channelPointRedemptionEventConfig.unfulfilledAdditionalDuration = value;\n    notifyListeners();\n  }\n\n  setPollEventDuration(Duration duration) {\n    pollEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setPollEventShowable(bool value) {\n    pollEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setHostEventDuration(Duration duration) {\n    hostEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setHostEventShowable(bool value) {\n    hostEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setHypetrainEventDuration(Duration duration) {\n    hypetrainEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setHypetrainEventShowable(bool value) {\n    hypetrainEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setPredictionEventDuration(Duration duration) {\n    predictionEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setPredictionEventShowable(bool value) {\n    predictionEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  setRaidingEventDuration(Duration duration) {\n    raidingEventConfig.eventDuration = duration;\n    notifyListeners();\n  }\n\n  setRaidingEventShowable(bool value) {\n    raidingEventConfig.showEvent = value;\n    notifyListeners();\n  }\n\n  EventSubConfigurationModel.fromJson(Map<String, dynamic> json) {\n    if (json['followEventConfig'] != null) {\n      followEventConfig = FollowEventConfig.fromJson(json['followEventConfig']);\n    }\n    if (json['subscriptionEventConfig'] != null) {\n      subscriptionEventConfig =\n          SubscriptionEventConfig.fromJson(json['subscriptionEventConfig']);\n    }\n    if (json['cheerEventConfig'] != null) {\n      cheerEventConfig = CheerEventConfig.fromJson(json['cheerEventConfig']);\n    }\n    if (json['raidEventConfig'] != null) {\n      raidEventConfig = RaidEventConfig.fromJson(json['raidEventConfig']);\n    }\n    if (json['hostEventConfig'] != null) {\n      hostEventConfig = HostEventConfig.fromJson(json['hostEventConfig']);\n    }\n    if (json['channelPointRedemptionEventConfig'] != null) {\n      channelPointRedemptionEventConfig =\n          ChannelPointRedemptionEventConfig.fromJson(\n              json['channelPointRedemptionEventConfig']);\n    }\n    if (json['pollEventConfig'] != null) {\n      pollEventConfig = PollEventConfig.fromJson(json['pollEventConfig']);\n    }\n    if (json['hypetrainEventConfig'] != null) {\n      hypetrainEventConfig =\n          HypetrainEventConfig.fromJson(json['hypetrainEventConfig']);\n    }\n    if (json['predictionEventConfig'] != null) {\n      predictionEventConfig =\n          PredictionEventConfig.fromJson(json['predictionEventConfig']);\n    }\n    if (json['raidingEventConfig'] != null) {\n      raidingEventConfig =\n          RaidingEventConfig.fromJson(json['raidingEventConfig']);\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"followEventConfig\": followEventConfig.toJson(),\n        \"subscriptionEventConfig\": subscriptionEventConfig.toJson(),\n        \"cheerEventConfig\": cheerEventConfig.toJson(),\n        \"raidEventConfig\": raidEventConfig.toJson(),\n        \"pollEventConfig\": pollEventConfig.toJson(),\n        \"channelPointRedemptionEventConfig\":\n            channelPointRedemptionEventConfig.toJson(),\n        \"hostEventConfig\": hostEventConfig.toJson(),\n        \"hypetrainEventConfig\": hypetrainEventConfig.toJson(),\n        \"predictionEventConfig\": predictionEventConfig.toJson(),\n        \"raidingEventConfig\": raidingEventConfig.toJson(),\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/event.dart",
    "content": "import 'dart:math';\n\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\n\nclass TwitchRaidEventModel extends MessageModel {\n  final TwitchUserModel from;\n  final int viewers;\n\n  const TwitchRaidEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.from,\n      required this.viewers});\n}\n\nclass TwitchHostEventModel extends MessageModel {\n  final TwitchUserModel from;\n  final int viewers;\n\n  const TwitchHostEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.from,\n      required this.viewers});\n}\n\nclass TwitchFollowEventModel extends MessageModel {\n  final List<TwitchUserModel> followers;\n\n  const TwitchFollowEventModel({\n    required this.followers,\n    required super.messageId,\n    required super.timestamp,\n  });\n\n  static TwitchFollowEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return TwitchFollowEventModel(followers: [\n      TwitchUserModel(\n          userId: data['event']['user_id'],\n          login: data['event']['user_login'],\n          displayName: data['event']['user_name'])\n    ], messageId: messageId, timestamp: data['timestamp'].toDate());\n  }\n\n  static TwitchFollowEventModel merged(List<MessageModel> models) {\n    return TwitchFollowEventModel(\n        followers: models\n            .whereType<TwitchFollowEventModel>()\n            .expand((element) => element.followers)\n            .toList(),\n        messageId: models.first.messageId,\n        timestamp: models.last.timestamp);\n  }\n}\n\nclass TwitchCheerEventModel extends MessageModel {\n  final int bits;\n  final bool isAnonymous;\n  final String cheerMessage;\n  final String? giverName;\n\n  const TwitchCheerEventModel({\n    required this.bits,\n    required this.isAnonymous,\n    required this.cheerMessage,\n    required this.giverName,\n    required super.messageId,\n    required super.timestamp,\n  });\n}\n\nclass PollChoiceModel {\n  final String id;\n  final String title;\n  final int bitVotes;\n  final int channelPointVotes;\n  final int votes;\n  const PollChoiceModel({\n    required this.id,\n    required this.title,\n    required this.bitVotes,\n    required this.channelPointVotes,\n    required this.votes,\n  });\n}\n\nclass TwitchPollEventModel extends MessageModel {\n  final List<PollChoiceModel> choices;\n  final String pollTitle;\n  final bool isCompleted;\n  final DateTime startTimestamp;\n  final DateTime endTimestamp;\n  final String status;\n\n  TwitchPollEventModel({\n    required this.choices,\n    required this.pollTitle,\n    required this.isCompleted,\n    required this.startTimestamp,\n    required this.endTimestamp,\n    required this.status,\n    required super.messageId,\n    required super.timestamp,\n  });\n\n  static TwitchPollEventModel fromDocumentData(Map<String, dynamic>? data) {\n    final m = TwitchPollEventModel(\n        choices: parseChoices(data!),\n        pollTitle: data['event']['title'],\n        isCompleted: false,\n        messageId: \"poll${data['event']['id']}\",\n        timestamp: data['timestamp'].toDate(),\n        startTimestamp: DateTime.parse(data['event']['started_at']),\n        endTimestamp: DateTime.parse(data['event']['ends_at']),\n        status: 'ongoing');\n    return m;\n  }\n\n  TwitchPollEventModel withProgress(Map<String, dynamic>? data) {\n    return fromDocumentData(data);\n  }\n\n  TwitchPollEventModel withEnd(Map<String, dynamic>? data) {\n    final m = TwitchPollEventModel(\n        choices: parseChoices(data!),\n        pollTitle: data['event']['title'],\n        isCompleted: true,\n        messageId: \"poll${data['event']['id']}\",\n        timestamp: data['timestamp'].toDate(),\n        startTimestamp: DateTime.parse(data['event']['started_at']),\n        endTimestamp: DateTime.parse(data['event']['ended_at']),\n        status: data['event']['status']);\n    return m;\n  }\n\n  static List<PollChoiceModel> parseChoices(Map<String, dynamic>? data) {\n    List<PollChoiceModel> lst = [];\n    for (final entry in data!['event']['choices']) {\n      final String id = entry['id'];\n      final String title = entry['title'] ?? \"Untitled\";\n      final int votes = entry['votes'] ?? 0;\n      final int bitVotes = entry['bits_votes'] ?? 0;\n      final int channelPointVotes = entry['channel_points_votes'] ?? 0;\n\n      var poll = PollChoiceModel(\n          id: id,\n          title: title,\n          bitVotes: bitVotes,\n          channelPointVotes: channelPointVotes,\n          votes: votes);\n      lst.add(poll);\n    }\n    return lst;\n  }\n\n  int get totalVotes => choices.fold(0, (sum, choice) => sum + choice.votes);\n\n  int get totalChannelPointsVotes =>\n      choices.fold(0, (sum, choice) => sum + choice.channelPointVotes);\n\n  int get totalBitVotes =>\n      choices.fold(0, (sum, choice) => sum + choice.bitVotes);\n\n  int get maxVotes => choices.map((e) => e.votes).reduce((a, b) => max(a, b));\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/user.dart",
    "content": "import 'package:flutter/painting.dart';\nimport 'package:rtchat/models/channels.dart';\n\nconst colors = [\n  Color(0xFFFF0000),\n  Color(0xFF0000FF),\n  Color(0xFF00FF00),\n  Color(0xFFB22222),\n  Color(0xFFFF7F50),\n  Color(0xFF9ACD32),\n  Color(0xFFFF4500),\n  Color(0xFF2E8B57),\n  Color(0xFFDAA520),\n  Color(0xFFD2691E),\n  Color(0xFF5F9EA0),\n  Color(0xFF1E90FF),\n  Color(0xFFFF69B4),\n  Color(0xFF8A2BE2),\n  Color(0xFF00FF7F),\n];\n\nconst botList = {\n  'streamlab',\n  'streamlabs',\n  'nightbot',\n  'xanbot',\n  'ankhbot',\n  'moobot',\n  'wizebot',\n  'phantombot',\n  'streamelements',\n  'streamelement',\n  'sery_bot'\n};\n\nclass TwitchUserModel {\n  final String userId;\n  final String? displayName;\n  final String login;\n\n  const TwitchUserModel(\n      {required this.userId, this.displayName, required this.login});\n\n  @override\n  String toString() => login;\n\n  @override\n  int get hashCode => login.hashCode;\n\n  @override\n  bool operator ==(other) =>\n      other is TwitchUserModel &&\n      other.userId == userId &&\n      other.displayName == displayName &&\n      other.login == login;\n\n  bool get isBot => botList.contains(login.toLowerCase());\n\n  Color get color {\n    final n = login.codeUnits.first + login.codeUnits.last;\n    return colors[n % colors.length];\n  }\n\n  Uri get profilePictureUrl {\n    return Uri.parse(\n        \"https://rtirl.com/pfp.png?provider=twitch&channelId=$userId\");\n  }\n\n  Channel get asChannel => Channel(\"twitch\", userId, displayName ?? login);\n\n  TwitchUserModel.fromJson(Map<String, dynamic> json)\n      : userId = json[\"userId\"],\n        displayName = json[\"displayName\"],\n        login = json[\"login\"];\n\n  Map<String, dynamic> toJson() => {\n        \"userId\": userId,\n        \"displayName\": displayName,\n        \"login\": login,\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/emote.dart",
    "content": "import 'dart:convert';\nimport 'dart:core';\nimport 'dart:io';\n\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/channels.dart';\n\nFuture<List<Emote>> getEmotes(Channel channel) async {\n  final temp = await getTemporaryDirectory();\n  final cacheFile = File('${temp.path}/emotes/${channel.toString()}.json');\n  if (await cacheFile.exists()) {\n    final stats = await cacheFile.stat();\n    if (stats.modified\n        .isAfter(DateTime.now().subtract(const Duration(days: 1)))) {\n      final json = await cacheFile.readAsString();\n      return (jsonDecode(json) as List).map((e) => Emote.fromJson(e)).toList();\n    }\n  }\n\n  for (int i = 0; i < 3; i++) {\n    try {\n      final response =\n          await FirebaseFunctions.instance.httpsCallable(\"getEmotes\")({\n        \"provider\": channel.provider,\n        \"channelId\": channel.channelId,\n      });\n      final json = jsonEncode(response.data);\n      await cacheFile.create(recursive: true);\n      await cacheFile.writeAsString(json);\n\n      return (response.data as List)\n          .map((individualEmote) => Emote.fromJson(individualEmote))\n          .toList();\n    } catch (e) {\n      if (i == 2) {\n        FirebaseCrashlytics.instance.recordError(e, StackTrace.current);\n      } else {\n        await Future.delayed(const Duration(seconds: 1));\n      }\n    }\n  }\n  return [];\n}\n\nclass Emote {\n  final String provider;\n  final String? category;\n  final String id;\n  final String code;\n  final String imageUrl;\n\n  Emote({\n    required this.provider,\n    required this.category,\n    required this.id,\n    required this.code,\n    required this.imageUrl,\n  });\n\n  get uri =>\n      Uri.tryParse(imageUrl.startsWith(\"//\") ? \"https:$imageUrl\" : imageUrl);\n\n  ResilientNetworkImage get image => ResilientNetworkImage(uri);\n\n  static Emote fromJson(dynamic json) {\n    return Emote(\n      provider: json['provider'] as String,\n      category: json['category'] as String?,\n      id: json['id'].toString(),\n      code: json['code'] as String,\n      imageUrl: json['imageUrl'] as String,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/subscription_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\nclass TwitchSubscriptionEventModel extends MessageModel {\n  final String subscriberUserName;\n  final bool isGift;\n  final String tier;\n\n  const TwitchSubscriptionEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.subscriberUserName,\n      required this.isGift,\n      required this.tier});\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/reply.dart",
    "content": "import 'package:rtchat/models/messages/twitch/user.dart';\n\nclass TwitchMessageReplyModel {\n  final String messageId;\n  final String message;\n  final TwitchUserModel author;\n\n  TwitchMessageReplyModel(\n      {required this.messageId, required this.message, required this.author});\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/shoutout_receive_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\n/*\n    \"broadcaster_user_id\": \"626262\",\n    \"broadcaster_user_name\": \"SandySanderman\",\n    \"broadcaster_user_login\": \"sandysanderman\",\n    \"from_broadcaster_user_id\": \"12345\",\n    \"from_broadcaster_user_name\": \"SimplySimple\",\n    \"from_broadcaster_user_login\": \"simplysimple\",\n    \"viewer_count\": 860,\n    \"started_at\": \"2022-07-26T17:00:03.17106713Z\"\n*/\n\nclass TwitchShoutoutReceiveEventModel extends MessageModel {\n  final String fromBroadcasterUserId;\n  final String fromBroadcasterUserName;\n  final int viewerCount;\n\n  const TwitchShoutoutReceiveEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.fromBroadcasterUserId,\n      required this.fromBroadcasterUserName,\n      required this.viewerCount});\n\n  static TwitchShoutoutReceiveEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return TwitchShoutoutReceiveEventModel(\n      fromBroadcasterUserId: data['event']['from_broadcaster_user_id'],\n      fromBroadcasterUserName: data['event']['from_broadcaster_user_name'],\n      viewerCount: data['event']['viewer_count'],\n      timestamp: data['timestamp'].toDate(),\n      messageId: messageId,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/channel_point_redemption_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/models/messages/message.dart';\n\nenum TwitchChannelPointRedemptionStatus {\n  fulfilled,\n  canceled,\n  unfulfilled,\n  unknown\n}\n\nextension TwitchChannelPointRedemptionStatusParser\n    on TwitchChannelPointRedemptionStatus {\n  static TwitchChannelPointRedemptionStatus toEnum(String value) {\n    switch (value) {\n      case 'fulfilled':\n        return TwitchChannelPointRedemptionStatus.fulfilled;\n      case 'canceled':\n        return TwitchChannelPointRedemptionStatus.canceled;\n      case 'unfulfilled':\n        return TwitchChannelPointRedemptionStatus.unfulfilled;\n      default:\n        return TwitchChannelPointRedemptionStatus.unknown;\n    }\n  }\n}\n\nclass TwitchChannelPointRedemptionEventModel extends MessageModel {\n  final String redeemerUsername;\n  final TwitchChannelPointRedemptionStatus status;\n  final String rewardName;\n  final int rewardCost;\n  final String? userInput;\n\n  const TwitchChannelPointRedemptionEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.redeemerUsername,\n      required this.status,\n      required this.rewardName,\n      required this.rewardCost,\n      required this.userInput});\n\n  static TwitchChannelPointRedemptionEventModel fromDocumentData(\n      Map<String, dynamic> data) {\n    return TwitchChannelPointRedemptionEventModel(\n        timestamp: data['timestamp'].toDate(),\n        messageId: \"channel.point-redemption-${data['event']['id']}\",\n        redeemerUsername: data['event']['user_name'],\n        status: TwitchChannelPointRedemptionStatusParser.toEnum(\n            data['event']['status']),\n        rewardName: data['event']['reward']['title'],\n        rewardCost: data['event']['reward']['cost'],\n        userInput: data['event']['user_input']);\n  }\n\n  IconData get icon {\n    switch (status) {\n      case TwitchChannelPointRedemptionStatus.fulfilled:\n        return Icons.done;\n      case TwitchChannelPointRedemptionStatus.canceled:\n        return Icons.close;\n      case TwitchChannelPointRedemptionStatus.unfulfilled:\n        return Icons.timer;\n      case TwitchChannelPointRedemptionStatus.unknown:\n        return Icons.help;\n      default:\n        return Icons.done;\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/subscription_gift_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\nclass TwitchSubscriptionGiftEventModel extends MessageModel {\n  final String gifterUserName;\n  final String tier;\n  final int total;\n  final int cumulativeTotal;\n\n  const TwitchSubscriptionGiftEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.gifterUserName,\n      required this.tier,\n      required this.total,\n      required this.cumulativeTotal});\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/shoutout_create_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\n\n/*\n    \"broadcaster_user_id\": \"12345\",\n    \"broadcaster_user_name\": \"SimplySimple\",\n    \"broadcaster_user_login\": \"simplysimple\",\n    \"moderator_user_id\": \"98765\",\n    \"moderator_user_name\": \"ParticularlyParticular123\",\n    \"moderator_user_login\": \"particularlyparticular123\",\n    \"to_broadcaster_user_id\": \"626262\",\n    \"to_broadcaster_user_name\": \"SandySanderman\",\n    \"to_broadcaster_user_login\": \"sandysanderman\",\n    \"started_at\": \"2022-07-26T17:00:03.17106713Z\",\n    \"viewer_count\": 860,\n    \"cooldown_ends_at\": \"2022-07-26T17:02:03.17106713Z\",\n    \"target_cooldown_ends_at\":\"2022-07-26T18:00:03.17106713Z\"\n*/\n\nclass TwitchShoutoutCreateEventModel extends MessageModel {\n  final String fromBroadcasterUserId;\n  final String fromBroadcasterUserName;\n  final String toBroadcasterUserId;\n  final String toBroadcasterUserName;\n  final int viewerCount;\n\n  const TwitchShoutoutCreateEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.fromBroadcasterUserId,\n      required this.fromBroadcasterUserName,\n      required this.toBroadcasterUserId,\n      required this.toBroadcasterUserName,\n      required this.viewerCount});\n\n  static TwitchShoutoutCreateEventModel fromDocumentData(\n      String messageId, Map<String, dynamic> data) {\n    return TwitchShoutoutCreateEventModel(\n      fromBroadcasterUserId: data['event']['broadcaster_user_id'],\n      fromBroadcasterUserName: data['event']['broadcaster_user_name'],\n      toBroadcasterUserId: data['event']['to_broadcaster_user_id'],\n      toBroadcasterUserName: data['event']['to_broadcaster_user_name'],\n      viewerCount: data['event']['viewer_count'],\n      timestamp: data['timestamp'].toDate(),\n      messageId: messageId,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/badge.dart",
    "content": "import 'dart:async';\nimport 'dart:core';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:rtchat/models/adapters/chat_state.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass TwitchBadgeModel extends ChangeNotifier {\n  StreamSubscription<void>? _globalBadgeSubscription;\n  StreamSubscription<void>? _localBadgeSubscription;\n\n  List<TwitchBadgeInfo> localBadgeSets = [];\n  List<TwitchBadgeInfo> globalBadgeSets = [];\n  Set<String> _enabled = {};\n  bool _isAllEnabled = false;\n\n  set channel(Channel? channel) {\n    localBadgeSets.clear();\n    globalBadgeSets.clear();\n    _globalBadgeSubscription?.cancel();\n    _localBadgeSubscription?.cancel();\n\n    _globalBadgeSubscription = ChatStateAdapter.instance\n        .getTwitchBadges()\n        .asStream()\n        .listen((badgeSets) {\n      globalBadgeSets = badgeSets;\n      notifyListeners();\n    });\n    if (channel != null) {\n      if (channel.provider != \"twitch\") {\n        return;\n      }\n      _localBadgeSubscription = ChatStateAdapter.instance\n          .getTwitchBadges(channelId: channel.channelId)\n          .asStream()\n          .listen((badgeSets) {\n        localBadgeSets = badgeSets;\n        notifyListeners();\n      });\n    }\n  }\n\n  List<TwitchBadgeInfo> get badgeSets {\n    return [...globalBadgeSets, ...localBadgeSets];\n  }\n\n  void setAllEnabled(bool enabled) {\n    if (enabled) {\n      _enabled = badgeSets.map((e) => e.setId).toSet();\n      _isAllEnabled = true;\n    } else {\n      _enabled.clear();\n      _isAllEnabled = false;\n    }\n\n    notifyListeners();\n  }\n\n  void setEnabled(String key, bool enabled) {\n    if (enabled) {\n      _enabled.add(key);\n    } else {\n      _enabled.remove(key);\n    }\n    if (_enabled.length == badgeSets.length) {\n      _isAllEnabled = true;\n    } else {\n      _isAllEnabled = false;\n    }\n\n    notifyListeners();\n  }\n\n  bool isEnabled(String setId) => _enabled.contains(setId) || _isAllEnabled;\n\n  int get badgeCount {\n    final globalKeys = globalBadgeSets.map((e) => e.setId).toSet();\n    final localKeys = localBadgeSets.map((e) => e.setId).toSet();\n    return globalKeys.union(localKeys).length;\n  }\n\n  int get enabledCount => _enabled.length;\n\n  TwitchBadgeModel.fromJson(Map<String, dynamic> json) {\n    final badges = json['enabled'];\n    if (badges != null) {\n      for (dynamic badge in badges) {\n        _enabled.add(badge);\n      }\n      notifyListeners();\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"enabled\": _enabled.toList(),\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/twitch/subscription_message_event.dart",
    "content": "import 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/tokens.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\n\nclass SubscriptionMessageEventEmote {\n  final String id;\n  final int begin;\n  final int end;\n\n  const SubscriptionMessageEventEmote(\n      {required this.id, required this.begin, required this.end});\n\n  static List<SubscriptionMessageEventEmote> fromDynamicList(\n      List<dynamic>? input) {\n    if (input == null) {\n      return [];\n    }\n    return input\n        .map((e) => SubscriptionMessageEventEmote(\n            id: e['id'] as String,\n            begin: e['begin'] as int,\n            end: e['end'] as int))\n        .toList();\n  }\n}\n\nclass TwitchSubscriptionMessageEventModel extends MessageModel {\n  final String subscriberUserName;\n  final String tier;\n  final int cumulativeMonths;\n  final int durationMonths;\n  final int streakMonths;\n  final List<SubscriptionMessageEventEmote> emotes;\n  final String text;\n\n  const TwitchSubscriptionMessageEventModel(\n      {required super.timestamp,\n      required super.messageId,\n      required this.subscriberUserName,\n      required this.tier,\n      required this.cumulativeMonths,\n      required this.durationMonths,\n      required this.streakMonths,\n      required this.emotes,\n      required this.text});\n\n  String emotesToString() {\n    return emotes.map((e) => '${e.id}:${e.begin}-${e.end}').join('/');\n  }\n\n  List<MessageToken> tokenize() {\n    Iterable<MessageToken> tokens = rootEmoteTokenizer(text, emotesToString());\n    tokens = tokenizeTags(tokens);\n    return tokens.toList();\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/messages/tokens.dart",
    "content": "import 'package:flutter/foundation.dart';\n\nabstract class MessageToken {\n  const MessageToken();\n}\n\nclass UserMentionToken extends MessageToken {\n  final String username;\n\n  const UserMentionToken(this.username);\n\n  @override\n  bool operator ==(other) =>\n      other is UserMentionToken && username == other.username;\n\n  @override\n  int get hashCode => username.hashCode;\n\n  @override\n  String toString() => \"@$username\";\n}\n\nclass TextToken extends MessageToken {\n  final String text;\n\n  const TextToken(this.text);\n\n  bool get isWhitespace => text.trim().isEmpty;\n\n  @override\n  bool operator ==(other) => other is TextToken && text == other.text;\n\n  @override\n  int get hashCode => text.hashCode;\n\n  @override\n  String toString() => text;\n}\n\nclass LinkToken extends MessageToken {\n  final Uri url;\n  final String text;\n\n  const LinkToken({required this.url, required this.text});\n\n  @override\n  bool operator ==(other) =>\n      other is LinkToken && other.url == url && other.text == text;\n\n  @override\n  int get hashCode => url.hashCode ^ text.hashCode;\n\n  @override\n  String toString() => text;\n}\n\nclass EmoteToken extends MessageToken {\n  final Uri url;\n  final String code;\n\n  const EmoteToken({required this.url, required this.code});\n\n  @override\n  bool operator ==(other) => other is EmoteToken && url == other.url;\n\n  @override\n  int get hashCode => url.hashCode;\n\n  @override\n  String toString() => code;\n}\n\nclass CompactedToken extends MessageToken {\n  final List<MessageToken> children;\n  final int multiplicity;\n\n  const CompactedToken(this.children, this.multiplicity);\n\n  @override\n  bool operator ==(other) =>\n      other is CompactedToken && listEquals(children, other.children);\n\n  @override\n  int get hashCode =>\n      children.map((child) => child.hashCode).reduce((a, b) => a ^ b);\n\n  @override\n  String toString() => children.toString();\n}\n\nextension IterableMessageToken<T extends MessageToken> on Iterable<T> {\n  /// Returns the shortest repeating tokenization.\n  Iterable<MessageToken> get compacted sync* {\n    // TODO: We can be more clever around partial compactions.\n    final list = toList();\n    for (var length = 1; length <= list.length / 2; length++) {\n      final last = list[length - 1];\n      final isSpaceDelimited = last is TextToken && last.isWhitespace;\n      if ((list.length + (isSpaceDelimited ? 1 : 0)) % length != 0) {\n        // must be a divisor of the list length.\n        continue;\n      }\n      var repeating = true;\n      for (var index = length; index < list.length; index++) {\n        if (list[index] != list[index % length]) {\n          repeating = false;\n          break;\n        }\n      }\n      if (repeating) {\n        yield CompactedToken(\n            list.sublist(0, length - (isSpaceDelimited ? 1 : 0)),\n            (list.length + (isSpaceDelimited ? 1 : 0)) ~/ length);\n        return;\n      }\n    }\n    yield* list;\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/channels.dart",
    "content": "import 'dart:core';\n\nimport 'package:rtchat/components/image/resilient_network_image.dart';\n\nclass Channel {\n  final String provider;\n  final String channelId;\n  final String displayName;\n\n  Channel(this.provider, this.channelId, this.displayName);\n\n  @override\n  bool operator ==(other) =>\n      other is Channel &&\n      other.provider == provider &&\n      other.channelId == channelId;\n\n  @override\n  int get hashCode => provider.hashCode ^ channelId.hashCode;\n\n  @override\n  String toString() => \"$provider:$channelId\";\n\n  Uri get profilePictureUrl {\n    return Uri.parse(\n        \"https://rtirl.com/pfp.png?provider=twitch&channelId=$channelId\");\n  }\n\n  ResilientNetworkImage get profilePicture {\n    return ResilientNetworkImage(profilePictureUrl);\n  }\n\n  Map<String, dynamic> toJson() {\n    return {\n      'provider': provider,\n      'channelId': channelId,\n      'displayName': displayName,\n    };\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/chat_mode.dart",
    "content": "enum ChatMode {\n  followers(\n      title: \"/followers\",\n      subtitle:\n          \"Restrict the chat to followers-only mode; optionally, specify a time duration (e.g., 30 minutes, 1 week)\"),\n  followersoff(title: \"/followersoff\", subtitle: \"Disable followers-only mode\"),\n  subscribers(title: \"/subscribers\", subtitle: \"Restrict Chat to subscribers\"),\n  subscribersoff(\n      title: \"/subscribersoff\", subtitle: \"Turn off subscribers-only mode\"),\n  uniquechat(\n      title: \"/uniquechat\",\n      subtitle: \"Prevent users from sending duplicate messages in Chat\"),\n  uniquechatoff(title: \"/uniquechatoff\", subtitle: \"Turn off unique-chat mode\"),\n  emoteonly(\n      title: \"/emoteonly\",\n      subtitle: \"Users can only send emotes in their messages\"),\n  emoteonlyoff(title: \"/emoteonlyoff\", subtitle: \"Disable emotes only mode\"),\n  slow(\n      title: \"/slow\",\n      subtitle: \"Limit the rate at which users can send messages\"),\n  slowoff(title: \"/slowoff\", subtitle: \"Disable slow mode\");\n\n  const ChatMode({\n    required this.title,\n    required this.subtitle,\n  });\n\n  final String title;\n  final String subtitle;\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/activity_feed.dart",
    "content": "import 'dart:core';\n\nimport 'package:flutter/foundation.dart';\n\nclass ActivityFeedModel extends ChangeNotifier {\n  bool _isEnabled = false;\n  bool _isCustom = false;\n  String _customUrl = \"\";\n\n  bool get isCustom => _isCustom;\n\n  set isCustom(bool isCustom) {\n    _isCustom = isCustom;\n    notifyListeners();\n  }\n\n  bool get isEnabled => _isEnabled;\n\n  set isEnabled(bool isEnabled) {\n    _isEnabled = isEnabled;\n    notifyListeners();\n  }\n\n  String get customUrl => _customUrl;\n\n  set customUrl(String customUrl) {\n    _customUrl = customUrl;\n    notifyListeners();\n  }\n\n  ActivityFeedModel.fromJson(Map<String, dynamic> json) {\n    if (json['isCustom'] != null) {\n      _isCustom = json['isCustom'];\n    }\n    if (json['customUrl'] != null) {\n      _customUrl = json['customUrl'];\n    }\n    if (json['isEnabled'] != null) {\n      _isEnabled = json['isEnabled'];\n    } else if (json['isCustom'] != null) {\n      _isEnabled =\n          true; // to migrate users from old activity feed default true.\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"isCustom\": _isCustom,\n        \"customUrl\": _customUrl,\n        \"isEnabled\": _isEnabled,\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/style.dart",
    "content": "import 'dart:core';\n\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\n\nColor darken(Color color, [double amount = .1]) {\n  assert(amount >= 0 && amount <= 1);\n\n  final hsl = HSLColor.fromColor(color);\n  final hslDark = hsl.withLightness((hsl.lightness) * (1 - amount));\n\n  return hslDark.toColor();\n}\n\nColor lighten(Color color, [double amount = .1]) {\n  assert(amount >= 0 && amount <= 1);\n\n  final hsl = HSLColor.fromColor(color);\n  final hslLight = hsl.withLightness((hsl.lightness) * (1 - amount) + amount);\n\n  return hslLight.toColor();\n}\n\nenum CompactMessages { none, withinMessage, acrossMessages }\n\nextension CompactMessagesJson on CompactMessages {\n  static fromJson(dynamic value) {\n    switch (value) {\n      case 0:\n        return CompactMessages.none;\n      case 1:\n        return CompactMessages.withinMessage;\n      case 2:\n        return CompactMessages.acrossMessages;\n      default:\n        return CompactMessages.none;\n    }\n  }\n\n  toJson() {\n    switch (this) {\n      case CompactMessages.none:\n        return 0;\n      case CompactMessages.withinMessage:\n        return 1;\n      case CompactMessages.acrossMessages:\n        return 2;\n    }\n  }\n}\n\nclass StyleModel extends ChangeNotifier {\n  double _fontSize = 20;\n  double _lightnessBoost = 0.179;\n  bool _isDeletedMessagesVisible = true;\n  CompactMessages _compactMessages = CompactMessages.none;\n  bool _isDiscoModeAvailable = false;\n  bool _isLoginShown = true;\n\n  double get fontSize {\n    return _fontSize;\n  }\n\n  set fontSize(double fontSize) {\n    _fontSize = fontSize;\n    notifyListeners();\n  }\n\n  double get lightnessBoost => _lightnessBoost;\n\n  set lightnessBoost(double lightnessBoost) {\n    _lightnessBoost = lightnessBoost;\n    notifyListeners();\n  }\n\n  Color applyLightnessBoost(BuildContext context, Color color) {\n    switch (Theme.of(context).brightness) {\n      case Brightness.dark:\n        return lighten(color, lightnessBoost);\n      case Brightness.light:\n        return darken(color, lightnessBoost);\n    }\n  }\n\n  set isDeletedMessagesVisible(bool isDeletedMessagesVisible) {\n    _isDeletedMessagesVisible = isDeletedMessagesVisible;\n    notifyListeners();\n  }\n\n  bool get isDeletedMessagesVisible => _isDeletedMessagesVisible;\n\n  set compactMessages(CompactMessages compactMessages) {\n    _compactMessages = compactMessages;\n    notifyListeners();\n  }\n\n  CompactMessages get compactMessages => _compactMessages;\n\n  set isDiscoModeAvailable(bool isDiscoModeAvailable) {\n    _isDiscoModeAvailable = isDiscoModeAvailable;\n    notifyListeners();\n  }\n\n  bool get isLoginShown => _isLoginShown;\n\n  set isLoginShown(bool isLoginShown) {\n    _isLoginShown = isLoginShown;\n    notifyListeners();\n  }\n\n  String getTwitchDisplayName(TwitchUserModel user) {\n    final author = user.displayName ?? user.login;\n    if (author.toLowerCase() != user.login && isLoginShown) {\n      // this is an internationalized name.\n      return \"${user.displayName} (${user.login})\";\n    }\n    return author;\n  }\n\n  bool get isDiscoModeAvailable => _isDiscoModeAvailable;\n\n  StyleModel.fromJson(Map<String, dynamic> json) {\n    if (json['fontSize'] != null) {\n      _fontSize = json['fontSize'];\n    }\n    if (json['lightnessBoost'] != null) {\n      _lightnessBoost = json['lightnessBoost'];\n    }\n    if (json['isDeletedMessagesVisible'] != null) {\n      _isDeletedMessagesVisible = json['isDeletedMessagesVisible'];\n    }\n    if (json['compactMessages'] != null) {\n      _compactMessages = CompactMessagesJson.fromJson(json['compactMessages']);\n    }\n    if (json['isDiscoModeEnabled'] != null) {\n      _isDiscoModeAvailable = json['isDiscoModeEnabled'];\n    }\n    if (json['isLoginShown'] != null) {\n      _isLoginShown = json['isLoginShown'];\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"lightnessBoost\": _lightnessBoost,\n        \"fontSize\": _fontSize,\n        \"isDeletedMessagesVisible\": _isDeletedMessagesVisible,\n        \"compactMessages\": _compactMessages.toJson(),\n        \"isDiscoModeEnabled\": _isDiscoModeAvailable,\n        \"isLoginShown\": _isLoginShown,\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/models/quick_links.dart",
    "content": "import 'dart:core';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nclass QuickLinkSource {\n  final String icon;\n  final Uri url;\n  final String label;\n\n  QuickLinkSource(this.icon, this.url, this.label);\n\n  @override\n  bool operator ==(other) =>\n      other is QuickLinkSource && other.url == url && other.label == label;\n\n  @override\n  int get hashCode => url.hashCode;\n\n  QuickLinkSource.fromJson(Map<String, dynamic> json)\n      : icon = json['icon'],\n        url = Uri.parse(json['url']),\n        label = json['label'] ?? json['url']; // null coalescing for migration.\n\n  Map<String, dynamic> toJson() => {\n        \"url\": url.toString(),\n        \"icon\": icon,\n        \"label\": label,\n      };\n\n  @override\n  String toString() => url.toString();\n}\n\nclass QuickLinksModel extends ChangeNotifier {\n  final List<QuickLinkSource> _sources = [];\n\n  List<QuickLinkSource> get sources => _sources;\n\n  void addSource(QuickLinkSource source) {\n    _sources.add(source);\n    notifyListeners();\n  }\n\n  void removeSource(QuickLinkSource source) {\n    _sources.remove(source);\n    notifyListeners();\n  }\n\n  void swapSource(int a, int b) {\n    if (a < b) {\n      b -= 1;\n    }\n    final item = _sources.removeAt(a);\n    _sources.insert(b, item);\n    notifyListeners();\n  }\n\n  QuickLinksModel.fromJson(Map<String, dynamic> json) {\n    final sources = json['sources'];\n    if (sources != null) {\n      for (dynamic source in sources) {\n        _sources.add(QuickLinkSource.fromJson(source));\n      }\n    }\n  }\n\n  Map<String, dynamic> toJson() => {\n        \"sources\": _sources.map((source) => source.toJson()).toList(),\n      };\n}"
  },
  {
    "file": "/root/development/rtchat/lib/audio_channel.dart",
    "content": "import 'package:flutter/services.dart';\n\nclass AudioChannel {\n  static const _channel = MethodChannel('com.rtirl.chat/audio');\n\n  static set(List<String> urls) async {\n    if (await hasPermission()) {\n      await _channel.invokeMethod<bool>('set', {\"urls\": urls});\n    }\n  }\n\n  static reload(String url) async {\n    await _channel.invokeMethod<bool>('reload', {\"url\": url});\n  }\n\n  static Future<bool> requestPermission() async {\n    return await _channel.invokeMethod<bool>('requestPermission') ?? false;\n  }\n\n  static Future<bool> hasPermission() async {\n    return await _channel.invokeMethod<bool>('hasPermission') ?? false;\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/drawer/sliver_title.dart",
    "content": "import 'package:flutter/material.dart';\n\nclass SliverTitleWidget extends StatelessWidget {\n  final String title;\n  const SliverTitleWidget({super.key, required this.title});\n\n  @override\n  Widget build(BuildContext context) {\n    return SliverList(\n      delegate: SliverChildListDelegate(\n        [\n          Padding(\n            padding: const EdgeInsets.only(left: 16, bottom: 4, top: 8),\n            child: Text(\n              title,\n              style: TextStyle(\n                  color: Theme.of(context).colorScheme.secondary, fontSize: 18),\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/drawer/sliver_search_bar.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass SliverSearchBarWidget extends StatelessWidget {\n  final void Function(String) onFilterBySearchBarText;\n\n  const SliverSearchBarWidget(\n      {super.key, required this.onFilterBySearchBarText});\n\n  @override\n  Widget build(BuildContext context) {\n    return SliverList(\n      delegate: SliverChildListDelegate([\n        Padding(\n          padding: const EdgeInsets.fromLTRB(24, 0, 24, 8),\n          child: Center(\n            child: Container(\n              height: 50,\n              decoration: BoxDecoration(\n                borderRadius: const BorderRadius.all(Radius.circular(10)),\n                color: Theme.of(context).inputDecorationTheme.fillColor,\n              ),\n              child: Row(\n                children: [\n                  const SizedBox(width: 24.0),\n                  Expanded(\n                    child: TextField(\n                      textInputAction: TextInputAction.search,\n                      decoration: InputDecoration(\n                        hintText: AppLocalizations.of(context)!.search,\n                        isDense: true,\n                        border: InputBorder.none,\n                      ),\n                      onChanged: (value) async {\n                        onFilterBySearchBarText(value);\n                      },\n                    ),\n                  ),\n                  const Padding(\n                    padding: EdgeInsets.only(right: 20),\n                    child: Icon(Icons.search),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/drawer/quicklinks_listview.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:metadata_fetch/metadata_fetch.dart';\nimport 'package:provider/provider.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/models/quick_links.dart';\nimport 'package:rtchat/screens/settings/quick_links.dart';\nimport 'package:rtchat/urls.dart';\n\nclass QuicklinksListView extends StatelessWidget {\n  const QuicklinksListView({super.key});\n\n  Future<String> retrieveName(QuickLinkSource link) async {\n    final metadata = await MetadataFetch.extract(link.url.toString());\n    return metadata?.title ?? link.url.toString();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<QuickLinksModel>(\n        builder: (context, quickLinksModel, child) {\n      return Column(\n        children: quickLinksModel.sources.map((source) {\n          final url = source.url.toString();\n          return ListTile(\n            leading: Icon(quickLinksIconsMap[source.icon] ?? Icons.link),\n            title: Text(source.label),\n            subtitle: Text(\n              url,\n              maxLines: 1,\n              overflow: TextOverflow.ellipsis,\n            ),\n            onTap: () => openUrl(source.url),\n            onLongPress: () async {\n              Navigator.pop(context);\n              await Clipboard.setData(ClipboardData(text: url));\n              if (!context.mounted) return;\n              ScaffoldMessenger.of(context).showSnackBar(\n                SnackBar(\n                    content:\n                        Text(AppLocalizations.of(context)!.copiedToClipboard)),\n              );\n            },\n          );\n        }).toList(),\n      );\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/drawer/end_drawer.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/drawer/sliver_search_bar.dart';\nimport 'package:rtchat/components/drawer/sliver_title.dart';\nimport 'package:rtchat/models/adapters/chat_state.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass EndDrawerWidget extends StatefulWidget {\n  final Channel channel;\n\n  const EndDrawerWidget({required this.channel, super.key});\n\n  @override\n  State<EndDrawerWidget> createState() => EndDrawerWidgetState();\n}\n\nclass EndDrawerWidgetState extends State<EndDrawerWidget> {\n  String _search = \"\";\n  Viewers? _viewers;\n  bool _isLoading = true;\n  bool _isError = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadViewers();\n  }\n\n  void _loadViewers() async {\n    try {\n      final viewers = await ChatStateAdapter.instance\n          .getViewers(channelId: widget.channel.toString());\n      if (!mounted) return;\n      setState(() {\n        _viewers = viewers;\n        _isLoading = false;\n      });\n    } catch (e) {\n      if (!mounted) return;\n      setState(() {\n        _isLoading = false;\n        _isError = true;\n      });\n      _showTemporaryError();\n    }\n  }\n\n  void _showTemporaryError() {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(\n        content: Text(AppLocalizations.of(context)!.errorFetchingViewerList),\n        duration: const Duration(seconds: 5),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isLoading) {\n      return const CircularProgressIndicator();\n    }\n    // Check if viewers data is available and build UI accordingly\n    if (_viewers == null || _isError) {\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        if (mounted) {\n          Navigator.of(context).pop();\n        }\n      });\n      // Show loading or empty state\n      return const CircularProgressIndicator();\n    }\n\n    final filtered = _viewers!.query(_search);\n\n    return Container(\n        color: Theme.of(context).canvasColor,\n        child: SafeArea(\n            top: false,\n            child: CustomScrollView(\n              slivers: [\n                SliverPadding(\n                  padding: const EdgeInsets.only(top: 24),\n                  sliver: SliverAppBar(\n                    actions: const [SizedBox()],\n                    centerTitle: false,\n                    title: Padding(\n                      padding: const EdgeInsets.only(left: 16),\n                      child: Text(\n                        AppLocalizations.of(context)!.searchViewers,\n                        style: Theme.of(context)\n                            .textTheme\n                            .headlineSmall\n                            ?.copyWith(fontWeight: FontWeight.bold),\n                      ),\n                    ),\n                    backgroundColor: Colors.transparent,\n                    automaticallyImplyLeading: false,\n                  ),\n                ),\n                SliverSearchBarWidget(\n                  onFilterBySearchBarText: (value) =>\n                      setState(() => _search = value),\n                ),\n                if (filtered.broadcaster.isNotEmpty) ...[\n                  SliverPadding(\n                    padding: const EdgeInsets.only(top: 8, left: 8),\n                    sliver: SliverTitleWidget(\n                        title: AppLocalizations.of(context)!.broadcaster),\n                  ),\n                  SliverList(\n                    delegate: SliverChildListDelegate(\n                      filtered.broadcaster.map((name) {\n                        return Padding(\n                          padding: const EdgeInsets.only(left: 24),\n                          child: Text(name),\n                        );\n                      }).toList(),\n                    ),\n                  ),\n                ],\n                if (filtered.moderators.isNotEmpty) ...[\n                  SliverPadding(\n                    padding: const EdgeInsets.only(top: 8, left: 8),\n                    sliver: SliverTitleWidget(\n                        title: AppLocalizations.of(context)!.moderators),\n                  ),\n                  SliverList(\n                    delegate: SliverChildListDelegate(\n                      filtered.moderators.map((name) {\n                        return Padding(\n                          padding: const EdgeInsets.only(left: 24),\n                          child: Text(name),\n                        );\n                      }).toList(),\n                    ),\n                  ),\n                ],\n                if (filtered.vips.isNotEmpty) ...[\n                  SliverPadding(\n                    padding: const EdgeInsets.only(top: 8, left: 8),\n                    sliver: SliverTitleWidget(\n                        title: AppLocalizations.of(context)!.communityVips),\n                  ),\n                  SliverList(\n                    delegate: SliverChildListDelegate(\n                      filtered.vips.map((name) {\n                        return Padding(\n                          padding: const EdgeInsets.only(left: 24),\n                          child: Text(name),\n                        );\n                      }).toList(),\n                    ),\n                  ),\n                ],\n                if (filtered.viewers.isNotEmpty) ...[\n                  SliverPadding(\n                    padding: const EdgeInsets.only(top: 8, left: 8),\n                    sliver: SliverTitleWidget(\n                        title: AppLocalizations.of(context)!.viewers),\n                  ),\n                  SliverList(\n                    delegate: SliverChildListDelegate(\n                      filtered.viewers.map((name) {\n                        return Padding(\n                          padding: const EdgeInsets.only(left: 24),\n                          child: Text(name),\n                        );\n                      }).toList(),\n                    ),\n                  ),\n                ],\n              ],\n            )));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/drawer/sidebar.dart",
    "content": "import 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/channel_search_bottom_sheet.dart';\nimport 'package:rtchat/components/drawer/quicklinks_listview.dart';\nimport 'package:rtchat/components/image/cross_fade_image.dart';\nimport 'package:rtchat/models/adapters/actions.dart';\nimport 'package:rtchat/models/audio.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/layout.dart';\nimport 'package:rtchat/models/qr_code.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/screens/settings/qr.dart';\nimport 'package:rtchat/urls.dart';\n\nclass _DrawerHeader extends StatelessWidget {\n  const _DrawerHeader();\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: 146,\n      child: DrawerHeader(\n          padding: EdgeInsets.zero,\n          child: Column(\n            children: [\n              GestureDetector(\n                onTap: () => openUrl(Uri.parse(\"https://muxable.com\")),\n                child: SizedBox(\n                  height: 50,\n                  child: Padding(\n                    padding: const EdgeInsets.all(12),\n                    child: Consumer<LayoutModel>(\n                      builder: (context, value, child) {\n                        return ColorFiltered(\n                            colorFilter: value.themeMode == ThemeMode.light\n                                ? const ColorFilter.matrix(<double>[\n                                    -1.0, 0.0, 0.0, 0.0, 255.0, //\n                                    0.0, -1.0, 0.0, 0.0, 255.0, //\n                                    0.0, 0.0, -1.0, 0.0, 255.0, //\n                                    0.0, 0.0, 0.0, 1.0, 0.0, //\n                                  ])\n                                : const ColorFilter.matrix(<double>[\n                                    1.0, 0.0, 0.0, 0.0, 0.0, //\n                                    0.0, 1.0, 0.0, 0.0, 0.0, //\n                                    0.0, 0.0, 1.0, 0.0, 0.0, //\n                                    0.0, 0.0, 0.0, 1.0, 0.0, //\n                                  ]),\n                            child: Image.asset(\"assets/muxable.png\"));\n                      },\n                    ),\n                  ),\n                ),\n              ),\n              Row(\n                children: [\n                  Expanded(\n                    child:\n                        Consumer<UserModel>(builder: (context, model, child) {\n                      final userChannel = model.userChannel;\n                      return InkWell(\n                        borderRadius: BorderRadius.circular(10.0),\n                        onTap: () {\n                          if (model.activeChannel != userChannel) {\n                            model.activeChannel = userChannel;\n                          }\n                          Navigator.of(context).pop();\n                        },\n                        child: Row(children: [\n                          if (userChannel != null) const SizedBox(width: 16),\n                          if (userChannel != null)\n                            ClipRRect(\n                              borderRadius: BorderRadius.circular(24),\n                              child: CrossFadeImage(\n                                  placeholder: userChannel\n                                      .profilePicture.placeholderImage,\n                                  image: userChannel.profilePicture,\n                                  height: 36,\n                                  width: 36),\n                            ),\n                          const SizedBox(width: 16),\n                          Expanded(\n                            child: Column(\n                              mainAxisAlignment: MainAxisAlignment.center,\n                              crossAxisAlignment: CrossAxisAlignment.start,\n                              children: [\n                                Text(\n                                  userChannel?.displayName ??\n                                      AppLocalizations.of(context)!.notSignedIn,\n                                  overflow: TextOverflow.ellipsis,\n                                  style: Theme.of(context).textTheme.bodyLarge,\n                                ),\n                                const SizedBox(height: 8),\n                                Text(\"twitch.tv\",\n                                    overflow: TextOverflow.ellipsis,\n                                    style:\n                                        Theme.of(context).textTheme.bodyMedium),\n                              ],\n                            ),\n                          ),\n                        ]),\n                      );\n                    }),\n                  ),\n                  const VerticalDivider(\n                    width: 4,\n                    thickness: 2,\n                    indent: 8,\n                    endIndent: 8,\n                  ),\n                  Consumer<UserModel>(builder: (context, model, child) {\n                    final userChannel = model.userChannel;\n                    if (userChannel == null) {\n                      return Container();\n                    }\n                    return Padding(\n                      padding: const EdgeInsets.all(8.0),\n                      child: IconButton(\n                        icon: const Icon(Icons.qr_code),\n                        onPressed: () {\n                          Navigator.of(context).pop();\n\n                          showDialog(\n                            context: context,\n                            builder: (context) {\n                              return Dialog(\n                                shape: RoundedRectangleBorder(\n                                  borderRadius: BorderRadius.circular(25.0),\n                                ),\n                                child: Consumer<QRModel>(\n                                  builder: (context, qrModel, child) {\n                                    return Container(\n                                      width: MediaQuery.of(context)\n                                                  .orientation ==\n                                              Orientation.landscape\n                                          ? MediaQuery.of(context).size.width *\n                                              0.01\n                                          : double.infinity,\n                                      decoration: BoxDecoration(\n                                        gradient: qrModel.currentGradient,\n                                        borderRadius:\n                                            const BorderRadius.vertical(\n                                                top: Radius.circular(25.0),\n                                                bottom: Radius.circular(25.0)),\n                                      ),\n                                      child: const QRDisplay(),\n                                    );\n                                  },\n                                ),\n                              );\n                            },\n                          );\n                        },\n                      ),\n                    );\n                  }),\n                  Padding(\n                    padding: const EdgeInsets.all(8),\n                    child: IconButton(\n                      icon: const Icon(Icons.search),\n                      iconSize: 32,\n                      splashRadius: 24,\n                      tooltip: AppLocalizations.of(context)!.searchChannels,\n                      onPressed: () {\n                        Navigator.of(context).pop();\n                        FirebaseAnalytics.instance.logEvent(\n                            name: 'search_channels', parameters: null);\n                        showModalBottomSheet<void>(\n                          context: context,\n                          isScrollControlled: true,\n                          shape: const RoundedRectangleBorder(\n                            borderRadius:\n                                BorderRadius.vertical(top: Radius.circular(16)),\n                          ),\n                          builder: (context) {\n                            return DraggableScrollableSheet(\n                              initialChildSize: 0.8,\n                              maxChildSize: 0.9,\n                              expand: false,\n                              builder: (context, controller) {\n                                final model = Provider.of<UserModel>(context,\n                                    listen: false);\n                                final userChannel = model.userChannel;\n                                return ChannelSearchBottomSheetWidget(\n                                  onChannelSelect: (channel) {\n                                    model.activeChannel = channel;\n                                  },\n                                  onRaid: userChannel == model.activeChannel &&\n                                          userChannel != null\n                                      ? (channel) {\n                                          final activeChannel =\n                                              model.activeChannel;\n                                          if (activeChannel == null) {\n                                            return;\n                                          }\n                                          ActionsAdapter.instance\n                                              .raid(activeChannel, channel);\n                                        }\n                                      : null,\n                                  controller: controller,\n                                );\n                              },\n                            );\n                          },\n                        );\n                      },\n                    ),\n                  ),\n                ],\n              ),\n            ],\n          )),\n    );\n  }\n}\n\nclass Sidebar extends StatefulWidget {\n  final Channel channel;\n\n  const Sidebar({required this.channel, super.key});\n\n  @override\n  State<Sidebar> createState() => _SidebarState();\n}\n\nclass _SidebarState extends State<Sidebar> {\n  @override\n  Widget build(BuildContext context) {\n    final tiles = <Widget>[\n      ListTile(\n          leading: const Icon(Icons.add_link_sharp),\n          title: Text(AppLocalizations.of(context)!.configureQuickLinks),\n          onTap: () =>\n              Navigator.of(context).pushNamed(\"/settings/quick-links\")),\n\n      const Divider(),\n\n      // setting\n      Consumer<LayoutModel>(builder: (context, layoutModel, child) {\n        if (!layoutModel.locked) {\n          return ListTile(\n            leading: const Icon(Icons.thunderstorm),\n            title: Text(AppLocalizations.of(context)!.enableRainMode),\n            subtitle: Text(AppLocalizations.of(context)!.enableRainModeSubtitle,\n                overflow: TextOverflow.ellipsis),\n            onTap: () async {\n              layoutModel.locked = !layoutModel.locked;\n              Navigator.pop(context);\n            },\n          );\n        }\n\n        return ListTile(\n          leading: const Icon(Icons.thunderstorm),\n          title: Text(AppLocalizations.of(context)!.disableRainMode),\n          subtitle: Text(AppLocalizations.of(context)!.disableRainModeSubtitle,\n              overflow: TextOverflow.ellipsis),\n          onTap: () async {\n            layoutModel.locked = !layoutModel.locked;\n            Navigator.pop(context);\n          },\n        );\n      }),\n\n      Consumer<AudioModel>(builder: (context, audioModel, child) {\n        if (audioModel.sources.isEmpty) {\n          return Container();\n        }\n        return ListTile(\n          leading: const Icon(Icons.cached_outlined),\n          title: Text(AppLocalizations.of(context)!.refreshAudioSources),\n          onTap: () async {\n            final scaffoldMessenger = ScaffoldMessenger.of(context);\n            final count = await audioModel.refreshAllSources();\n            if (!context.mounted) return;\n            scaffoldMessenger.showSnackBar(SnackBar(\n                content: Text(AppLocalizations.of(context)!\n                    .refreshAudioSourcesCount(count))));\n          },\n        );\n      }),\n\n      //raid\n      Consumer<UserModel>(builder: (context, model, child) {\n        return ListTile(\n          leading: const Icon(Icons.connect_without_contact),\n          title: Text(AppLocalizations.of(context)!.raidAChannel),\n          onTap: () {\n            Navigator.of(context).pop();\n            showModalBottomSheet<void>(\n              context: context,\n              isScrollControlled: true,\n              shape: const RoundedRectangleBorder(\n                borderRadius: BorderRadius.vertical(top: Radius.circular(16)),\n              ),\n              builder: (context) {\n                return DraggableScrollableSheet(\n                  initialChildSize: 0.8,\n                  maxChildSize: 0.9,\n                  expand: false,\n                  builder: (context, controller) {\n                    final model =\n                        Provider.of<UserModel>(context, listen: false);\n                    final userChannel = model.userChannel;\n                    return ChannelSearchBottomSheetWidget(\n                      isRaid: true,\n                      onChannelSelect: (channel) {\n                        model.activeChannel = channel;\n                      },\n                      onRaid: userChannel == model.activeChannel &&\n                              userChannel != null\n                          ? (channel) {\n                              final activeChannel = model.activeChannel;\n                              if (activeChannel == null) {\n                                return;\n                              }\n                              ActionsAdapter.instance\n                                  .raid(activeChannel, channel);\n                            }\n                          : null,\n                      controller: controller,\n                    );\n                  },\n                );\n              },\n            );\n          },\n        );\n      }),\n\n      ListTile(\n        leading: const Icon(Icons.build_outlined),\n        title: Text(AppLocalizations.of(context)!.settings),\n        onTap: () async {\n          await Navigator.pushNamed(context, \"/settings\");\n        },\n      ),\n      Consumer<UserModel>(builder: (context, model, child) {\n        if (!model.isSignedIn()) {\n          return Container();\n        }\n        return ListTile(\n          leading: const Icon(Icons.logout_outlined),\n          iconColor: Colors.redAccent,\n          title: Text(AppLocalizations.of(context)!.signOut),\n          onTap: () async {\n            await showDialog(\n              context: context,\n              builder: (context) {\n                return AlertDialog(\n                  title: Text(AppLocalizations.of(context)!.signOut),\n                  content:\n                      Text(AppLocalizations.of(context)!.signOutConfirmation),\n                  actions: [\n                    TextButton(\n                      child: Text(AppLocalizations.of(context)!.cancel),\n                      onPressed: () {\n                        Navigator.of(context).pop();\n                      },\n                    ),\n                    TextButton(\n                      child: Text(AppLocalizations.of(context)!.signOut),\n                      onPressed: () async {\n                        final navigator = Navigator.of(context);\n                        await Provider.of<UserModel>(context, listen: false)\n                            .signOut();\n                        if (!mounted) return;\n                        navigator.pop();\n                      },\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n        );\n      }),\n    ];\n    return Drawer(\n      child: SafeArea(\n        child: Column(\n          children: [\n            const _DrawerHeader(),\n\n            // quicklinks\n            Expanded(child: Builder(builder: (context) {\n              final orientation = MediaQuery.of(context).orientation;\n              if (orientation == Orientation.portrait) {\n                return CustomScrollView(shrinkWrap: true, slivers: [\n                  const SliverToBoxAdapter(\n                    child: QuicklinksListView(),\n                  ),\n                  SliverFillRemaining(\n                      hasScrollBody: false,\n                      child: Column(\n                        mainAxisAlignment: MainAxisAlignment.end,\n                        children: tiles,\n                      ))\n                ]);\n              } else {\n                return ListView(\n                    padding: EdgeInsets.zero,\n                    children: [const QuicklinksListView(), ...tiles]);\n              }\n            }))\n          ],\n        ),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/header_search_bar.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass HeaderSearchBar extends StatelessWidget {\n  final void Function(String) onFilterBySearchBarText;\n\n  const HeaderSearchBar({super.key, required this.onFilterBySearchBarText});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedBox(\n      decoration: BoxDecoration(\n        borderRadius: const BorderRadius.all(Radius.circular(10)),\n        color: Theme.of(context).inputDecorationTheme.fillColor,\n      ),\n      child: Padding(\n        padding: const EdgeInsets.symmetric(horizontal: 8.0),\n        child: TextField(\n          textInputAction: TextInputAction.search,\n          autofocus: true,\n          style: TextStyle(\n            color: Theme.of(context).colorScheme.onSurface,\n          ),\n          decoration: InputDecoration(\n            hintText: AppLocalizations.of(context)!.search,\n            isDense: true,\n            border: InputBorder.none,\n            hintStyle: TextStyle(\n              color: Theme.of(context).colorScheme.primary,\n            ),\n          ),\n          onChanged: (value) async {\n            onFilterBySearchBarText(value);\n          },\n        ),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/scanner_settings.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\n\nclass ScannerSettings extends StatelessWidget {\n  const ScannerSettings({super.key, required this.scanController});\n\n  final MobileScannerController scanController;\n\n  @override\n  Widget build(BuildContext context) {\n    const Color iconColor = Colors.white;\n    return ValueListenableBuilder(\n      valueListenable: scanController,\n      builder: (context, value, child) {\n        return Row(\n          mainAxisSize: MainAxisSize.max,\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: [\n            IconButton(\n              onPressed: () => Navigator.pop(context),\n              icon: const Icon(\n                Icons.close,\n                color: iconColor,\n              ),\n            ),\n            IconButton(\n              onPressed: () => scanController.toggleTorch(),\n              icon: Icon(\n                scanController.value.torchState == TorchState.on\n                    ? Icons.flash_off\n                    : Icons.flash_on,\n                color: iconColor,\n              ),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/channel_search_bottom_sheet.dart",
    "content": "import 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/channel_search_results.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass ChannelSearchBottomSheetWidget extends StatefulWidget {\n  final ScrollController? controller;\n  final void Function(Channel) onChannelSelect;\n  final void Function(Channel)? onRaid;\n  final bool? isRaid;\n\n  const ChannelSearchBottomSheetWidget(\n      {super.key,\n      this.controller,\n      required this.onChannelSelect,\n      this.onRaid,\n      this.isRaid});\n\n  @override\n  State<ChannelSearchBottomSheetWidget> createState() =>\n      _ChannelSearchBottomSheetWidgetState();\n}\n\nclass _ChannelSearchBottomSheetWidgetState\n    extends State<ChannelSearchBottomSheetWidget> {\n  final _searchController = TextEditingController();\n  var _value = \"\";\n  var _raid = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _raid = widget.isRaid ?? false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        children: [\n          Row(children: [\n            Expanded(\n                child: Text(\n                    _raid && widget.onRaid != null\n                        ? AppLocalizations.of(context)!.raidAChannel\n                        : AppLocalizations.of(context)!.searchChannels,\n                    style: Theme.of(context).textTheme.headlineMedium)),\n            if (widget.onRaid != null)\n              Switch.adaptive(\n                  value: _raid,\n                  onChanged: (value) => setState(() => _raid = value))\n          ]),\n          const SizedBox(height: 16),\n          TextField(\n              textInputAction: TextInputAction.search,\n              autofocus: true,\n              controller: _searchController,\n              decoration: InputDecoration(\n                  border: OutlineInputBorder(\n                      borderRadius: BorderRadius.circular(10.0),\n                      borderSide: BorderSide.none),\n                  filled: true,\n                  hintStyle:\n                      TextStyle(color: Theme.of(context).colorScheme.primary),\n                  prefixIcon: const Padding(\n                      padding: EdgeInsets.only(left: 16, right: 8),\n                      child: Text(\"twitch.tv/\")),\n                  prefixIconConstraints:\n                      const BoxConstraints(minWidth: 0, minHeight: 0),\n                  suffixIcon: AnimatedScale(\n                    scale: _value == \"\" ? 0.0 : 1.0,\n                    duration: const Duration(milliseconds: 150),\n                    child: GestureDetector(\n                        child: const Icon(Icons.cancel),\n                        onTap: () {\n                          _searchController.clear();\n                          setState(() => _value = \"\");\n                        }),\n                  ),\n                  hintText: \"muxfd\"),\n              onChanged: (value) {\n                setState(() {\n                  _value = value;\n                });\n              }),\n          Expanded(\n              child: ChannelSearchResultsWidget(\n            query: _value,\n            controller: widget.controller,\n            onChannelSelect: (channel) {\n              if (_raid && widget.onRaid != null) {\n                FirebaseAnalytics.instance.logEvent(\n                    name: \"raid\", parameters: {\"channelId\": channel.channelId});\n                widget.onRaid!(channel);\n              } else {\n                FirebaseAnalytics.instance.logEvent(\n                    name: \"channel_select\",\n                    parameters: {\"channelId\": channel.channelId});\n                widget.onChannelSelect(channel);\n              }\n              Navigator.of(context).pop();\n            },\n            isShowOnlyOnline: _raid && widget.onRaid != null,\n          ))\n        ],\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/stream_preview.dart",
    "content": "import 'dart:async';\nimport 'dart:convert';\nimport 'dart:io';\n\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/stream_preview.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\nimport 'package:webview_flutter_android/webview_flutter_android.dart';\nimport 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';\n\nclass StreamPreview extends StatefulWidget {\n  const StreamPreview({super.key, required this.channel});\n\n  final Channel channel;\n\n  @override\n  State<StreamPreview> createState() => _StreamPreviewState();\n}\n\nextension Embed on Channel {\n  Uri get embedUri {\n    return Uri.parse(\n        'https://chat.rtirl.com/embed?provider=$provider&channelId=$channelId');\n  }\n}\n\nclass _StreamPreviewState extends State<StreamPreview> {\n  late WebViewController _controller;\n  late Uri url;\n\n  var _isOverlayActive = false;\n  Timer? _overlayTimer;\n  String? _playerState;\n  Timer? _promptTimer;\n\n  @override\n  void initState() {\n    super.initState();\n\n    final model = Provider.of<StreamPreviewModel>(context, listen: false);\n    if (model.showBatteryPrompt) {\n      _promptTimer = Timer(const Duration(minutes: 5), () {\n        ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n          duration: const Duration(minutes: 1),\n          content: Text(AppLocalizations.of(context)!.streamPreviewMessage),\n          action: SnackBarAction(\n            label: AppLocalizations.of(context)!.okay,\n            onPressed: () {\n              model.showBatteryPrompt = false;\n              _promptTimer = null;\n            },\n          ),\n        ));\n      });\n    }\n\n    url = widget.channel.embedUri;\n\n    if (WebViewPlatform.instance is WebKitWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          WebKitWebViewControllerCreationParams(\n        allowsInlineMediaPlayback: true,\n        mediaTypesRequiringUserAction: const {},\n      ));\n    } else if (WebViewPlatform.instance is AndroidWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          AndroidWebViewControllerCreationParams());\n    } else {\n      throw UnsupportedError(\"Unsupported platform\");\n    }\n\n    _controller\n      ..setJavaScriptMode(JavaScriptMode.unrestricted)\n      ..enableZoom(false)\n      ..loadRequest(url)\n      ..addJavaScriptChannel(\"Flutter\", onMessageReceived: (message) {\n        try {\n          final data = jsonDecode(message.message);\n          if (data is Map && data.containsKey('params')) {\n            final params = data['params'];\n            if (params is Map && mounted) {\n              setState(() => _playerState = params[\"playback\"]);\n            }\n          }\n        } catch (e, st) {\n          FirebaseCrashlytics.instance.recordError(e, st);\n        }\n      })\n      ..setNavigationDelegate(NavigationDelegate(\n        onPageFinished: (url) async {\n          await _controller.runJavaScript(\n              await rootBundle.loadString('assets/twitch-tunnel.js'));\n          // wait a second for twitch to catch up.\n          await Future.delayed(const Duration(seconds: 1));\n          if (Platform.isIOS) {\n            await _controller.runJavaScript(\n                \"window.action(window.Actions.SetMuted, ${model.volume == 0})\");\n          } else {\n            await _controller\n                .runJavaScript(\"window.action(window.Actions.SetMuted, false)\");\n            await _controller.runJavaScript(\n                \"window.action(window.Actions.SetVolume, ${model.volume / 100})\");\n            if (model.isHighDefinition) {\n              await _controller.runJavaScript(\n                  \"window.action(window.Actions.SetQuality, 'auto')\");\n            } else {\n              await _controller.runJavaScript(\n                  \"window.action(window.Actions.SetQuality, '160p')\");\n            }\n          }\n        },\n      ));\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n\n    _promptTimer?.cancel();\n\n    // on iOS, the webview is not disposed when the widget is disposed.\n    // this causes audio to keep playing even when the widget is closed.\n    // therefore, we load a blank page to silence the audio.\n    if (Platform.isIOS) {\n      _controller.loadHtmlString(\" \");\n    }\n  }\n\n  @override\n  void didUpdateWidget(StreamPreview oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    final newUrl = widget.channel.embedUri;\n    if (url != newUrl) {\n      _controller.loadRequest(newUrl);\n      url = newUrl;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(children: [\n      WebViewWidget(controller: _controller),\n      if (_playerState == null || _playerState == \"Idle\")\n        Positioned.fill(\n          child: IgnorePointer(\n            child: Container(\n              color: Colors.black.withOpacity(0.8),\n              child: Center(\n                child: Text(\n                  AppLocalizations.of(context)!.streamPreviewLoading,\n                  style: const TextStyle(color: Colors.white),\n                ),\n              ),\n            ),\n          ),\n        )\n      else if (_playerState == \"Playing\")\n        Positioned.fill(\n          child: GestureDetector(\n            onTap: () {\n              _overlayTimer?.cancel();\n              _overlayTimer = Timer(const Duration(seconds: 3), () {\n                _overlayTimer = null;\n                if (!mounted) return;\n                setState(() {\n                  _isOverlayActive = false;\n                });\n              });\n              setState(() {\n                _isOverlayActive = true;\n              });\n            },\n            child: AnimatedOpacity(\n              duration: const Duration(milliseconds: 100),\n              opacity: _isOverlayActive ? 1.0 : 0.0,\n              child: Container(\n                color: Colors.black.withOpacity(0.4),\n                child: Padding(\n                  padding: const EdgeInsets.all(8),\n                  child: Consumer<StreamPreviewModel>(\n                    builder: (context, model, child) {\n                      return Row(\n                        crossAxisAlignment: CrossAxisAlignment.end,\n                        mainAxisAlignment: MainAxisAlignment.end,\n                        children: [\n                          IconButton(\n                              onPressed: !_isOverlayActive\n                                  ? null\n                                  : () async {\n                                      if (Platform.isIOS) {\n                                        // SetVolume doesn't seem to work on ios so we use SetMuted instead and toggle between 0 and 100.\n                                        model.volume =\n                                            model.volume == 0 ? 100 : 0;\n                                        await _controller.runJavaScript(\n                                            \"window.action(window.Actions.SetMuted, ${model.volume == 0})\");\n                                        return;\n                                      }\n                                      if (model.volume == 0) {\n                                        model.volume = 100;\n                                      } else if (model.volume == 100) {\n                                        model.volume = 33;\n                                      } else {\n                                        model.volume = 0;\n                                      }\n                                      await _controller.runJavaScript(\n                                          \"window.action(window.Actions.SetMuted, false)\");\n                                      await _controller.runJavaScript(\n                                          \"window.action(window.Actions.SetVolume, ${model.volume / 100})\");\n                                    },\n                              color: Colors.white,\n                              icon: Icon(\n                                model.volume == 0\n                                    ? Icons.volume_mute\n                                    : model.volume == 100\n                                        ? Icons.volume_up\n                                        : Icons.volume_down,\n                              )),\n                          // SetQuality doesn't seem to work on ios so we don't show the button.\n                          if (!Platform.isIOS)\n                            IconButton(\n                                onPressed: !_isOverlayActive\n                                    ? null\n                                    : () async {\n                                        model.isHighDefinition =\n                                            !model.isHighDefinition;\n                                        if (model.isHighDefinition) {\n                                          await _controller.runJavaScript(\n                                              \"window.action(window.Actions.SetQuality, 'auto')\");\n                                        } else {\n                                          await _controller.runJavaScript(\n                                              \"window.action(window.Actions.SetQuality, '160p')\");\n                                        }\n                                      },\n                                color: Colors.white,\n                                icon: Icon(model.isHighDefinition\n                                    ? Icons.hd\n                                    : Icons.sd)),\n                        ],\n                      );\n                    },\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n    ]);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/pinnable/scroll_view.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:rtchat/components/chat_history/sliver.dart';\nimport 'package:rtchat/components/pinnable/viewport.dart';\n\nenum PinState {\n  notPinnable,\n  pinned,\n  unpinned,\n}\n\n/// This is a total hack of a scrollview. Instead of the standard one-pass\n/// render that [ScrollView] provides, this class instead performs a second\n/// pass to detect [PinnableMessageSliver] slivers and renders them at the\n/// correct location if they're pinned.\nclass PinnableMessageScrollView extends ScrollView {\n  final TickerProvider vsync;\n  final PinState Function(int) isPinnedBuilder;\n  final Widget Function(int) itemBuilder;\n  final ChildIndexGetter findChildIndexCallback;\n  final int count;\n\n  const PinnableMessageScrollView({\n    super.key,\n    super.controller,\n    required this.vsync,\n    required this.isPinnedBuilder,\n    required this.itemBuilder,\n    required this.findChildIndexCallback,\n    required this.count,\n  }) : super(\n          reverse: true,\n        );\n\n  @override\n  List<Widget> buildSlivers(BuildContext context) {\n    final brightness = Theme.of(context).brightness;\n    final pinnedSliverColor =\n        brightness == Brightness.dark ? Colors.grey[900] : Colors.grey[300];\n    final slivers = <Widget>[];\n    // this is an optimization to improve pinning performance by skipping\n    // messages that can't be pinned.\n    for (var start = 0; start < count;) {\n      final nextPinnableIndex =\n          Iterable.generate(count - start, (value) => value + start).firstWhere(\n              (index) => isPinnedBuilder(index) != PinState.notPinnable,\n              orElse: () => count);\n      final intermediateCount = nextPinnableIndex - start;\n      // key from the distance to the end of the list, which is the most stable identifier.\n      if (intermediateCount > 0) {\n        final offset = start;\n        final sliver = SliverList(\n          key: ValueKey(count - nextPinnableIndex + 1),\n          delegate: SliverChildBuilderDelegate(\n            (context, index) => itemBuilder(index + offset),\n            findChildIndexCallback: (key) {\n              final index = findChildIndexCallback(key);\n              return index == null || index == -1 ? null : index - offset;\n            },\n            childCount: intermediateCount,\n            semanticIndexOffset: offset,\n          ),\n        );\n        slivers.add(sliver);\n      }\n      if (nextPinnableIndex == count) {\n        break;\n      }\n      final pinned = isPinnedBuilder(nextPinnableIndex);\n      final sliver = PinnableMessageSliver(\n        key: ValueKey(count - nextPinnableIndex),\n        vsync: vsync,\n        pinned: pinned == PinState.pinned,\n        child: AnimatedContainer(\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeOut,\n          color: pinned == PinState.pinned\n              ? pinnedSliverColor\n              : Colors.transparent,\n          child: itemBuilder(nextPinnableIndex),\n        ),\n      );\n      slivers.add(sliver);\n      start = nextPinnableIndex + 1;\n    }\n    return slivers;\n  }\n\n  @override\n  Widget buildViewport(\n    BuildContext context,\n    ViewportOffset offset,\n    AxisDirection axisDirection,\n    List<Widget> slivers,\n  ) {\n    assert(() {\n      switch (axisDirection) {\n        case AxisDirection.up:\n        case AxisDirection.down:\n          return debugCheckHasDirectionality(\n            context,\n            why: 'to determine the cross-axis direction of the scroll view',\n            hint:\n                'Vertical scroll views create Viewport widgets that try to determine their cross axis direction '\n                'from the ambient Directionality.',\n          );\n        case AxisDirection.left:\n        case AxisDirection.right:\n          return true;\n      }\n    }());\n    return PinnableMessageViewport(\n      axisDirection: axisDirection,\n      offset: offset,\n      slivers: slivers,\n      cacheExtent: cacheExtent,\n      center: center,\n      anchor: anchor,\n      clipBehavior: clipBehavior,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/pinnable/viewport.dart",
    "content": "import 'dart:math' as math;\n\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:rtchat/components/chat_history/sliver.dart';\n\nclass PinnableMessageViewport extends Viewport {\n  PinnableMessageViewport({\n    super.key,\n    super.axisDirection,\n    super.crossAxisDirection,\n    super.anchor,\n    required super.offset,\n    super.center,\n    super.cacheExtent,\n    super.cacheExtentStyle,\n    super.clipBehavior,\n    super.slivers,\n  });\n\n  @override\n  RenderPinnableMessageViewport createRenderObject(BuildContext context) {\n    return RenderPinnableMessageViewport(\n      axisDirection: axisDirection,\n      crossAxisDirection: crossAxisDirection ??\n          Viewport.getDefaultCrossAxisDirection(context, axisDirection),\n      anchor: anchor,\n      offset: offset,\n      cacheExtent: cacheExtent,\n      cacheExtentStyle: cacheExtentStyle,\n      clipBehavior: clipBehavior,\n    );\n  }\n\n  @override\n  void updateRenderObject(\n      BuildContext context, RenderPinnableMessageViewport renderObject) {\n    renderObject\n      ..axisDirection = axisDirection\n      ..crossAxisDirection = crossAxisDirection ??\n          Viewport.getDefaultCrossAxisDirection(context, axisDirection)\n      ..anchor = anchor\n      ..offset = offset\n      ..cacheExtent = cacheExtent\n      ..cacheExtentStyle = cacheExtentStyle\n      ..clipBehavior = clipBehavior;\n  }\n}\n\nclass RenderPinnableMessageViewport extends RenderViewport {\n  double cumulativeOffset = 0.0;\n\n  RenderPinnableMessageViewport({\n    super.axisDirection,\n    required super.crossAxisDirection,\n    required super.offset,\n    double anchor = 0.0,\n    super.cacheExtent,\n    super.cacheExtentStyle,\n    super.clipBehavior,\n  });\n\n  @override\n  double layoutChildSequence({\n    required RenderSliver? child,\n    required double scrollOffset,\n    required double overlap,\n    required double layoutOffset,\n    required double remainingPaintExtent,\n    required double mainAxisExtent,\n    required double crossAxisExtent,\n    required GrowthDirection growthDirection,\n    required RenderSliver? Function(RenderSliver child) advance,\n    required double remainingCacheExtent,\n    required double cacheOrigin,\n  }) {\n    cumulativeOffset = 0.0;\n    final result = super.layoutChildSequence(\n        child: child,\n        scrollOffset: scrollOffset,\n        overlap: overlap,\n        layoutOffset: layoutOffset,\n        remainingPaintExtent: remainingPaintExtent,\n        mainAxisExtent: mainAxisExtent,\n        crossAxisExtent: crossAxisExtent,\n        growthDirection: growthDirection,\n        advance: advance,\n        remainingCacheExtent: remainingCacheExtent,\n        cacheOrigin: cacheOrigin);\n    // progress through the children and pin the children.\n    while (child != null) {\n      if (child is RenderPinnableMessageSliver) {\n        final offset =\n            (child.parentData! as SliverPhysicalParentData).paintOffset;\n\n        (child.parentData! as SliverPhysicalParentData).paintOffset = Offset(\n            offset.dx,\n            math.max(\n                offset.dy, cumulativeOffset - child.geometry!.paintExtent));\n        cumulativeOffset -= child.geometry!.maxPaintExtent * child.pinFraction;\n      }\n      child = advance(child);\n    }\n    return result;\n  }\n\n  @override\n  void updateChildLayoutOffset(RenderSliver child, double layoutOffset,\n      GrowthDirection growthDirection) {\n    super.updateChildLayoutOffset(child, layoutOffset, growthDirection);\n\n    if (child is RenderPinnableMessageSliver) {\n      cumulativeOffset += child.geometry!.maxPaintExtent * child.pinFraction;\n    }\n  }\n\n  @override\n  Iterable<RenderSliver> get childrenInPaintOrder sync* {\n    yield* getMessageSlivers(false);\n    yield* getMessageSlivers(true);\n  }\n\n  @override\n  Iterable<RenderSliver> get childrenInHitTestOrder sync* {\n    yield* getMessageSlivers(true);\n    yield* getMessageSlivers(false);\n  }\n\n  Iterable<RenderSliver> getMessageSlivers(bool pinnable) sync* {\n    if (firstChild == null) {\n      return;\n    }\n    for (var child = firstChild; child != null; child = childAfter(child)) {\n      if ((child is RenderPinnableMessageSliver) == pinnable) {\n        yield child;\n      }\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/pinnable/reverse_refresh_indicator.dart",
    "content": "// This file is forked from refresh_indicator.dart in flutter to revert this PR:\n// https://github.com/flutter/flutter/pull/93779\n\nimport 'dart:async';\nimport 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\n\n// The over-scroll distance that moves the indicator to its maximum\n// displacement, as a percentage of the scrollable's container extent.\nconst double _kDragContainerExtentPercentage = 0.25;\n\n// How much the scroll's drag gesture can overshoot the RefreshIndicator's\n// displacement; max displacement = _kDragSizeFactorLimit * displacement.\nconst double _kDragSizeFactorLimit = 1.5;\n\n// When the scroll ends, the duration of the refresh indicator's animation\n// to the RefreshIndicator's displacement.\nconst Duration _kIndicatorSnapDuration = Duration(milliseconds: 150);\n\n// The duration of the ScaleTransition that starts when the refresh action\n// has completed.\nconst Duration _kIndicatorScaleDuration = Duration(milliseconds: 200);\n\n/// The signature for a function that's called when the user has dragged a\n/// [ReverseRefreshIndicator] far enough to demonstrate that they want the app to\n/// refresh. The returned [Future] must complete when the refresh operation is\n/// finished.\n///\n/// Used by [ReverseRefreshIndicator.onRefresh].\ntypedef RefreshCallback = Future<void> Function();\n\n// The state machine moves through these modes only when the scrollable\n// identified by scrollableKey has been scrolled to its min or max limit.\nenum _RefreshIndicatorMode {\n  drag, // Pointer is down.\n  armed, // Dragged far enough that an up event will run the onRefresh callback.\n  snap, // Animating to the indicator's final \"displacement\".\n  refresh, // Running the refresh callback.\n  done, // Animating the indicator's fade-out after refreshing.\n  canceled, // Animating the indicator's fade-out after not arming.\n}\n\n/// Used to configure how [ReverseRefreshIndicator] can be triggered.\nenum RefreshIndicatorTriggerMode {\n  /// The indicator can be triggered regardless of the scroll position\n  /// of the [Scrollable] when the drag starts.\n  anywhere,\n\n  /// The indicator can only be triggered if the [Scrollable] is at the edge\n  /// when the drag starts.\n  onEdge,\n}\n\n/// A widget that supports the Material \"swipe to refresh\" idiom.\n///\n/// {@youtube 560 315 https://www.youtube.com/watch?v=ORApMlzwMdM}\n///\n/// When the child's [Scrollable] descendant overscrolls, an animated circular\n/// progress indicator is faded into view. When the scroll ends, if the\n/// indicator has been dragged far enough for it to become completely opaque,\n/// the [onRefresh] callback is called. The callback is expected to update the\n/// scrollable's contents and then complete the [Future] it returns. The refresh\n/// indicator disappears after the callback's [Future] has completed.\n///\n/// The trigger mode is configured by [ReverseRefreshIndicator.triggerMode].\n///\n/// {@tool dartpad}\n/// This example shows how [ReverseRefreshIndicator] can be triggered in different ways.\n///\n/// ** See code in examples/api/lib/material/refresh_indicator/refresh_indicator.0.dart **\n/// {@end-tool}\n///\n/// ## Troubleshooting\n///\n/// ### Refresh indicator does not show up\n///\n/// The [ReverseRefreshIndicator] will appear if its scrollable descendant can be\n/// overscrolled, i.e. if the scrollable's content is bigger than its viewport.\n/// To ensure that the [ReverseRefreshIndicator] will always appear, even if the\n/// scrollable's content fits within its viewport, set the scrollable's\n/// [Scrollable.physics] property to [AlwaysScrollableScrollPhysics]:\n///\n/// ```dart\n/// ListView(\n///   physics: const AlwaysScrollableScrollPhysics(),\n///   children: ...\n/// )\n/// ```\n///\n/// A [ReverseRefreshIndicator] can only be used with a vertical scroll view.\n///\n/// See also:\n///\n///  * <https://material.io/design/platform-guidance/android-swipe-to-refresh.html>\n///  * [ReverseRefreshIndicatorState], can be used to programmatically show the refresh indicator.\n///  * [RefreshProgressIndicator], widget used by [ReverseRefreshIndicator] to show\n///    the inner circular progress spinner during refreshes.\n///  * [CupertinoSliverRefreshControl], an iOS equivalent of the pull-to-refresh pattern.\n///    Must be used as a sliver inside a [CustomScrollView] instead of wrapping\n///    around a [ScrollView] because it's a part of the scrollable instead of\n///    being overlaid on top of it.\nclass ReverseRefreshIndicator extends StatefulWidget {\n  /// Creates a refresh indicator.\n  ///\n  /// The [onRefresh], [child], and [notificationPredicate] arguments must be\n  /// non-null. The default\n  /// [displacement] is 40.0 logical pixels.\n  ///\n  /// The [semanticsLabel] is used to specify an accessibility label for this widget.\n  /// If it is null, it will be defaulted to [MaterialLocalizations.refreshIndicatorSemanticLabel].\n  /// An empty string may be passed to avoid having anything read by screen reading software.\n  /// The [semanticsValue] may be used to specify progress on the widget.\n  const ReverseRefreshIndicator({\n    super.key,\n    required this.child,\n    this.displacement = 40.0,\n    this.edgeOffset = 0.0,\n    required this.onRefresh,\n    this.color,\n    this.backgroundColor,\n    this.notificationPredicate = defaultScrollNotificationPredicate,\n    this.semanticsLabel,\n    this.semanticsValue,\n    this.strokeWidth = RefreshProgressIndicator.defaultStrokeWidth,\n    this.triggerMode = RefreshIndicatorTriggerMode.onEdge,\n  });\n\n  /// The widget below this widget in the tree.\n  ///\n  /// The refresh indicator will be stacked on top of this child. The indicator\n  /// will appear when child's Scrollable descendant is over-scrolled.\n  ///\n  /// Typically a [ListView] or [CustomScrollView].\n  final Widget child;\n\n  /// The distance from the child's top or bottom [edgeOffset] where\n  /// the refresh indicator will settle. During the drag that exposes the refresh\n  /// indicator, its actual displacement may significantly exceed this value.\n  ///\n  /// In most cases, [displacement] distance starts counting from the parent's\n  /// edges. However, if [edgeOffset] is larger than zero then the [displacement]\n  /// value is calculated from that offset instead of the parent's edge.\n  final double displacement;\n\n  /// The offset where [RefreshProgressIndicator] starts to appear on drag start.\n  ///\n  /// Depending whether the indicator is showing on the top or bottom, the value\n  /// of this variable controls how far from the parent's edge the progress\n  /// indicator starts to appear. This may come in handy when, for example, the\n  /// UI contains a top [Widget] which covers the parent's edge where the progress\n  /// indicator would otherwise appear.\n  ///\n  /// By default, the edge offset is set to 0.\n  ///\n  /// See also:\n  ///\n  ///  * [displacement], can be used to change the distance from the edge that\n  ///    the indicator settles.\n  final double edgeOffset;\n\n  /// A function that's called when the user has dragged the refresh indicator\n  /// far enough to demonstrate that they want the app to refresh. The returned\n  /// [Future] must complete when the refresh operation is finished.\n  final RefreshCallback onRefresh;\n\n  /// The progress indicator's foreground color. The current theme's\n  /// [ColorScheme.primary] by default.\n  final Color? color;\n\n  /// The progress indicator's background color. The current theme's\n  /// [ThemeData.canvasColor] by default.\n  final Color? backgroundColor;\n\n  /// A check that specifies whether a [ScrollNotification] should be\n  /// handled by this widget.\n  ///\n  /// By default, checks whether `notification.depth == 0`. Set it to something\n  /// else for more complicated layouts.\n  final ScrollNotificationPredicate notificationPredicate;\n\n  /// {@macro flutter.progress_indicator.ProgressIndicator.semanticsLabel}\n  ///\n  /// This will be defaulted to [MaterialLocalizations.refreshIndicatorSemanticLabel]\n  /// if it is null.\n  final String? semanticsLabel;\n\n  /// {@macro flutter.progress_indicator.ProgressIndicator.semanticsValue}\n  final String? semanticsValue;\n\n  /// Defines `strokeWidth` for `RefreshIndicator`.\n  ///\n  /// By default, the value of `strokeWidth` is 2.0 pixels.\n  final double strokeWidth;\n\n  /// Defines how this [ReverseRefreshIndicator] can be triggered when users overscroll.\n  ///\n  /// The [ReverseRefreshIndicator] can be pulled out in two cases,\n  /// 1, Keep dragging if the scrollable widget at the edge with zero scroll position\n  ///    when the drag starts.\n  /// 2, Keep dragging after overscroll occurs if the scrollable widget has\n  ///    a non-zero scroll position when the drag starts.\n  ///\n  /// If this is [RefreshIndicatorTriggerMode.anywhere], both of the cases above can be triggered.\n  ///\n  /// If this is [RefreshIndicatorTriggerMode.onEdge], only case 1 can be triggered.\n  ///\n  /// Defaults to [RefreshIndicatorTriggerMode.onEdge].\n  final RefreshIndicatorTriggerMode triggerMode;\n\n  @override\n  ReverseRefreshIndicatorState createState() => ReverseRefreshIndicatorState();\n}\n\n/// Contains the state for a [ReverseRefreshIndicator]. This class can be used to\n/// programmatically show the refresh indicator, see the [show] method.\nclass ReverseRefreshIndicatorState extends State<ReverseRefreshIndicator>\n    with TickerProviderStateMixin<ReverseRefreshIndicator> {\n  late AnimationController _positionController;\n  late AnimationController _scaleController;\n  late Animation<double> _positionFactor;\n  late Animation<double> _scaleFactor;\n  late Animation<double> _value;\n  late Animation<Color?> _valueColor;\n\n  _RefreshIndicatorMode? _mode;\n  late Future<void> _pendingRefreshFuture;\n  bool? _isIndicatorAtTop;\n  double? _dragOffset;\n\n  static final Animatable<double> _threeQuarterTween =\n      Tween<double>(begin: 0.0, end: 0.75);\n  static final Animatable<double> _kDragSizeFactorLimitTween =\n      Tween<double>(begin: 0.0, end: _kDragSizeFactorLimit);\n  static final Animatable<double> _oneToZeroTween =\n      Tween<double>(begin: 1.0, end: 0.0);\n\n  @override\n  void initState() {\n    super.initState();\n    _positionController = AnimationController(vsync: this);\n    _positionFactor = _positionController.drive(_kDragSizeFactorLimitTween);\n    _value = _positionController.drive(\n        _threeQuarterTween); // The \"value\" of the circular progress indicator during a drag.\n\n    _scaleController = AnimationController(vsync: this);\n    _scaleFactor = _scaleController.drive(_oneToZeroTween);\n  }\n\n  @override\n  void didChangeDependencies() {\n    final ThemeData theme = Theme.of(context);\n    _valueColor = _positionController.drive(\n      ColorTween(\n        begin: (widget.color ?? theme.colorScheme.primary).withOpacity(0.0),\n        end: (widget.color ?? theme.colorScheme.primary).withOpacity(1.0),\n      ).chain(CurveTween(\n        curve: const Interval(0.0, 1.0 / _kDragSizeFactorLimit),\n      )),\n    );\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant ReverseRefreshIndicator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.color != widget.color) {\n      final ThemeData theme = Theme.of(context);\n      _valueColor = _positionController.drive(\n        ColorTween(\n          begin: (widget.color ?? theme.colorScheme.primary).withOpacity(0.0),\n          end: (widget.color ?? theme.colorScheme.primary).withOpacity(1.0),\n        ).chain(CurveTween(\n          curve: const Interval(0.0, 1.0 / _kDragSizeFactorLimit),\n        )),\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    _positionController.dispose();\n    _scaleController.dispose();\n    super.dispose();\n  }\n\n  bool _shouldStart(ScrollNotification notification) {\n    // If the notification.dragDetails is null, this scroll is not triggered by\n    // user dragging. It may be a result of ScrollController.jumpTo or ballistic scroll.\n    // In this case, we don't want to trigger the refresh indicator.\n    return ((notification is ScrollStartNotification &&\n                notification.dragDetails != null) ||\n            (notification is ScrollUpdateNotification &&\n                notification.dragDetails != null &&\n                widget.triggerMode == RefreshIndicatorTriggerMode.anywhere)) &&\n        notification.metrics.extentBefore == 0.0 &&\n        _mode == null &&\n        _start(notification.metrics.axisDirection);\n  }\n\n  bool _handleScrollNotification(ScrollNotification notification) {\n    if (!widget.notificationPredicate(notification)) return false;\n    if (_shouldStart(notification)) {\n      setState(() {\n        _mode = _RefreshIndicatorMode.drag;\n      });\n      return false;\n    }\n    bool? indicatorAtTopNow;\n    switch (notification.metrics.axisDirection) {\n      case AxisDirection.down:\n        indicatorAtTopNow = true;\n        break;\n      case AxisDirection.up:\n        indicatorAtTopNow = false;\n        break;\n      case AxisDirection.left:\n      case AxisDirection.right:\n        indicatorAtTopNow = null;\n        break;\n    }\n    if (indicatorAtTopNow != _isIndicatorAtTop) {\n      if (_mode == _RefreshIndicatorMode.drag ||\n          _mode == _RefreshIndicatorMode.armed) {\n        _dismiss(_RefreshIndicatorMode.canceled);\n      }\n    } else if (notification is ScrollUpdateNotification) {\n      if (_mode == _RefreshIndicatorMode.drag ||\n          _mode == _RefreshIndicatorMode.armed) {\n        if (notification.metrics.extentBefore > 0.0) {\n          _dismiss(_RefreshIndicatorMode.canceled);\n        } else {\n          _dragOffset = _dragOffset! - notification.scrollDelta!;\n          _checkDragOffset(notification.metrics.viewportDimension);\n        }\n      }\n      if (_mode == _RefreshIndicatorMode.armed &&\n          notification.dragDetails == null) {\n        // On iOS start the refresh when the Scrollable bounces back from the\n        // overscroll (ScrollNotification indicating this don't have dragDetails\n        // because the scroll activity is not directly triggered by a drag).\n        _show();\n      }\n    } else if (notification is OverscrollNotification) {\n      if (_mode == _RefreshIndicatorMode.drag ||\n          _mode == _RefreshIndicatorMode.armed) {\n        _dragOffset = _dragOffset! - notification.overscroll;\n        _checkDragOffset(notification.metrics.viewportDimension);\n      }\n    } else if (notification is ScrollEndNotification) {\n      switch (_mode) {\n        case _RefreshIndicatorMode.armed:\n          _show();\n          break;\n        case _RefreshIndicatorMode.drag:\n          _dismiss(_RefreshIndicatorMode.canceled);\n          break;\n        case _RefreshIndicatorMode.canceled:\n        case _RefreshIndicatorMode.done:\n        case _RefreshIndicatorMode.refresh:\n        case _RefreshIndicatorMode.snap:\n        case null:\n          // do nothing\n          break;\n      }\n    }\n    return false;\n  }\n\n  bool _handleGlowNotification(OverscrollIndicatorNotification notification) {\n    if (notification.depth != 0 || !notification.leading) return false;\n    if (_mode == _RefreshIndicatorMode.drag) {\n      notification.disallowIndicator();\n      return true;\n    }\n    return false;\n  }\n\n  bool _start(AxisDirection direction) {\n    assert(_mode == null);\n    assert(_isIndicatorAtTop == null);\n    assert(_dragOffset == null);\n    switch (direction) {\n      case AxisDirection.down:\n        _isIndicatorAtTop = true;\n        break;\n      case AxisDirection.up:\n        _isIndicatorAtTop = false;\n        break;\n      case AxisDirection.left:\n      case AxisDirection.right:\n        _isIndicatorAtTop = null;\n        // we do not support horizontal scroll views.\n        return false;\n    }\n    _dragOffset = 0.0;\n    _scaleController.value = 0.0;\n    _positionController.value = 0.0;\n    return true;\n  }\n\n  void _checkDragOffset(double containerExtent) {\n    assert(_mode == _RefreshIndicatorMode.drag ||\n        _mode == _RefreshIndicatorMode.armed);\n    double newValue =\n        _dragOffset! / (containerExtent * _kDragContainerExtentPercentage);\n    if (_mode == _RefreshIndicatorMode.armed) {\n      newValue = math.max(newValue, 1.0 / _kDragSizeFactorLimit);\n    }\n    _positionController.value =\n        newValue.clamp(0.0, 1.0); // this triggers various rebuilds\n    if (_mode == _RefreshIndicatorMode.drag &&\n        _valueColor.value!.alpha == 0xFF) {\n      _mode = _RefreshIndicatorMode.armed;\n    }\n  }\n\n  // Stop showing the refresh indicator.\n  Future<void> _dismiss(_RefreshIndicatorMode newMode) async {\n    await Future<void>.value();\n    // This can only be called from _show() when refreshing and\n    // _handleScrollNotification in response to a ScrollEndNotification or\n    // direction change.\n    assert(newMode == _RefreshIndicatorMode.canceled ||\n        newMode == _RefreshIndicatorMode.done);\n    setState(() {\n      _mode = newMode;\n    });\n    switch (_mode!) {\n      case _RefreshIndicatorMode.done:\n        await _scaleController.animateTo(1.0,\n            duration: _kIndicatorScaleDuration);\n        break;\n      case _RefreshIndicatorMode.canceled:\n        await _positionController.animateTo(0.0,\n            duration: _kIndicatorScaleDuration);\n        break;\n      case _RefreshIndicatorMode.armed:\n      case _RefreshIndicatorMode.drag:\n      case _RefreshIndicatorMode.refresh:\n      case _RefreshIndicatorMode.snap:\n        assert(false);\n    }\n    if (mounted && _mode == newMode) {\n      _dragOffset = null;\n      _isIndicatorAtTop = null;\n      setState(() {\n        _mode = null;\n      });\n    }\n  }\n\n  void _show() {\n    assert(_mode != _RefreshIndicatorMode.refresh);\n    assert(_mode != _RefreshIndicatorMode.snap);\n    final Completer<void> completer = Completer<void>();\n    _pendingRefreshFuture = completer.future;\n    _mode = _RefreshIndicatorMode.snap;\n    _positionController\n        .animateTo(1.0 / _kDragSizeFactorLimit,\n            duration: _kIndicatorSnapDuration)\n        .then<void>((void value) {\n      if (mounted && _mode == _RefreshIndicatorMode.snap) {\n        setState(() {\n          // Show the indeterminate progress indicator.\n          _mode = _RefreshIndicatorMode.refresh;\n        });\n\n        final Future<void> refreshResult = widget.onRefresh();\n        refreshResult.whenComplete(() {\n          if (mounted && _mode == _RefreshIndicatorMode.refresh) {\n            completer.complete();\n            _dismiss(_RefreshIndicatorMode.done);\n          }\n        });\n      }\n    });\n  }\n\n  /// Show the refresh indicator and run the refresh callback as if it had\n  /// been started interactively. If this method is called while the refresh\n  /// callback is running, it quietly does nothing.\n  ///\n  /// Creating the [ReverseRefreshIndicator] with a [GlobalKey<RefreshIndicatorState>]\n  /// makes it possible to refer to the [ReverseRefreshIndicatorState].\n  ///\n  /// The future returned from this method completes when the\n  /// [ReverseRefreshIndicator.onRefresh] callback's future completes.\n  ///\n  /// If you await the future returned by this function from a [State], you\n  /// should check that the state is still [mounted] before calling [setState].\n  ///\n  /// When initiated in this manner, the refresh indicator is independent of any\n  /// actual scroll view. It defaults to showing the indicator at the top. To\n  /// show it at the bottom, set `atTop` to false.\n  Future<void> show({bool atTop = true}) {\n    if (_mode != _RefreshIndicatorMode.refresh &&\n        _mode != _RefreshIndicatorMode.snap) {\n      if (_mode == null) _start(atTop ? AxisDirection.down : AxisDirection.up);\n      _show();\n    }\n    return _pendingRefreshFuture;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    assert(debugCheckHasMaterialLocalizations(context));\n    final Widget child = NotificationListener<ScrollNotification>(\n      onNotification: _handleScrollNotification,\n      child: NotificationListener<OverscrollIndicatorNotification>(\n        onNotification: _handleGlowNotification,\n        child: widget.child,\n      ),\n    );\n    assert(() {\n      if (_mode == null) {\n        assert(_dragOffset == null);\n        assert(_isIndicatorAtTop == null);\n      } else {\n        assert(_dragOffset != null);\n        assert(_isIndicatorAtTop != null);\n      }\n      return true;\n    }());\n\n    final bool showIndeterminateIndicator =\n        _mode == _RefreshIndicatorMode.refresh ||\n            _mode == _RefreshIndicatorMode.done;\n\n    return Stack(\n      children: <Widget>[\n        child,\n        if (_mode != null)\n          Positioned(\n            top: _isIndicatorAtTop! ? widget.edgeOffset : null,\n            bottom: !_isIndicatorAtTop! ? widget.edgeOffset : null,\n            left: 0.0,\n            right: 0.0,\n            child: SizeTransition(\n              axisAlignment: _isIndicatorAtTop! ? 1.0 : -1.0,\n              sizeFactor: _positionFactor, // this is what brings it down\n              child: Container(\n                padding: _isIndicatorAtTop!\n                    ? EdgeInsets.only(top: widget.displacement)\n                    : EdgeInsets.only(bottom: widget.displacement),\n                alignment: _isIndicatorAtTop!\n                    ? Alignment.topCenter\n                    : Alignment.bottomCenter,\n                child: ScaleTransition(\n                  scale: _scaleFactor,\n                  child: AnimatedBuilder(\n                    animation: _positionController,\n                    builder: (BuildContext context, Widget? child) {\n                      return RefreshProgressIndicator(\n                        semanticsLabel: widget.semanticsLabel ??\n                            MaterialLocalizations.of(context)\n                                .refreshIndicatorSemanticLabel,\n                        semanticsValue: widget.semanticsValue,\n                        value: showIndeterminateIndicator ? null : _value.value,\n                        valueColor: _valueColor,\n                        backgroundColor: widget.backgroundColor,\n                        strokeWidth: widget.strokeWidth,\n                      );\n                    },\n                  ),\n                ),\n              ),\n            ),\n          ),\n      ],\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/image/cross_fade_image.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\n\nclass CrossFadeImage extends StatelessWidget {\n  const CrossFadeImage({\n    super.key,\n    this.placeholder,\n    this.placeholderErrorBuilder,\n    required this.image,\n    this.crossfadeDuration = const Duration(milliseconds: 700),\n    this.crossfadeCurve = Curves.easeInOut,\n    this.width,\n    this.height,\n    this.fit,\n    this.alignment = Alignment.topCenter,\n    this.repeat = ImageRepeat.noRepeat,\n    this.matchTextDirection = false,\n  });\n\n  final ImageProvider? placeholder;\n\n  final ImageErrorWidgetBuilder? placeholderErrorBuilder;\n\n  final ImageProvider image;\n\n  final Duration crossfadeDuration;\n\n  final Curve crossfadeCurve;\n\n  final double? width;\n\n  final double? height;\n\n  final BoxFit? fit;\n\n  final AlignmentGeometry alignment;\n\n  final ImageRepeat repeat;\n\n  final bool matchTextDirection;\n\n  Image _image({\n    required ImageProvider image,\n    ImageErrorWidgetBuilder? errorBuilder,\n    ImageFrameBuilder? frameBuilder,\n  }) {\n    return Image(\n      image: image,\n      errorBuilder: errorBuilder,\n      frameBuilder: frameBuilder,\n      width: width,\n      height: height,\n      fit: fit,\n      alignment: alignment,\n      repeat: repeat,\n      matchTextDirection: matchTextDirection,\n      gaplessPlayback: true,\n      excludeFromSemantics: true,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (placeholder == null) {\n      return FadeInImage(\n        placeholder: MemoryImage(kTransparentImage),\n        image: image,\n        width: width,\n        height: height,\n        fit: fit,\n        alignment: alignment,\n        repeat: repeat,\n        matchTextDirection: matchTextDirection,\n        excludeFromSemantics: true,\n      );\n    }\n    Widget result = _image(\n      image: image,\n      errorBuilder: (context, error, stackTrace) {\n        return _image(\n          image: placeholder!,\n          errorBuilder: placeholderErrorBuilder,\n        );\n      },\n      frameBuilder: (context, child, frame, wasSynchronouslyLoaded) {\n        if (wasSynchronouslyLoaded) return child;\n        return AnimatedCrossFade(\n          firstChild: _image(\n              image: placeholder!, errorBuilder: placeholderErrorBuilder),\n          secondChild: child,\n          crossFadeState: frame == null\n              ? CrossFadeState.showFirst\n              : CrossFadeState.showSecond,\n          duration: crossfadeDuration,\n          firstCurve: const Threshold(1.0),\n          secondCurve: crossfadeCurve,\n        );\n      },\n    );\n    return result;\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/image/placeholder_image.dart",
    "content": "import 'dart:async';\nimport 'dart:io';\nimport 'dart:ui';\n\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:path_provider/path_provider.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\n\nclass PlaceholderImage extends ImageProvider<PlaceholderImage> {\n  final Uri uri;\n  final double scale;\n\n  int get hash => uri.hashCode;\n\n  const PlaceholderImage(this.uri, {this.scale = 1.0});\n\n  @override\n  ImageStreamCompleter loadImage(\n      PlaceholderImage key, ImageDecoderCallback decode) {\n    final chunkEvents = StreamController<ImageChunkEvent>();\n    return MultiFrameImageStreamCompleter(\n      chunkEvents: chunkEvents.stream,\n      codec: _loadAsync(key, chunkEvents, decode),\n      scale: scale,\n      debugLabel: key.uri.toString(),\n      informationCollector: _imageStreamInformationCollector(key),\n    );\n  }\n\n  InformationCollector? _imageStreamInformationCollector(PlaceholderImage key) {\n    InformationCollector? collector;\n    assert(() {\n      collector = () => <DiagnosticsNode>[\n            DiagnosticsProperty<ImageProvider>('Image provider', this),\n            DiagnosticsProperty<PlaceholderImage>('Image key', key),\n          ];\n      return true;\n    }());\n    return collector;\n  }\n\n  static Future<Codec> _loadAsync(\n      PlaceholderImage key,\n      StreamController<ImageChunkEvent> chunkEvents,\n      ImageDecoderCallback decode) async {\n    final temp = await getTemporaryDirectory();\n    final cacheFile = File('${temp.path}/${key.hash}');\n    final etagFile = File('${temp.path}/${key.hash}.etag');\n\n    Codec? decodedCache;\n\n    if (await cacheFile.exists() && await etagFile.exists()) {\n      try {\n        final bytes = await cacheFile.readAsBytes();\n        if (bytes.isNotEmpty) {\n          decodedCache =\n              await decode(await ImmutableBuffer.fromUint8List(bytes));\n          chunkEvents.add(ImageChunkEvent(\n            cumulativeBytesLoaded: bytes.lengthInBytes,\n            expectedTotalBytes: bytes.lengthInBytes,\n          ));\n          chunkEvents.close();\n          return decodedCache;\n        }\n      } catch (e) {\n        FirebaseCrashlytics.instance.recordError(e, StackTrace.current);\n      }\n    }\n    return await decode(await ImmutableBuffer.fromUint8List(kTransparentImage));\n  }\n\n  @override\n  Future<PlaceholderImage> obtainKey(ImageConfiguration configuration) {\n    return SynchronousFuture(this);\n  }\n\n  @override\n  bool operator ==(Object other) {\n    if (other.runtimeType != runtimeType) return false;\n    return other is PlaceholderImage &&\n        other.uri == uri &&\n        other.scale == scale;\n  }\n\n  @override\n  int get hashCode => Object.hash(uri, scale);\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'PlaceholderImage')}(\"$uri\", scale: $scale)';\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/image/resilient_network_image.dart",
    "content": "import 'dart:async';\nimport 'dart:io';\nimport 'dart:ui';\n\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:rtchat/components/image/placeholder_image.dart';\n\n// https://github.com/brianegan/transparent_image/blob/master/lib/transparent_image.dart\nfinal kTransparentImage = Uint8List.fromList(<int>[\n  0x89,\n  0x50,\n  0x4E,\n  0x47,\n  0x0D,\n  0x0A,\n  0x1A,\n  0x0A,\n  0x00,\n  0x00,\n  0x00,\n  0x0D,\n  0x49,\n  0x48,\n  0x44,\n  0x52,\n  0x00,\n  0x00,\n  0x00,\n  0x01,\n  0x00,\n  0x00,\n  0x00,\n  0x01,\n  0x08,\n  0x06,\n  0x00,\n  0x00,\n  0x00,\n  0x1F,\n  0x15,\n  0xC4,\n  0x89,\n  0x00,\n  0x00,\n  0x00,\n  0x0A,\n  0x49,\n  0x44,\n  0x41,\n  0x54,\n  0x78,\n  0x9C,\n  0x63,\n  0x00,\n  0x01,\n  0x00,\n  0x00,\n  0x05,\n  0x00,\n  0x01,\n  0x0D,\n  0x0A,\n  0x2D,\n  0xB4,\n  0x00,\n  0x00,\n  0x00,\n  0x00,\n  0x49,\n  0x45,\n  0x4E,\n  0x44,\n  0xAE,\n]);\n\nclass ResilientNetworkImage extends ImageProvider<ResilientNetworkImage> {\n  static final HttpClient _sharedHttpClient = HttpClient()\n    ..autoUncompress = false;\n\n  static HttpClient get _httpClient {\n    HttpClient client = _sharedHttpClient;\n    assert(() {\n      if (debugNetworkImageHttpClientProvider != null) {\n        client = debugNetworkImageHttpClientProvider!();\n      }\n      return true;\n    }());\n    return client;\n  }\n\n  static final Map<int, Future<Codec>> _pending = {};\n\n  final Uri uri;\n  final double scale;\n\n  int get hash => uri.hashCode;\n\n  PlaceholderImage get placeholderImage => PlaceholderImage(uri, scale: scale);\n\n  const ResilientNetworkImage(this.uri, {this.scale = 1.0});\n\n  @override\n  ImageStreamCompleter loadImage(\n      ResilientNetworkImage key, ImageDecoderCallback decode) {\n    final chunkEvents = StreamController<ImageChunkEvent>();\n    return MultiFrameImageStreamCompleter(\n      chunkEvents: chunkEvents.stream,\n      codec: _pending[hash] ??= _loadAsync(key, chunkEvents, decode).then((x) {\n        _pending.remove(hash);\n        return x;\n      }),\n      scale: scale,\n      debugLabel: key.uri.toString(),\n      informationCollector: _imageStreamInformationCollector(key),\n    );\n  }\n\n  InformationCollector? _imageStreamInformationCollector(\n      ResilientNetworkImage key) {\n    InformationCollector? collector;\n    assert(() {\n      collector = () => <DiagnosticsNode>[\n            DiagnosticsProperty<ImageProvider>('Image provider', this),\n            DiagnosticsProperty<ResilientNetworkImage>('Image key', key),\n          ];\n      return true;\n    }());\n    return collector;\n  }\n\n  static Future<Codec> _loadAsync(\n      ResilientNetworkImage key,\n      StreamController<ImageChunkEvent> chunkEvents,\n      ImageDecoderCallback decode) async {\n    final temp = await getTemporaryDirectory();\n    final cacheFile = File('${temp.path}/${key.hash}');\n    final etagFile = File('${temp.path}/${key.hash}.etag');\n\n    String? etagValue;\n\n    Codec? decodedCache;\n\n    if (await cacheFile.exists() && await etagFile.exists()) {\n      try {\n        final bytes = await cacheFile.readAsBytes();\n        if (bytes.isNotEmpty) {\n          decodedCache =\n              await decode(await ImmutableBuffer.fromUint8List(bytes));\n          etagValue = await etagFile.readAsString();\n        }\n      } catch (e) {\n        FirebaseCrashlytics.instance.recordError(e, StackTrace.current);\n      }\n    }\n\n    var delay = const Duration(seconds: 1);\n    Object? lastError;\n\n    for (var i = 0; i < 30; i++) {\n      try {\n        final request = await _httpClient.getUrl(key.uri);\n\n        if (etagValue != null && decodedCache != null) {\n          request.headers.add(HttpHeaders.ifNoneMatchHeader, etagValue);\n        }\n\n        final response = await request.close();\n\n        if (response.statusCode != HttpStatus.ok) {\n          await response.drain<List<int>>(<int>[]);\n\n          if (response.statusCode == HttpStatus.notModified &&\n              etagValue != null &&\n              decodedCache != null) {\n            final bytes = await cacheFile.readAsBytes();\n            chunkEvents.add(ImageChunkEvent(\n              cumulativeBytesLoaded: bytes.lengthInBytes,\n              expectedTotalBytes: bytes.lengthInBytes,\n            ));\n            chunkEvents.close();\n            await cacheFile.setLastModified(DateTime.now());\n            return decodedCache;\n          }\n          if (response.statusCode >= 400 && response.statusCode < 500) {\n            throw NetworkImageLoadException(\n                statusCode: response.statusCode, uri: key.uri);\n          } else {\n            // assume this is a retriable error.\n            continue;\n          }\n        }\n\n        final bytes = await consolidateHttpClientResponseBytes(\n          response,\n          onBytesReceived: (int cumulative, int? total) {\n            chunkEvents.add(ImageChunkEvent(\n              cumulativeBytesLoaded: cumulative,\n              expectedTotalBytes: total,\n            ));\n          },\n        );\n\n        if (bytes.lengthInBytes == 0) {\n          throw Exception('ResilientNetworkImage is an empty file: ${key.uri}');\n        }\n\n        final etagHeader = response.headers[HttpHeaders.etagHeader]?.first;\n        if (etagHeader != null) {\n          await cacheFile.writeAsBytes(bytes);\n          await etagFile.writeAsString(etagHeader);\n        }\n\n        chunkEvents.close();\n        return await decode(await ImmutableBuffer.fromUint8List(bytes));\n      } on NetworkImageLoadException {\n        chunkEvents.close();\n        scheduleMicrotask(() {\n          PaintingBinding.instance.imageCache.evict(key);\n        });\n        rethrow;\n      } catch (e) {\n        // retry this error\n        await Future.delayed(delay);\n        delay = Duration(milliseconds: (1.5 * delay.inMilliseconds).toInt());\n        lastError = e;\n      }\n    }\n    chunkEvents.close();\n    if (lastError != null) {\n      throw lastError;\n    }\n    throw Exception('Failed to fetch ResilientNetworkImage');\n  }\n\n  @override\n  Future<ResilientNetworkImage> obtainKey(ImageConfiguration configuration) {\n    return SynchronousFuture(this);\n  }\n\n  @override\n  bool operator ==(Object other) {\n    if (other.runtimeType != runtimeType) return false;\n    return other is ResilientNetworkImage &&\n        other.uri == uri &&\n        other.scale == scale;\n  }\n\n  @override\n  int get hashCode => Object.hash(uri, scale);\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ResilientNetworkImage')}(\"$uri\", scale: $scale)';\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/message.dart",
    "content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/auxiliary/realtimecash_donation.dart';\nimport 'package:rtchat/components/chat_history/auxiliary/streamelements.dart';\nimport 'package:rtchat/components/chat_history/auxiliary/streamlabs.dart';\nimport 'package:rtchat/components/chat_history/chat_cleared_event.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/chat_history/stream_state_event.dart';\nimport 'package:rtchat/components/chat_history/timeout_dialog.dart';\nimport 'package:rtchat/components/chat_history/twitch/channel_point_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/cheer_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/follow_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/host_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/hype_train_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/message.dart';\nimport 'package:rtchat/components/chat_history/twitch/poll_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/prediction_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/raid_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/raiding_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/shoutout_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/subscription_event.dart';\nimport 'package:rtchat/models/adapters/actions.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/layout.dart';\nimport 'package:rtchat/models/messages/auxiliary/realtimecash.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamelements.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamlabs.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/channel_point_redemption_event.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\nimport 'package:rtchat/models/messages/twitch/hype_train_event.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/prediction_event.dart';\nimport 'package:rtchat/models/messages/twitch/raiding_event.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_create_event.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_receive_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_gift_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_message_event.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/urls.dart';\n\nclass ChatHistoryMessage extends StatelessWidget {\n  final MessageModel message;\n  final Channel channel;\n\n  const ChatHistoryMessage(\n      {super.key, required this.message, required this.channel});\n\n  @override\n  Widget build(BuildContext context) {\n    final m = message;\n    if (m is TwitchMessageModel) {\n      return Consumer<LayoutModel>(builder: (context, layoutModel, child) {\n        final announcement = m.annotations.announcement;\n        final child = announcement != null\n            ? DecoratedEventWidget(\n                accentColor: announcement.color,\n                child: TwitchMessageWidget(m),\n              )\n            : Padding(\n                padding: const EdgeInsets.symmetric(horizontal: 16),\n                child: TwitchMessageWidget(m),\n              );\n        if (layoutModel.locked) {\n          return child;\n        }\n        final userModel = Provider.of<UserModel>(context, listen: false);\n        final loginChannelId = userModel.userChannel?.channelId;\n        final viewingChannelId = m.channelId.split(':')[1];\n        final channel = Channel(\"twitch\", viewingChannelId, \"\");\n\n        if (loginChannelId != viewingChannelId) {\n          return child;\n        }\n\n        return Material(\n          child: InkWell(\n              onTap: () => FocusManager.instance.primaryFocus?.unfocus(),\n              onLongPress: () async {\n                FocusManager.instance.primaryFocus?.unfocus();\n                var showTimeoutDialog = await showDialog<bool>(\n                    context: context,\n                    builder: (context) {\n                      return Dialog(\n                        child: ListView(\n                            shrinkWrap: true,\n                            primary: false,\n                            children: [\n                              if (kDebugMode) Text(\"DEBUG: id=${m.messageId}\"),\n                              Consumer<TtsModel>(\n                                  builder: (context, ttsModel, child) {\n                                if (ttsModel.isMuted(m.author)) {\n                                  return ListTile(\n                                      leading: const Icon(\n                                          Icons.volume_up_rounded,\n                                          color: Colors.deepPurpleAccent),\n                                      title: Text(AppLocalizations.of(context)!\n                                          .unmuteUser(m.author.displayName ??\n                                              m.author.login)),\n                                      onTap: () {\n                                        ttsModel.unmute(m.author);\n                                        Navigator.pop(context);\n                                      });\n                                }\n                                return ListTile(\n                                    leading: const Icon(\n                                        Icons.volume_off_rounded,\n                                        color: Colors.redAccent),\n                                    title: Text(AppLocalizations.of(context)!\n                                        .muteUser(m.author.displayName ??\n                                            m.author.login)),\n                                    onTap: () {\n                                      ttsModel.mute(m.author);\n                                      Navigator.pop(context);\n                                    });\n                              }),\n                              ListTile(\n                                  leading: const Icon(Icons.delete,\n                                      color: Colors.redAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .deleteMessage),\n                                  onTap: () {\n                                    ActionsAdapter.instance\n                                        .delete(channel, m.messageId);\n                                    Navigator.pop(context);\n                                  }),\n                              ListTile(\n                                  leading: const Icon(Icons.timer_outlined,\n                                      color: Colors.orangeAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .timeoutUser(m.author.displayName ??\n                                          m.author.login)),\n                                  onTap: () {\n                                    Navigator.pop(context, true);\n                                  }),\n                              ListTile(\n                                  leading: const Icon(\n                                      Icons.dnd_forwardslash_outlined,\n                                      color: Colors.redAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .banUser(m.author.displayName ??\n                                          m.author.login)),\n                                  onTap: () {\n                                    ActionsAdapter.instance\n                                        .ban(channel, m.author.login);\n                                    Navigator.pop(context);\n                                  }),\n                              ListTile(\n                                  leading: const Icon(Icons.circle_outlined,\n                                      color: Colors.greenAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .unbanUser(m.author.displayName ??\n                                          m.author.login)),\n                                  onTap: () {\n                                    ActionsAdapter.instance\n                                        .unban(channel, m.author.login);\n                                    Navigator.pop(context);\n                                  }),\n                              ListTile(\n                                  leading: const Icon(Icons.copy_outlined,\n                                      color: Colors.greenAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .copyMessage),\n                                  onTap: () {\n                                    Clipboard.setData(\n                                        ClipboardData(text: m.message));\n                                    Navigator.pop(context);\n                                  }),\n                              ListTile(\n                                  leading: const Icon(Icons.link_outlined,\n                                      color: Colors.blueAccent),\n                                  title: Text(AppLocalizations.of(context)!\n                                      .viewProfile(m.author.displayName ??\n                                          m.author.login)),\n                                  onTap: () {\n                                    openUrl(Uri.parse(\n                                        \"https://www.twitch.tv/${m.author.displayName}\"));\n                                    Navigator.pop(context);\n                                  }),\n                            ]),\n                      );\n                    });\n                if (showTimeoutDialog == true && context.mounted) {\n                  await showDialog(\n                      context: context,\n                      builder: (context) {\n                        return TimeoutDialog(\n                            title: AppLocalizations.of(context)!.timeoutUser(\n                                m.author.displayName ?? m.author.login),\n                            onPressed: (duration) {\n                              ActionsAdapter.instance.timeout(\n                                  channel,\n                                  m.author.login,\n                                  \"timed out by streamer\",\n                                  duration);\n                              Navigator.pop(context);\n                            });\n                      });\n                }\n              },\n              child: child),\n        );\n      });\n    } else if (m is TwitchRaidEventModel) {\n      return Selector<EventSubConfigurationModel, RaidEventConfig>(\n        selector: (_, model) => model.raidEventConfig,\n        builder: (_, config, __) => config.showEvent\n            ? TwitchRaidEventWidget(m, channel: channel)\n            : Container(),\n      );\n    } else if (m is TwitchSubscriptionEventModel) {\n      return Selector<EventSubConfigurationModel, SubscriptionEventConfig>(\n        selector: (_, model) => model.subscriptionEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent || (config.showIndividualGifts && m.isGift)\n                ? TwitchSubscriptionEventWidget(m)\n                : Container(),\n      );\n    } else if (m is TwitchSubscriptionGiftEventModel) {\n      return Selector<EventSubConfigurationModel, SubscriptionEventConfig>(\n        selector: (_, model) => model.subscriptionEventConfig,\n        builder: (_, config, __) => config.showEvent\n            ? TwitchSubscriptionGiftEventWidget(m)\n            : Container(),\n      );\n    } else if (m is TwitchSubscriptionMessageEventModel) {\n      return Selector<EventSubConfigurationModel, SubscriptionEventConfig>(\n        selector: (_, model) => model.subscriptionEventConfig,\n        builder: (_, config, __) => config.showEvent\n            ? TwitchSubscriptionMessageEventWidget(m)\n            : Container(),\n      );\n    } else if (m is StreamStateEventModel) {\n      return StreamStateEventWidget(m);\n    } else if (m is TwitchFollowEventModel) {\n      return Selector<EventSubConfigurationModel, FollowEventConfig>(\n        selector: (_, model) => model.followEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchFollowEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchCheerEventModel) {\n      return Selector<EventSubConfigurationModel, CheerEventConfig>(\n        selector: (_, model) => model.cheerEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchCheerEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchPollEventModel) {\n      return Selector<EventSubConfigurationModel, PollEventConfig>(\n        selector: (_, model) => model.pollEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchPollEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchChannelPointRedemptionEventModel) {\n      return Selector<EventSubConfigurationModel,\n          ChannelPointRedemptionEventConfig>(\n        selector: (_, model) => model.channelPointRedemptionEventConfig,\n        builder: (_, config, __) => config.showEvent\n            ? TwitchChannelPointRedemptionEventWidget(m)\n            : Container(),\n      );\n    } else if (m is TwitchHypeTrainEventModel) {\n      return Selector<EventSubConfigurationModel, HypetrainEventConfig>(\n        selector: (_, model) => model.hypetrainEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchHypeTrainEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchPredictionEventModel) {\n      return Selector<EventSubConfigurationModel, PredictionEventConfig>(\n        selector: (_, model) => model.predictionEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchPredictionEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchHostEventModel) {\n      return Selector<EventSubConfigurationModel, HostEventConfig>(\n        selector: (_, model) => model.hostEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchHostEventWidget(m) : Container(),\n      );\n    } else if (m is TwitchRaidingEventModel) {\n      return Selector<EventSubConfigurationModel, RaidingEventConfig>(\n        selector: (_, model) => model.raidingEventConfig,\n        builder: (_, config, __) =>\n            config.showEvent ? TwitchRaidingEventWidget(m) : Container(),\n      );\n    } else if (m is ChatClearedEventModel) {\n      return ChatClearedEventWidget(m);\n    } else if (m is StreamlabsDonationEventModel) {\n      return StreamlabsDonationEventWidget(m);\n    } else if (m is StreamElementsTipEventModel) {\n      return StreamElementsTipEventWidget(m);\n    } else if (m is SimpleRealtimeCashDonationEventModel) {\n      return RealtimeCashDonationEventWidget(m);\n    } else if (m is TwitchShoutoutCreateEventModel) {\n      return TwitchShoutoutCreateEventWidget(m);\n    } else if (m is TwitchShoutoutReceiveEventModel) {\n      return TwitchShoutoutReceiveEventWidget(m);\n    } else {\n      throw AssertionError(\"invalid message type $m\");\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/sliver.dart",
    "content": "import 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nclass PinnableMessageSliver extends SingleChildRenderObjectWidget {\n  final bool pinned;\n  final TickerProvider vsync;\n\n  const PinnableMessageSliver({\n    super.key,\n    required this.vsync,\n    required this.pinned,\n    required Widget super.child,\n  });\n\n  @override\n  RenderPinnableMessageSliver createRenderObject(BuildContext context) {\n    return RenderPinnableMessageSliver(vsync: vsync, pinned: pinned);\n  }\n\n  @override\n  void updateRenderObject(\n      BuildContext context, RenderPinnableMessageSliver renderObject) {\n    renderObject\n      ..vsync = vsync\n      ..pinned = pinned;\n  }\n}\n\nclass RenderPinnableMessageSliver extends RenderSliverToBoxAdapter {\n  late final AnimationController _controller;\n  bool _pinned;\n\n  RenderPinnableMessageSliver(\n      {required TickerProvider vsync, required bool pinned, super.child})\n      : _vsync = vsync,\n        _pinned = pinned {\n    _controller = AnimationController(\n        vsync: vsync,\n        value: pinned ? 1.0 : 0.0,\n        duration: const Duration(milliseconds: 300),\n        reverseDuration: const Duration(milliseconds: 300));\n    CurvedAnimation(parent: _controller, curve: Curves.easeOut)\n        .addListener(markNeedsLayout);\n  }\n\n  TickerProvider get vsync => _vsync;\n  TickerProvider _vsync;\n  set vsync(TickerProvider value) {\n    if (value == _vsync) return;\n    _vsync = value;\n    _controller.resync(vsync);\n  }\n\n  @override\n  void attach(PipelineOwner owner) {\n    super.attach(owner);\n    _animate(_pinned);\n  }\n\n  @override\n  void detach() {\n    _controller.stop();\n    super.detach();\n  }\n\n  double get pinFraction => _controller.value;\n\n  set pinned(bool value) {\n    if (value == _pinned) {\n      return;\n    }\n    _animate(value);\n    _pinned = value;\n  }\n\n  void _animate(bool value) {\n    if (value) {\n      if (!_controller.isCompleted) {\n        _controller.forward(from: 0.0);\n      }\n    } else {\n      if (!_controller.isDismissed) {\n        _controller.reverse(from: 1.0);\n      }\n    }\n  }\n\n  @override\n  void performLayout() {\n    super.performLayout();\n\n    geometry = SliverGeometry(\n      scrollExtent: geometry!.scrollExtent,\n      paintExtent: geometry!.paintExtent,\n      cacheExtent: geometry!.cacheExtent,\n      maxPaintExtent: geometry!.maxPaintExtent,\n      hitTestExtent: geometry!.hitTestExtent,\n      hasVisualOverflow: geometry!.hasVisualOverflow,\n      visible: true,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/auxiliary/streamlabs.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamlabs.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass StreamlabsDonationEventWidget extends StatelessWidget {\n  final StreamlabsDonationEventModel model;\n\n  const StreamlabsDonationEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatar(\n      avatar: const AssetImage(\"assets/streamlabs.png\"),\n      child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            StyledText(\n              text: AppLocalizations.of(context)!\n                  .streamlabsTipEventMessage(model.name, model.formattedAmount),\n              tags: {\n                'b': StyledTextTag(\n                    style: Theme.of(context).textTheme.titleSmall),\n              },\n            ),\n            if (model.message != null && model.message!.isNotEmpty)\n              Text(model.message!,\n                  style: const TextStyle(fontStyle: FontStyle.italic)),\n          ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/auxiliary/streamelements.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/auxiliary/streamelements.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass StreamElementsTipEventWidget extends StatelessWidget {\n  final StreamElementsTipEventModel model;\n\n  const StreamElementsTipEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatar(\n      avatar: const AssetImage(\"assets/streamelements.png\"),\n      child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            StyledText(\n              text: AppLocalizations.of(context)!.streamElementsTipEventMessage(\n                  model.name, model.formattedAmount),\n              tags: {\n                'b': StyledTextTag(\n                    style: Theme.of(context).textTheme.titleSmall),\n              },\n            ),\n            if (model.message != null && model.message!.isNotEmpty)\n              Text(model.message!,\n                  style: const TextStyle(fontStyle: FontStyle.italic)),\n          ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/auxiliary/realtimecash_donation.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/auxiliary/realtimecash.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass RealtimeCashDonationEventWidget extends StatelessWidget {\n  final SimpleRealtimeCashDonationEventModel model;\n\n  const RealtimeCashDonationEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatar(\n      avatar: model.image,\n      child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            StyledText(\n              text: model.donor != null && model.donor!.isNotEmpty\n                  ? AppLocalizations.of(context)!.realtimeCashTipWithDonor(\n                      model.donor!, model.value.toString(), model.currency)\n                  : AppLocalizations.of(context)!.realtimeCashTipAnonymous(\n                      model.value.toString(), model.currency),\n              tags: {\n                'b': StyledTextTag(\n                    style: Theme.of(context).textTheme.titleSmall),\n              },\n            ),\n            if (model.message != null && model.message!.isNotEmpty)\n              Text(model.message!,\n                  style: const TextStyle(fontStyle: FontStyle.italic)),\n          ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/hype_train_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/twitch/hype_train_event.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchHypeTrainEventWidget extends StatelessWidget {\n  final TwitchHypeTrainEventModel model;\n\n  const TwitchHypeTrainEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.icon(\n      icon: Icons.train,\n      child: Builder(builder: (context) {\n        if (model.hasEnded) {\n          return StyledText(\n            text: model.isSuccessful\n                ? AppLocalizations.of(context)!\n                    .hypeTrainEventEndedSuccessful(model.level)\n                : AppLocalizations.of(context)!\n                    .hypeTrainEventEndedUnsuccessful(model.level),\n            tags: {\n              'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n            },\n          );\n        } else {\n          return StyledText(\n            text: AppLocalizations.of(context)!.hypeTrainEventProgress(\n                model.level.toString(),\n                ((model.progress * 100) ~/ model.goal).toString()),\n            tags: {\n              'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n            },\n          );\n        }\n      }),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/channel_point_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/twitch/channel_point_redemption_event.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchChannelPointRedemptionEventWidget extends StatelessWidget {\n  final TwitchChannelPointRedemptionEventModel model;\n\n  const TwitchChannelPointRedemptionEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.icon(\n      icon: model.icon,\n      child: StyledText(\n        text: model.userInput != null\n            ? AppLocalizations.of(context)!.channelPointRedemptionWithUserInput(\n                model.redeemerUsername,\n                model.rewardName,\n                model.rewardCost,\n                model.userInput!)\n            : AppLocalizations.of(context)!\n                .channelPointRedemptionWithoutUserInput(\n                    model.redeemerUsername, model.rewardName, model.rewardCost),\n        tags: {\n          'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/prediction_event.dart",
    "content": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/twitch/prediction_event.dart';\n\nclass TwitchPredictionEventWidget extends StatelessWidget {\n  final TwitchPredictionEventModel model;\n\n  const TwitchPredictionEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return model.status != \"canceled\"\n        ? DecoratedEventWidget(\n            child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Padding(\n                  padding: const EdgeInsets.only(bottom: 8),\n                  child: Text(model.title,\n                      style: Theme.of(context).textTheme.titleSmall)),\n              ...model.outcomes.map((outcome) {\n                final isWinner = model.status == \"resolved\" &&\n                    model.winningOutcomeId == outcome.id;\n                return _TwitchOutcomeWidget(\n                    outcome: outcome,\n                    isWinner: isWinner,\n                    totalPoints: model.totalPoints);\n              }),\n            ],\n          ))\n        : Container();\n  }\n}\n\nclass _TwitchOutcomeWidget extends StatelessWidget {\n  const _TwitchOutcomeWidget(\n      {required this.outcome,\n      required this.isWinner,\n      required this.totalPoints});\n  final TwitchPredictionOutcomeModel outcome;\n  final bool isWinner;\n  final int totalPoints;\n\n  @override\n  Widget build(BuildContext context) {\n    final outcomePercentage =\n        \"${((outcome.points / max(1, totalPoints)) * 100).round()}%\";\n    return Padding(\n        padding: const EdgeInsets.only(bottom: 8),\n        child: Stack(alignment: AlignmentDirectional.center, children: [\n          SizedBox(\n            height: 37,\n            child: LinearProgressIndicator(\n              value: outcome.points / max(1, totalPoints),\n              valueColor: AlwaysStoppedAnimation<Color>(outcome.widgetColor),\n              backgroundColor: Theme.of(context).brightness == Brightness.light\n                  ? outcome.widgetColor.shade200\n                  : outcome.widgetColor.shade900,\n            ),\n          ),\n          Builder(builder: (context) {\n            if (isWinner) {\n              return Stack(alignment: AlignmentDirectional.center, children: [\n                const Padding(\n                  padding: EdgeInsets.only(left: 8),\n                  child: Align(\n                    alignment: Alignment.centerLeft,\n                    child: Icon(\n                      Icons.emoji_events_outlined,\n                    ),\n                  ),\n                ),\n                Padding(\n                  padding: const EdgeInsets.only(left: 48),\n                  child: Align(\n                    alignment: Alignment.centerLeft,\n                    child: Text(\n                      outcome.title,\n                    ),\n                  ),\n                ),\n                Padding(\n                  padding: const EdgeInsets.only(right: 12),\n                  child: Align(\n                      alignment: Alignment.centerRight,\n                      child: Text(outcomePercentage)),\n                )\n              ]);\n            } else {\n              return Stack(alignment: AlignmentDirectional.center, children: [\n                Padding(\n                  padding: const EdgeInsets.only(left: 12),\n                  child: Align(\n                    alignment: Alignment.centerLeft,\n                    child: Text(outcome.title),\n                  ),\n                ),\n                Padding(\n                  padding: const EdgeInsets.only(right: 12),\n                  child: Align(\n                      alignment: Alignment.centerRight,\n                      child: Text(outcomePercentage)),\n                )\n              ]);\n            }\n          }),\n        ]));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/poll_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/chat_history/twitch/poll_indicator.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\n\nList<Widget> getPollsWidget(TwitchPollEventModel model) {\n  var choices = model.choices;\n  List<Widget> children = [];\n  for (final poll in choices) {\n    children.add(PollChoiceWidget(\n        data: poll,\n        isCompleted: model.isCompleted,\n        maxVotes: model.maxVotes,\n        totalVotes: model.totalVotes));\n  }\n  return children;\n}\n\nclass TwitchPollEventWidget extends StatelessWidget {\n  final TwitchPollEventModel model;\n\n  const TwitchPollEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget(\n      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [\n        // title\n        Padding(\n            padding: const EdgeInsets.only(bottom: 8),\n            child: Text(model.pollTitle,\n                style: Theme.of(context).textTheme.titleSmall)),\n        // polls\n        ...getPollsWidget(model),\n      ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/raiding_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/messages/twitch/raiding_event.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchRaidingEventWidget extends StatelessWidget {\n  final TwitchRaidingEventModel model;\n\n  const TwitchRaidingEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    if (!model.isComplete) {\n      return StreamBuilder<int>(\n          stream: Stream.periodic(const Duration(milliseconds: 500), (x) => x),\n          builder: (context, snapshot) {\n            final flash = snapshot.data == null || snapshot.data! % 2 == 0;\n            final expiration = model.timestamp.add(model.duration);\n            final remaining = expiration.difference(DateTime.now());\n            return Stack(children: [\n              Positioned.fill(\n                child: AnimatedContainer(\n                  duration: const Duration(milliseconds: 500),\n                  color: flash\n                      ? Theme.of(context).highlightColor\n                      : Theme.of(context).colorScheme.secondary,\n                ),\n              ),\n              DecoratedEventWidget.avatar(\n                  decoration: const BoxDecoration(color: Colors.transparent),\n                  avatar:\n                      ResilientNetworkImage(model.targetUser.profilePictureUrl),\n                  child: Row(children: [\n                    Expanded(\n                      child: StyledText(\n                        text: AppLocalizations.of(context)!.raidingEventRaiding(\n                            model.targetUser.displayName ??\n                                AppLocalizations.of(context)!.anonymous),\n                        tags: {\n                          'b': StyledTextTag(\n                              style: Theme.of(context).textTheme.titleSmall),\n                        },\n                      ),\n                    ),\n                    Text.rich(TextSpan(\n                        text: remaining.isNegative\n                            ? AppLocalizations.of(context)!\n                                .raidingEventTimeRemaining(0)\n                            : AppLocalizations.of(context)!\n                                .raidingEventTimeRemaining(\n                                    remaining.inSeconds + 1),\n                        style: Theme.of(context).textTheme.titleSmall))\n                  ])),\n            ]);\n          });\n    } else if (model.isSuccessful) {\n      return GestureDetector(\n          child: DecoratedEventWidget.avatar(\n              avatar: ResilientNetworkImage(model.targetUser.profilePictureUrl),\n              child: Row(children: [\n                Expanded(\n                  child: StyledText(\n                    text: AppLocalizations.of(context)!.raidingEventRaided(\n                        model.targetUser.displayName ??\n                            AppLocalizations.of(context)!.anonymous),\n                    tags: {\n                      'b': StyledTextTag(\n                          style: Theme.of(context).textTheme.titleSmall),\n                    },\n                  ),\n                ),\n                Text.rich(TextSpan(\n                    text: AppLocalizations.of(context)!.raidingEventJoin,\n                    style: Theme.of(context).textTheme.titleSmall?.copyWith(\n                        color: Theme.of(context)\n                            .buttonTheme\n                            .colorScheme\n                            ?.primary))),\n              ])),\n          onTap: () {\n            final userModel = Provider.of<UserModel>(context, listen: false);\n            userModel.activeChannel = model.targetUser.asChannel;\n          });\n    } else {\n      return DecoratedEventWidget.avatar(\n          avatar: ResilientNetworkImage(model.targetUser.profilePictureUrl),\n          child: StyledText(\n            text: AppLocalizations.of(context)!.raidingEventCanceled(\n                model.targetUser.displayName ??\n                    AppLocalizations.of(context)!.anonymous),\n            tags: {\n              'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n            },\n          ));\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/poll_indicator.dart",
    "content": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/style.dart';\n\nclass PollChoiceWidget extends StatelessWidget {\n  final PollChoiceModel data;\n  final bool isCompleted;\n  final int maxVotes;\n  final int totalVotes;\n  const PollChoiceWidget(\n      {super.key,\n      required this.data,\n      required this.isCompleted,\n      required this.maxVotes,\n      required this.totalVotes});\n\n  @override\n  Widget build(BuildContext context) {\n    final percentage = data.votes / max(1, totalVotes);\n\n    return Consumer<StyleModel>(builder: (context, styleModel, child) {\n      var baseStyle = Theme.of(context)\n          .textTheme\n          .bodyMedium!\n          .copyWith(fontSize: styleModel.fontSize);\n      // winner poll gets a trophy icon\n      return Padding(\n          padding: const EdgeInsets.only(bottom: 8),\n          child: Stack(alignment: AlignmentDirectional.center, children: [\n            SizedBox(\n              height: 37,\n              child: LinearProgressIndicator(\n                color: Theme.of(context).colorScheme.secondary,\n                backgroundColor:\n                    Theme.of(context).brightness == Brightness.light\n                        ? Theme.of(context).scaffoldBackgroundColor\n                        : Theme.of(context).colorScheme.tertiary,\n                value: percentage,\n              ),\n            ),\n            if (isCompleted && data.votes >= maxVotes) ...[\n              const Padding(\n                padding: EdgeInsets.only(left: 8),\n                child: Align(\n                  alignment: Alignment.centerLeft,\n                  child: Icon(\n                    Icons.emoji_events_outlined,\n                    size: 32,\n                  ),\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.only(left: 48),\n                child: Align(\n                  alignment: Alignment.centerLeft,\n                  child: Text(\n                    data.title,\n                    style: baseStyle,\n                  ),\n                ),\n              )\n            ],\n            if (!isCompleted || data.votes < maxVotes) ...[\n              Padding(\n                padding: const EdgeInsets.only(left: 12),\n                child: Align(\n                  alignment: Alignment.centerLeft,\n                  child: Text(\n                    data.title,\n                    style: baseStyle,\n                  ),\n                ),\n              ),\n            ],\n            Padding(\n              padding: const EdgeInsets.only(right: 12),\n              child: Align(\n                  alignment: Alignment.centerRight,\n                  child: Text(\"${(percentage * 100).round()}% (${data.votes})\",\n                      style: baseStyle)),\n            ),\n          ]));\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/host_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchHostEventWidget extends StatelessWidget {\n  final TwitchHostEventModel model;\n\n  const TwitchHostEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatar(\n      avatar: ResilientNetworkImage(model.from.profilePictureUrl),\n      child: StyledText(\n        text: AppLocalizations.of(context)!.hostEventMessage(\n            model.from.displayName ?? AppLocalizations.of(context)!.anonymous,\n            model.viewers),\n        tags: {\n          'b': StyledTextTag(\n              style: Theme.of(context)\n                  .textTheme\n                  .titleSmall\n                  ?.copyWith(fontWeight: FontWeight.bold)),\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/cheer_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:styled_text/styled_text.dart';\n\nUri getCorrespondingImageUrl(int bits) {\n  final key = [100000, 10000, 5000, 1000, 100]\n      .firstWhere((k) => k <= bits, orElse: () => 10);\n  return Uri.parse(\n      'https://cdn.twitchalerts.com/twitch-bits/images/hd/$key.gif');\n}\n\nclass TwitchCheerEventWidget extends StatelessWidget {\n  final TwitchCheerEventModel model;\n\n  const TwitchCheerEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final name = model.isAnonymous\n        ? AppLocalizations.of(context)!.anonymous\n        : model.giverName ?? AppLocalizations.of(context)!.anonymous;\n    return DecoratedEventWidget.avatar(\n      avatar: ResilientNetworkImage(getCorrespondingImageUrl(model.bits)),\n      child: StyledText(\n        text: AppLocalizations.of(context)!\n            .cheerEventMessage(name, model.bits, model.cheerMessage),\n        tags: {\n          'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/message_link_preview.dart",
    "content": "import 'package:metadata_fetch/metadata_fetch.dart';\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\n\nclass TwitchClipData {\n  final String? imageUrl;\n  final String? url;\n  final String? title;\n  final String? description;\n\n  const TwitchClipData(\n      {required this.imageUrl,\n      required this.url,\n      required this.title,\n      required this.description});\n}\n\nFuture<TwitchClipData> fetchClipData(String url) async {\n  final data = await MetadataFetch.extract(url);\n  return TwitchClipData(\n      imageUrl: data!.image,\n      url: data.url,\n      title: data.title,\n      description: data.description);\n}\n\nclass TwitchMessageLinkPreviewWidget extends StatefulWidget {\n  final String url;\n\n  const TwitchMessageLinkPreviewWidget({required this.url, super.key});\n\n  @override\n  State<TwitchMessageLinkPreviewWidget> createState() =>\n      _TwitchMessageLinkPreviewWidgetState();\n}\n\nclass _TwitchMessageLinkPreviewWidgetState\n    extends State<TwitchMessageLinkPreviewWidget> {\n  TwitchClipData? _data;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // this approach instead of FutureBuilder prevents a flash of a loading\n    // indicator on subsequent rerender.\n    fetchClipData(widget.url).then((data) {\n      if (!mounted) {\n        return;\n      }\n      setState(() {\n        _data = data;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final data = _data;\n    if (data == null) {\n      return const Padding(\n          padding: EdgeInsets.symmetric(vertical: 4),\n          child: Card(child: CircularProgressIndicator()));\n    }\n    return Padding(\n        padding: const EdgeInsets.symmetric(vertical: 4),\n        child: Card(\n          child: ListTile(\n            leading: data.imageUrl == null\n                ? null\n                : Image(\n                    image: ResilientNetworkImage(Uri.parse(data.imageUrl!))),\n            title: data.title == null ? null : Text(data.title!),\n            subtitle: data.description == null ? null : Text(data.description!),\n            isThreeLine: true,\n          ),\n        ));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/follow_event.dart",
    "content": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/style.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchFollowEventWidget extends StatelessWidget {\n  final TwitchFollowEventModel model;\n\n  const TwitchFollowEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatars(\n      avatars: model.followers\n          .sublist(0, min(3, model.followers.length))\n          .map((follower) => ResilientNetworkImage(follower.profilePictureUrl)),\n      child: Consumer<StyleModel>(builder: (context, styleModel, child) {\n        switch (model.followers.length) {\n          case 1:\n            return StyledText(\n                text: AppLocalizations.of(context)!.followingEvent(\n                    styleModel.getTwitchDisplayName(model.followers.first)),\n                tags: {\n                  'bold': StyledTextTag(\n                      style: Theme.of(context).textTheme.titleSmall),\n                });\n          case 2:\n            // return x and y are following you.\n            return StyledText(\n                text: AppLocalizations.of(context)!.followingEvent2(\n                    styleModel.getTwitchDisplayName(model.followers.first),\n                    styleModel.getTwitchDisplayName(model.followers.last)),\n                tags: {\n                  'bold': StyledTextTag(\n                      style: Theme.of(context).textTheme.titleSmall),\n                });\n          default:\n            // return x, y, and n others are following you.\n            return StyledText(\n                text: AppLocalizations.of(context)!.followingEvent3(\n                    styleModel.getTwitchDisplayName(model.followers.first),\n                    styleModel.getTwitchDisplayName(model.followers.last),\n                    model.followers.length - 2),\n                tags: {\n                  'bold': StyledTextTag(\n                      style: Theme.of(context).textTheme.titleSmall),\n                });\n        }\n      }),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/raid_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/adapters/actions.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchRaidEventWidget extends StatelessWidget {\n  final TwitchRaidEventModel model;\n  final Channel channel;\n\n  const TwitchRaidEventWidget(this.model, {super.key, required this.channel});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.avatar(\n      avatar: ResilientNetworkImage(model.from.profilePictureUrl),\n      child: Row(children: [\n        Expanded(\n          child: StyledText(\n            text: AppLocalizations.of(context)!\n                .raidEventMessage(model.from.displayName ?? \"\", model.viewers),\n            tags: {\n              'b': StyledTextTag(style: Theme.of(context).textTheme.titleSmall),\n            },\n          ),\n        ),\n        Consumer<EventSubConfigurationModel>(\n            builder: (context, eventSubConfigurationModel, child) {\n          if (!eventSubConfigurationModel\n              .raidEventConfig.enableShoutoutButton) {\n            return Container();\n          }\n          return GestureDetector(\n              child: Text.rich(TextSpan(\n                  text: AppLocalizations.of(context)!.shoutout,\n                  style: Theme.of(context).textTheme.titleSmall?.copyWith(\n                      color:\n                          Theme.of(context).buttonTheme.colorScheme?.primary))),\n              onTap: () {\n                ActionsAdapter.instance\n                    .send(channel, \"/shoutout ${model.from.login}\");\n              });\n        }),\n      ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/badge.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/messages/twitch/badge.dart';\n\nclass TwitchBadgeWidget extends StatelessWidget {\n  final String badgeSetId;\n  final String version;\n  final double? height;\n\n  const TwitchBadgeWidget(\n      {super.key,\n      required this.badgeSetId,\n      required this.version,\n      this.height});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<TwitchBadgeModel>(builder: (context, model, child) {\n      if (!model.isEnabled(badgeSetId)) {\n        return const SizedBox();\n      }\n      for (final badgeSet in model.badgeSets) {\n        if (badgeSet.setId != badgeSetId) {\n          continue;\n        }\n        for (final version in badgeSet.versions) {\n          if (version.id != this.version) {\n            continue;\n          }\n          final url = Uri.tryParse(version.imageUrl1x);\n          if (url == null) {\n            return const SizedBox();\n          }\n          return Padding(\n              padding: const EdgeInsets.only(right: 5),\n              child: Image(image: ResilientNetworkImage(url), height: height));\n        }\n      }\n      // badge not found, ignore.\n      return const SizedBox();\n    });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/twitch/shoutout_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:rtchat/components/chat_history/decorated_event.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_create_event.dart';\nimport 'package:rtchat/models/messages/twitch/shoutout_receive_event.dart';\nimport 'package:styled_text/styled_text.dart';\n\nclass TwitchShoutoutCreateEventWidget extends StatelessWidget {\n  final TwitchShoutoutCreateEventModel model;\n\n  const TwitchShoutoutCreateEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.icon(\n      icon: Icons.campaign,\n      child: StyledText(\n        text:\n            'Shoutout was given to <b>${model.toBroadcasterUserName}</b> with ${model.viewerCount} viewers',\n        tags: {\n          'b': StyledTextTag(\n              style: const TextStyle(\n                  fontWeight: FontWeight.bold, color: Colors.purpleAccent)),\n        },\n      ),\n    );\n  }\n}\n\nclass TwitchShoutoutReceiveEventWidget extends StatelessWidget {\n  final TwitchShoutoutReceiveEventModel model;\n\n  const TwitchShoutoutReceiveEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedEventWidget.icon(\n      icon: Icons.campaign,\n      child: StyledText(\n        text:\n            '<b>${model.fromBroadcasterUserName}</b> gave you a shoutout to ${model.viewerCount} viewers',\n        tags: {\n          'b': StyledTextTag(\n              style: const TextStyle(\n                  fontWeight: FontWeight.bold, color: Colors.purpleAccent)),\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/decorated_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/image/cross_fade_image.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/style.dart';\n\nclass DecoratedEventWidget extends StatelessWidget {\n  final Widget child;\n  final Iterable<ImageProvider> avatars;\n  final IconData? icon;\n  final Color? accentColor;\n  final BoxDecoration decoration;\n  final EdgeInsets padding;\n\n  const DecoratedEventWidget._(\n      {super.key,\n      required this.child,\n      this.avatars = const [],\n      this.icon,\n      this.accentColor,\n      this.padding = const EdgeInsets.fromLTRB(12, 4, 16, 4),\n      this.decoration = const BoxDecoration()});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: decoration.copyWith(\n        color: decoration.color ?? Theme.of(context).highlightColor,\n        border: Border(\n          left: BorderSide(\n            width: 4,\n            color: accentColor ?? Theme.of(context).colorScheme.secondary,\n          ),\n        ),\n      ),\n      child: Padding(\n          padding: padding,\n          child: avatars.isEmpty && icon == null\n              ? child\n              : Consumer<StyleModel>(\n                  builder: (context, styleModel, child) {\n                    // this complex chunk of change keeps:\n                    // 1. the text centered if there is one line + avatar aligned\n                    // 2. the avatar and text fit if there are two lines\n                    // 3. the avatar aligned to top if there are more than two lines\n                    return IntrinsicHeight(\n                        child: Row(\n                      crossAxisAlignment: CrossAxisAlignment.stretch,\n                      children: [\n                        Align(\n                            alignment: Alignment.topLeft,\n                            child: ConstrainedBox(\n                              constraints: BoxConstraints(\n                                  maxHeight: 2 * styleModel.fontSize),\n                              child: Container(\n                                alignment: Alignment.center,\n                                child: Builder(builder: (context) {\n                                  if (avatars.isNotEmpty) {\n                                    if (avatars.length == 1) {\n                                      // short circuit for faster rendering.\n                                      return ClipRRect(\n                                        borderRadius: BorderRadius.circular(\n                                            styleModel.fontSize),\n                                        child: CrossFadeImage(\n                                            image: avatars.first,\n                                            height: styleModel.fontSize * 1.5,\n                                            width: styleModel.fontSize * 1.5),\n                                      );\n                                    }\n                                    return Stack(\n                                        children: avatars\n                                            .toList()\n                                            .asMap()\n                                            .entries\n                                            .map((entry) {\n                                              final index = entry.key;\n                                              final avatar = entry.value;\n                                              return Padding(\n                                                  padding: EdgeInsets.only(\n                                                      left: index * 12),\n                                                  child: ClipRRect(\n                                                    borderRadius:\n                                                        BorderRadius.circular(\n                                                            styleModel\n                                                                .fontSize),\n                                                    child: CrossFadeImage(\n                                                        placeholder: MemoryImage(\n                                                            kTransparentImage),\n                                                        image: avatar,\n                                                        height: styleModel\n                                                                .fontSize *\n                                                            1.5,\n                                                        width: styleModel\n                                                                .fontSize *\n                                                            1.5),\n                                                  ));\n                                            })\n                                            .toList()\n                                            .reversed\n                                            .toList());\n                                  }\n                                  // icon is not empty by precondition.\n                                  return Icon(icon,\n                                      size: styleModel.fontSize * 1.5);\n                                }),\n                              ),\n                            )),\n                        const SizedBox(width: 12),\n                        Expanded(\n                            child: Align(\n                                alignment: Alignment.centerLeft, child: child)),\n                      ],\n                    ));\n                  },\n                  child: child)),\n    );\n  }\n\n  Widget? get prefixWidget {\n    return null;\n  }\n\n  DecoratedEventWidget.avatar(\n      {Key? key,\n      required Widget child,\n      required ImageProvider avatar,\n      BoxDecoration decoration = const BoxDecoration()})\n      : this._(\n            key: key, child: child, avatars: [avatar], decoration: decoration);\n\n  const DecoratedEventWidget.avatars(\n      {Key? key,\n      required Widget child,\n      required Iterable<ImageProvider> avatars,\n      BoxDecoration decoration = const BoxDecoration()})\n      : this._(\n            key: key, child: child, avatars: avatars, decoration: decoration);\n\n  const DecoratedEventWidget.icon(\n      {Key? key,\n      required Widget child,\n      required IconData icon,\n      EdgeInsets padding = const EdgeInsets.fromLTRB(12, 4, 16, 4)})\n      : this._(key: key, padding: padding, child: child, icon: icon);\n\n  const DecoratedEventWidget({\n    Key? key,\n    required Widget child,\n    Color? accentColor,\n    EdgeInsets padding = const EdgeInsets.fromLTRB(12, 4, 16, 4),\n  }) : this._(\n            key: key, child: child, accentColor: accentColor, padding: padding);\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/stream_state_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/models/messages/message.dart';\n\nclass StreamStateEventWidget extends StatelessWidget {\n  final StreamStateEventModel model;\n\n  const StreamStateEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n        padding: const EdgeInsets.symmetric(vertical: 8),\n        child: SizedBox(\n          width: double.infinity,\n          child: Padding(\n              padding: const EdgeInsets.all(8),\n              child: Text(\n                model.isOnline\n                    ? AppLocalizations.of(context)!\n                        .streamOnline(model.timestamp, model.timestamp)\n                    : AppLocalizations.of(context)!\n                        .streamOffline(model.timestamp, model.timestamp),\n                textAlign: TextAlign.center,\n                style: Theme.of(context).textTheme.bodySmall,\n              )),\n        ));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/chat_cleared_event.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/models/messages/message.dart';\n\nclass ChatClearedEventWidget extends StatelessWidget {\n  final ChatClearedEventModel model;\n\n  const ChatClearedEventWidget(this.model, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n        padding: const EdgeInsets.symmetric(vertical: 8),\n        child: Container(\n          color: Theme.of(context).dividerColor,\n          width: double.infinity,\n          child: Padding(\n              padding: const EdgeInsets.all(8),\n              child: Text(\n                AppLocalizations.of(context)!\n                    .chatCleared(model.timestamp, model.timestamp),\n                textAlign: TextAlign.center,\n                style: Theme.of(context).textTheme.bodySmall,\n              )),\n        ));\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/timeout_dialog.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass TimeoutDialog extends StatefulWidget {\n  final String title;\n  final void Function(Duration) onPressed;\n\n  const TimeoutDialog(\n      {super.key, required this.title, required this.onPressed});\n\n  @override\n  State<TimeoutDialog> createState() => _TimeoutDialogState();\n}\n\nclass _TimeoutDialogState extends State<TimeoutDialog> {\n  var _value = 5;\n\n  String? getLabel(BuildContext context) {\n    switch (_value) {\n      case 1:\n        return AppLocalizations.of(context)!.durationOneSecond;\n      case 2:\n        return AppLocalizations.of(context)!.durationOneMinute;\n      case 3:\n        return AppLocalizations.of(context)!.durationTenMinutes;\n      case 4:\n        return AppLocalizations.of(context)!.durationOneHour;\n      case 5:\n        return AppLocalizations.of(context)!.durationSixHours;\n      case 6:\n        return AppLocalizations.of(context)!.durationOneDay;\n      case 7:\n        return AppLocalizations.of(context)!.durationTwoDays;\n      case 8:\n        return AppLocalizations.of(context)!.durationOneWeek;\n      case 9:\n        return AppLocalizations.of(context)!.durationTwoWeeks;\n    }\n    return null;\n  }\n\n  String getPrompt(BuildContext context) {\n    switch (_value) {\n      case 1:\n        return AppLocalizations.of(context)!.durationOneSecondTimeoutPrompt;\n      case 2:\n        return AppLocalizations.of(context)!.durationOneMinuteTimeoutPrompt;\n      case 3:\n        return AppLocalizations.of(context)!.durationTenMinutesTimeoutPrompt;\n      case 4:\n        return AppLocalizations.of(context)!.durationOneHourTimeoutPrompt;\n      case 5:\n        return AppLocalizations.of(context)!.durationSixHoursTimeoutPrompt;\n      case 6:\n        return AppLocalizations.of(context)!.durationOneDayTimeoutPrompt;\n      case 7:\n        return AppLocalizations.of(context)!.durationTwoDaysTimeoutPrompt;\n      case 8:\n        return AppLocalizations.of(context)!.durationOneWeekTimeoutPrompt;\n      case 9:\n        return AppLocalizations.of(context)!.durationTwoWeeksTimeoutPrompt;\n    }\n    return \"\";\n  }\n\n  Duration get _duration {\n    switch (_value) {\n      case 1:\n        return const Duration(seconds: 1);\n      case 2:\n        return const Duration(minutes: 1);\n      case 3:\n        return const Duration(minutes: 10);\n      case 4:\n        return const Duration(hours: 1);\n      case 5:\n        return const Duration(hours: 6);\n      case 6:\n        return const Duration(days: 1);\n      case 7:\n        return const Duration(days: 2);\n      case 8:\n        return const Duration(days: 7);\n      case 9:\n        return const Duration(days: 14);\n    }\n    return const Duration(days: 100 * 365);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AlertDialog(\n        title: Text(widget.title),\n        content: SizedBox(\n          height: 56,\n          child: Slider(\n            value: _value.toDouble(),\n            min: 1,\n            max: 9,\n            divisions: 9,\n            label: getLabel(context),\n            onChanged: (double value) {\n              setState(() {\n                _value = value.toInt();\n              });\n            },\n          ),\n        ),\n        actions: [\n          TextButton(\n              child: Text(getPrompt(context)),\n              onPressed: () {\n                widget.onPressed(_duration);\n              })\n        ]);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_history/separator.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport 'package:rtchat/models/adapters/messages.dart';\nimport 'package:rtchat/models/channels.dart';\n\nclass SeparatorWidget extends StatelessWidget {\n  final DateTime timestamp;\n  final Channel channel;\n  final format = DateFormat(\"MMM d, h:mm aa\");\n\n  static String formatDuration(Duration d) {\n    var seconds = d.inSeconds;\n    final days = seconds ~/ Duration.secondsPerDay;\n    seconds -= days * Duration.secondsPerDay;\n    final hours = seconds ~/ Duration.secondsPerHour;\n    seconds -= hours * Duration.secondsPerHour;\n    final minutes = seconds ~/ Duration.secondsPerMinute;\n    seconds -= minutes * Duration.secondsPerMinute;\n\n    final List<String> tokens = [];\n    if (days != 0) {\n      tokens.add('${days}d');\n    }\n    if (tokens.isNotEmpty || hours != 0) {\n      tokens.add('${hours}h');\n    }\n    if (tokens.isNotEmpty || minutes != 0) {\n      tokens.add('${minutes}m');\n    }\n    tokens.add('${seconds}s');\n\n    return tokens.join('');\n  }\n\n  SeparatorWidget(this.channel, this.timestamp, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),\n      child: StreamBuilder<DateTime?>(\n        stream: MessagesAdapter.instance\n            .forChannelUptime(channel, timestamp: timestamp),\n        builder: (context, snapshot) {\n          final uptime = snapshot.data;\n          if (uptime == null) {\n            return Text(\n              DateFormat().format(timestamp),\n              textAlign: TextAlign.center,\n              style: Theme.of(context).textTheme.bodySmall,\n            );\n          }\n          final delta = timestamp.difference(uptime);\n          return Text(\n            \"${format.format(timestamp)} [${formatDuration(delta)}]\",\n            textAlign: TextAlign.center,\n            style: Theme.of(context).textTheme.bodySmall,\n          );\n        },\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/activity_feed_panel.dart",
    "content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/activity_feed.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\nimport 'package:webview_flutter_android/webview_flutter_android.dart';\nimport 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';\n\nclass ActivityFeedPanelWidget extends StatefulWidget {\n  const ActivityFeedPanelWidget({super.key});\n\n  @override\n  State<ActivityFeedPanelWidget> createState() =>\n      _ActivityFeedPanelWidgetState();\n}\n\nclass _ActivityFeedPanelWidgetState extends State<ActivityFeedPanelWidget> {\n  late final ActivityFeedModel _activityFeedModel;\n  late final WebViewController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _activityFeedModel = Provider.of<ActivityFeedModel>(context, listen: false);\n    _activityFeedModel.addListener(synchronizeActivityFeedUrl);\n\n    if (WebViewPlatform.instance is WebKitWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          WebKitWebViewControllerCreationParams(\n        allowsInlineMediaPlayback: true,\n        mediaTypesRequiringUserAction: const {},\n      ));\n    } else if (WebViewPlatform.instance is AndroidWebViewPlatform) {\n      _controller = WebViewController.fromPlatformCreationParams(\n          AndroidWebViewControllerCreationParams());\n    } else {\n      throw UnsupportedError(\"Unsupported platform\");\n    }\n\n    _controller\n      ..setJavaScriptMode(JavaScriptMode.unrestricted)\n      ..enableZoom(false);\n\n    synchronizeActivityFeedUrl();\n  }\n\n  @override\n  void dispose() {\n    _activityFeedModel.removeListener(synchronizeActivityFeedUrl);\n\n    super.dispose();\n  }\n\n  void synchronizeActivityFeedUrl() async {\n    final uri = getUri();\n    if (uri != null) {\n      await _controller.loadRequest(uri);\n    }\n  }\n\n  Uri? getUri() {\n    final activityFeedModel =\n        Provider.of<ActivityFeedModel>(context, listen: false);\n    final userModel = Provider.of<UserModel>(context, listen: false);\n    final channel = userModel.userChannel;\n    if (activityFeedModel.isCustom) {\n      final tryUri = Uri.tryParse(activityFeedModel.customUrl);\n      if (tryUri != null && !tryUri.hasScheme) {\n        return Uri.tryParse(\"https://${activityFeedModel.customUrl}\");\n      }\n      return tryUri;\n    } else if (channel == null) {\n      return null;\n    }\n    switch (channel.provider) {\n      case \"twitch\":\n        return Uri.tryParse(\n            \"https://dashboard.twitch.tv/popout/u/${channel.displayName}/stream-manager/activity-feed\");\n    }\n    return null;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return WebViewWidget(\n      controller: _controller,\n      gestureRecognizers: {\n        Factory<OneSequenceGestureRecognizer>(() => EagerGestureRecognizer()),\n      },\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/emote_picker.dart",
    "content": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/components/image/cross_fade_image.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/messages/twitch/emote.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:sticky_headers/sticky_headers/widget.dart';\n\nclass EmotesList extends StatelessWidget {\n  const EmotesList({\n    super.key,\n    required this.emotes,\n    required this.onEmoteSelected,\n    required this.channel,\n  });\n\n  final List<Emote> emotes;\n  final Function(Emote) onEmoteSelected;\n  final Channel channel;\n\n  @override\n  Widget build(BuildContext context) {\n    final globalEmotes = AppLocalizations.of(context)!.globalEmotes;\n    final byCategory = emotes.fold<Map<String, List<Emote>>>({}, (map, emote) {\n      final category = emote.category ?? globalEmotes;\n      if (!map.containsKey(category)) {\n        map[category] = [];\n      }\n      map[category]!.add(emote);\n      return map;\n    });\n    final categories = byCategory.keys.toList();\n    categories.sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));\n\n    // ensure global emotes is first.\n    final globalEmotesIndex = categories.indexOf(globalEmotes);\n    if (globalEmotesIndex != -1) {\n      categories.removeAt(globalEmotesIndex);\n      categories.insert(0, globalEmotes);\n    }\n\n    // ensure channel emotes is second.\n    final channelEmotesIndex = categories.indexOf(channel.displayName);\n    if (channelEmotesIndex != -1) {\n      categories.removeAt(channelEmotesIndex);\n      categories.insert(1, channel.displayName);\n    }\n\n    return ListView.builder(\n      itemCount: categories.length,\n      itemBuilder: (context, index) {\n        return StickyHeader(\n          overlapHeaders: false,\n          header: Container(\n            width: MediaQuery.of(context).size.width,\n            color: Theme.of(context).scaffoldBackgroundColor,\n            padding: const EdgeInsets.symmetric(horizontal: 16.0),\n            alignment: Alignment.centerLeft,\n            child: Padding(\n              padding: const EdgeInsets.only(top: 8.0, bottom: 8.0),\n              child: Text(\n                categories[index],\n                style: TextStyle(\n                  color: Theme.of(context).colorScheme.primary,\n                  fontWeight: FontWeight.bold,\n                  fontSize: 16.0,\n                ),\n              ),\n            ),\n          ),\n          content: Padding(\n            padding:\n                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),\n            child: Center(\n              child: Wrap(\n                alignment: WrapAlignment.start,\n                spacing: 8.0,\n                runSpacing: 8.0,\n                children: byCategory[categories[index]]!.map((emote) {\n                  return Tooltip(\n                    message: emote.code,\n                    preferBelow: false,\n                    child: SizedBox(\n                      // Adjust width for 7 emotes per row\n                      width: (MediaQuery.of(context).size.width - 32) / 7 - 8,\n                      height: 36,\n                      child: IconButton(\n                        onPressed: () => onEmoteSelected(emote),\n                        splashRadius: 24,\n                        icon: CrossFadeImage(\n                          placeholder: emote.image.placeholderImage,\n                          image: emote.image,\n                          width: 36,\n                          height: 36,\n                        ),\n                      ),\n                    ),\n                  );\n                }).toList(),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass _TabbedEmotePickerWidget extends StatelessWidget {\n  const _TabbedEmotePickerWidget({\n    required this.emotes,\n    required this.onEmoteSelected,\n    required this.channel,\n  });\n\n  final List<Emote> emotes;\n  final Function(Emote) onEmoteSelected;\n  final Channel channel;\n\n  @override\n  Widget build(BuildContext context) {\n    final byProvider = emotes.fold<Map<String, List<Emote>>>({}, (map, emote) {\n      final provider = emote.provider;\n      if (!map.containsKey(provider)) {\n        map[provider] = [];\n      }\n      map[provider]!.add(emote);\n      return map;\n    });\n    final tabs = [\n      if (byProvider.containsKey(\"twitch\")) const Tab(text: \"Twitch\"),\n      if (byProvider.containsKey(\"bttv\")) const Tab(text: \"BTTV\"),\n      if (byProvider.containsKey(\"ffz\")) const Tab(text: \"FFZ\"),\n      if (byProvider.containsKey(\"7tv\")) const Tab(text: \"7TV\"),\n    ];\n    return DefaultTabController(\n      length: tabs.length,\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: [\n          TabBar(tabs: tabs),\n          Expanded(\n            child: TabBarView(\n              children: [\n                if (byProvider.containsKey(\"twitch\"))\n                  EmotesList(\n                    emotes: byProvider[\"twitch\"]!,\n                    onEmoteSelected: onEmoteSelected,\n                    channel: channel,\n                  ),\n                if (byProvider.containsKey(\"bttv\"))\n                  EmotesList(\n                    emotes: byProvider[\"bttv\"]!,\n                    onEmoteSelected: onEmoteSelected,\n                    channel: channel,\n                  ),\n                if (byProvider.containsKey(\"ffz\"))\n                  EmotesList(\n                    emotes: byProvider[\"ffz\"]!,\n                    onEmoteSelected: onEmoteSelected,\n                    channel: channel,\n                  ),\n                if (byProvider.containsKey(\"7tv\"))\n                  EmotesList(\n                    emotes: byProvider[\"7tv\"]!,\n                    onEmoteSelected: onEmoteSelected,\n                    channel: channel,\n                  ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass EmotePickerWidget extends StatelessWidget {\n  final void Function(Emote?) onEmoteSelected;\n  final List<Emote> emotes;\n  final Channel channel;\n\n  const EmotePickerWidget({\n    super.key,\n    required this.onEmoteSelected,\n    required this.channel,\n    required this.emotes,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final rowNumber =\n        MediaQuery.of(context).orientation == Orientation.portrait ? 6 : 4;\n    final maxHeight = MediaQuery.of(context).size.height * 0.5;\n\n    return PopScope(\n      canPop: false,\n      onPopInvokedWithResult: (didPop, result) {\n        onEmoteSelected(null);\n      },\n      child: SizedBox(\n        height: min(48 * rowNumber.toDouble(), maxHeight),\n        child: _TabbedEmotePickerWidget(\n          emotes: emotes,\n          onEmoteSelected: onEmoteSelected,\n          channel: channel,\n        ),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/message_input.dart",
    "content": "import 'dart:async';\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:flutter_keyboard_visibility/flutter_keyboard_visibility.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/autocomplete.dart';\nimport 'package:rtchat/components/emote_picker.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/adapters/actions.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/commands.dart';\nimport 'package:rtchat/models/messages/tokens.dart';\nimport 'package:rtchat/models/messages/twitch/emote.dart';\nimport 'package:rtchat/models/style.dart';\nimport 'package:rtchat/share_channel.dart';\n\nclass EmoteTextEditingController extends TextEditingController {\n  List<Emote> emotes;\n\n  EmoteTextEditingController(this.emotes);\n\n  Iterable<MessageToken> tokenizeEmotes(\n      String message, List<Emote> emotes) sync* {\n    final emotesMap = {for (final emote in emotes) emote.code: emote};\n    var lastParsedStart = 0;\n    for (var start = 0; start < message.length;) {\n      final end = message.indexOf(\" \", start);\n      final token =\n          end == -1 ? message.substring(start) : message.substring(start, end);\n      final emote = emotesMap[token.trim()];\n      if (emote != null) {\n        if (lastParsedStart != start) {\n          yield TextToken(message.substring(lastParsedStart, start));\n        }\n        yield EmoteToken(url: emote.uri, code: emote.code);\n        lastParsedStart = end == -1 ? message.length : end;\n      }\n      start = end == -1 ? message.length : end + 1;\n    }\n    if (lastParsedStart != message.length) {\n      yield TextToken(message.substring(lastParsedStart));\n    }\n  }\n\n  static Iterable<InlineSpan> render(\n      BuildContext context, StyleModel styleModel, MessageToken token) sync* {\n    if (token is TextToken) {\n      yield TextSpan(text: token.text);\n    } else if (token is EmoteToken) {\n      yield* [\n        TextSpan(text: \"\u200B\" * (token.code.length - 1)),\n        WidgetSpan(\n            alignment: PlaceholderAlignment.middle,\n            child: Tooltip(\n                message: token.code,\n                preferBelow: false,\n                child: Image(\n                    height: styleModel.fontSize,\n                    image: ResilientNetworkImage(token.url),\n                    errorBuilder: (context, error, stackTrace) =>\n                        Text(token.code))))\n      ];\n    } else {\n      throw Exception(\"invalid token\");\n    }\n  }\n\n  @override\n  TextSpan buildTextSpan({\n    required BuildContext context,\n    TextStyle? style,\n    required bool withComposing,\n  }) {\n    assert(!value.composing.isValid ||\n        !withComposing ||\n        value.isComposingRangeValid);\n    // If the composing range is out of range for the current text, ignore it to\n    // preserve the tree integrity, otherwise in release mode a RangeError will\n    // be thrown and this EditableText will be built with a broken subtree.\n    final bool composingRegionOutOfRange =\n        !value.isComposingRangeValid || !withComposing;\n\n    final styleModel = Provider.of<StyleModel>(context, listen: false);\n\n    if (composingRegionOutOfRange) {\n      return TextSpan(\n          style: style,\n          children: tokenizeEmotes(text, emotes)\n              .expand((token) => render(context, styleModel, token))\n              .toList());\n    }\n\n    final TextStyle composingStyle =\n        style?.merge(const TextStyle(decoration: TextDecoration.underline)) ??\n            const TextStyle(decoration: TextDecoration.underline);\n\n    return TextSpan(\n      style: style,\n      children: <TextSpan>[\n        TextSpan(\n            children:\n                tokenizeEmotes(value.composing.textBefore(value.text), emotes)\n                    .expand((token) => render(context, styleModel, token))\n                    .toList()),\n        TextSpan(\n          style: composingStyle,\n          text: value.composing.textInside(value.text),\n        ),\n        TextSpan(\n            children:\n                tokenizeEmotes(value.composing.textAfter(value.text), emotes)\n                    .expand((token) => render(context, styleModel, token))\n                    .toList()),\n      ],\n    );\n  }\n}\n\nclass MessageInputWidget extends StatefulWidget {\n  final Channel channel;\n  final List<Emote> emotes; // TODO: decouple this from the twitch emote model.\n\n  const MessageInputWidget(\n      {super.key, required this.channel, required this.emotes});\n\n  @override\n  State<MessageInputWidget> createState() => _MessageInputWidgetState();\n}\n\nfinal _emotes = [\n  \"https://static-cdn.jtvnw.net/emoticons/v2/425618/default/light/2.0\",\n  \"https://static-cdn.jtvnw.net/emoticons/v2/112291/default/light/2.0\",\n  \"https://static-cdn.jtvnw.net/emoticons/v2/81274/default/light/2.0\",\n  \"https://static-cdn.jtvnw.net/emoticons/v2/28087/default/light/2.0\",\n  \"https://static-cdn.jtvnw.net/emoticons/v2/305954156/default/light/2.0\",\n];\n\nconst _greyscale = ColorFilter.matrix([\n  0.2126, 0.7152, 0.0722, 0, 0, // red\n  0.2126, 0.7152, 0.0722, 0, 0, // green\n  0.2126, 0.7152, 0.0722, 0, 0, // blue\n  0, 0, 0, 1, 0, // alpha\n]);\n\nclass _MessageInputWidgetState extends State<MessageInputWidget> {\n  late final EmoteTextEditingController _textEditingController;\n  final _chatInputFocusNode = FocusNode();\n  var _isEmotePickerVisible = false;\n  var _isKeyboardVisible = false;\n  late StreamSubscription keyboardSubscription;\n  var _emoteIndex = Random().nextInt(_emotes.length);\n  final _textSeed = Random().nextDouble();\n  final List<String> _pendingSend = [];\n\n  @override\n  void initState() {\n    super.initState();\n    final keyboardVisibilityController = KeyboardVisibilityController();\n    _textEditingController = EmoteTextEditingController(widget.emotes);\n    // Subscribe to keyboard visibility changes.\n    keyboardSubscription =\n        keyboardVisibilityController.onChange.listen((visible) {\n      setState(() {\n        _isKeyboardVisible = visible;\n      });\n    });\n\n    ShareChannel()\n      // Register a callback to handle any shared data while app is running\n      ..onDataReceived = _handleSharedData\n      // Check to see if there is any shared data already via sharing\n      ..getSharedText().then(_handleSharedData);\n  }\n\n  @override\n  void didUpdateWidget(MessageInputWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    _textEditingController.emotes = widget.emotes;\n  }\n\n  // Handles any shared data we may receive.\n  void _handleSharedData(String sharedData) {\n    setState(() {\n      _textEditingController.text = sharedData;\n    });\n  }\n\n  @override\n  void dispose() {\n    keyboardSubscription.cancel();\n    _textEditingController.dispose();\n    super.dispose();\n  }\n\n  void sendMessage(String value) async {\n    value = value.trim();\n    if (value.isEmpty) {\n      return;\n    }\n    final messenger = ScaffoldMessenger.of(context);\n    if (value.startsWith('!')) {\n      final commandsModel = Provider.of<CommandsModel>(context, listen: false);\n      commandsModel.addCommand(Command(value, DateTime.now()));\n    }\n    if (!mounted) {\n      return;\n    }\n    setState(() {\n      _textEditingController.clear();\n    });\n    var done = false;\n    await Future.wait([\n      () async {\n        try {\n          final error =\n              await ActionsAdapter.instance.send(widget.channel, value);\n          if (error != null) {\n            messenger.showSnackBar(SnackBar(\n              content: Text(error),\n            ));\n          }\n        } catch (e) {\n          messenger.showSnackBar(SnackBar(\n            content: Text(e.toString()),\n          ));\n        }\n        done = true;\n        if (!mounted) {\n          return;\n        }\n        setState(() {\n          _pendingSend.remove(value);\n        });\n      }(),\n      () async {\n        await Future.delayed(const Duration(seconds: 1));\n        if (!done) {\n          if (!mounted) {\n            return;\n          }\n          setState(() {\n            _pendingSend.add(value);\n          });\n        }\n      }(),\n    ]);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // render pending sends\n            ..._pendingSend.map((e) => Padding(\n                  padding:\n                      const EdgeInsets.symmetric(vertical: 4, horizontal: 16),\n                  child: Text(e,\n                      style: const TextStyle(fontStyle: FontStyle.italic)),\n                )),\n            if (_isKeyboardVisible)\n              Flexible(\n                child: AutocompleteWidget(\n                  controller: _textEditingController,\n                  onSend: sendMessage,\n                  channel: widget.channel,\n                ),\n              ),\n            Padding(\n              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n              child: Container(\n                decoration: BoxDecoration(\n                    borderRadius: const BorderRadius.all(Radius.circular(24)),\n                    color: Theme.of(context).splashColor),\n                child: TextField(\n                  focusNode: _chatInputFocusNode,\n                  controller: _textEditingController,\n                  textInputAction: TextInputAction.send,\n                  maxLines: 6,\n                  minLines: 1,\n                  textAlignVertical: TextAlignVertical.center,\n                  decoration: InputDecoration(\n                      prefixIcon: IconButton(\n                        onPressed: () {\n                          if (_isEmotePickerVisible) {\n                            setState(() => _isEmotePickerVisible = false);\n                            _chatInputFocusNode.requestFocus();\n                          } else {\n                            _chatInputFocusNode.unfocus();\n                            setState(() {\n                              _isEmotePickerVisible = true;\n                              _emoteIndex = Random().nextInt(_emotes.length);\n                            });\n                          }\n                        },\n                        splashRadius: 24,\n                        icon: _isEmotePickerVisible\n                            ? const Icon(Icons.keyboard_rounded)\n                            : ColorFiltered(\n                                colorFilter: _greyscale,\n                                child: Image(\n                                  width: 24,\n                                  height: 24,\n                                  image: ResilientNetworkImage(\n                                      Uri.parse(_emotes[_emoteIndex])),\n                                )),\n                      ),\n                      suffixIcon: IconButton(\n                        icon: const Icon(Icons.send_rounded),\n                        color: Theme.of(context).colorScheme.primary,\n                        splashRadius: 24,\n                        onPressed: () =>\n                            sendMessage(_textEditingController.text),\n                      ),\n                      border: InputBorder.none,\n                      hintMaxLines: 1,\n                      hintText: () {\n                        final l10n = AppLocalizations.of(context)!;\n                        if (_textSeed < 0.5) {\n                          return l10n.sendAMessage;\n                        } else if (_textSeed < 0.9) {\n                          return l10n.writeSomething;\n                        } else if (_textSeed < 0.99) {\n                          return l10n.speakToTheCrowds;\n                        } else if (_textSeed < 0.999) {\n                          return l10n.shareYourThoughts;\n                        }\n                        return l10n.saySomethingYouLittleBitch;\n                      }()),\n                  onChanged: (text) {\n                    final filtered = text.replaceAll('\n', ' ');\n                    if (filtered == text) {\n                      return;\n                    }\n                    setState(() {\n                      _textEditingController.value = TextEditingValue(\n                          text: filtered,\n                          selection: TextSelection.fromPosition(TextPosition(\n                              offset: _textEditingController.text.length)));\n                    });\n                  },\n                  onSubmitted: sendMessage,\n                  onTap: () {\n                    setState(() => _isEmotePickerVisible = false);\n                    _chatInputFocusNode.requestFocus();\n                  },\n                ),\n              ),\n            ),\n            _isEmotePickerVisible\n                ? EmotePickerWidget(\n                    channel: widget.channel,\n                    emotes: widget.emotes,\n                    onEmoteSelected: (emote) {\n                      if (emote == null) {\n                        setState(() {\n                          _isEmotePickerVisible = false;\n                        });\n                        return;\n                      }\n                      if (_textEditingController.text.isNotEmpty) {\n                        _textEditingController.text =\n                            \"${_textEditingController.text} ${emote.code} \";\n                      } else {\n                        _textEditingController.text = \"${emote.code} \";\n                      }\n                    })\n                : Container(),\n          ]),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/connection_status.dart",
    "content": "import 'package:firebase_database/firebase_database.dart';\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/components/chat_panel.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\n\nclass ConnectionStatusWidget extends StatelessWidget {\n  final _delay = const Duration(seconds: 5);\n\n  const ConnectionStatusWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        // add a sentinel listener so Firebase connects to the db.\n        StreamBuilder(\n            stream: FirebaseDatabase.instance.ref('sentinel').onValue,\n            builder: (context, snapshot) => Container()),\n        StreamBuilder<DateTime?>(\n            stream: FirebaseDatabase.instance\n                .ref('.info/connected')\n                .onValue\n                .map((event) {\n              return event.snapshot.value == false ? DateTime.now() : null;\n            }),\n            builder: (context, snapshot) {\n              final data = snapshot.data;\n              if (data == null) {\n                return Container();\n              }\n              return RebuildableWidget(\n                  rebuildAt: {data.add(_delay)},\n                  builder: (context) {\n                    if (DateTime.now().difference(data) < _delay) {\n                      return Container();\n                    }\n                    return Container(\n                      width: double.infinity,\n                      height: 48,\n                      alignment: Alignment.center,\n                      color: Colors.red,\n                      child: Text(AppLocalizations.of(context)!.reconnecting),\n                    );\n                  });\n            }),\n      ],\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/style_model_theme.dart",
    "content": "import 'dart:io';\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/style.dart';\n\nclass StyleModelTheme extends StatelessWidget {\n  final Widget child;\n\n  const StyleModelTheme({required this.child, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<StyleModel>(\n        builder: (context, model, child) {\n          final theme = Theme.of(context);\n          final fontFamily = Platform.isIOS\n              ? Typography.whiteCupertino.bodyMedium!.fontFamily\n              : Typography.whiteMountainView.bodyMedium!.fontFamily;\n          final themeData = theme.copyWith(\n              textTheme: theme.textTheme.apply(\n                  fontSizeDelta: model.fontSize - 14, fontFamily: fontFamily));\n          return Theme(\n              data: themeData,\n              child: DefaultTextStyle(\n                  style: themeData.textTheme.bodyMedium!, child: child!));\n        },\n        child: child);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/disco.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/style.dart';\n\nfinal discoModeColors = [\n  Colors.red.withOpacity(0.7),\n  Colors.blue.withOpacity(0.7),\n  Colors.green.withOpacity(0.7),\n  Colors.purple.withOpacity(0.7),\n  Colors.yellow.withOpacity(0.7),\n  Colors.cyan.withOpacity(0.7),\n  Colors.brown.withOpacity(0.7),\n];\n\nclass DiscoWidget extends StatelessWidget {\n  final Widget child;\n  final bool isEnabled;\n\n  const DiscoWidget({required this.child, required this.isEnabled, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<StyleModel, bool>(\n      selector: (context, model) => model.isDiscoModeAvailable,\n      builder: (context, isDiscoModeAvailable, child) {\n        if (isEnabled && isDiscoModeAvailable) {\n          return Stack(\n            children: [\n              child!,\n              StreamBuilder<int>(\n                  stream: Stream.periodic(\n                      const Duration(milliseconds: 150), (x) => x),\n                  builder: (context, snapshot) {\n                    final index = (snapshot.data ?? 0);\n                    final color = index % 2 != 0\n                        ? Colors.white\n                        : discoModeColors[\n                            (index ~/ 2) % discoModeColors.length];\n                    return Positioned.fill(\n                      child: AnimatedContainer(\n                        duration: const Duration(milliseconds: 50),\n                        color: color,\n                      ),\n                    );\n                  }),\n            ],\n          );\n        }\n        return child!;\n      },\n      child: child,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/auth/companion_auth.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:qr_flutter/qr_flutter.dart';\nimport 'package:rtchat/models/adapters/profiles.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:uuid/uuid.dart';\n\nclass CompanionAuthWidget extends StatefulWidget {\n  final String provider;\n  final bool isTooOld;\n\n  const CompanionAuthWidget({\n    super.key,\n    required this.isTooOld,\n    required this.provider,\n  });\n\n  @override\n  State<CompanionAuthWidget> createState() => _CompanionAuthWidgetState();\n}\n\nclass _CompanionAuthWidgetState extends State<CompanionAuthWidget> {\n  final sessionUuid = const Uuid().v4();\n\n  @override\n  void initState() {\n    super.initState();\n    final user = Provider.of<UserModel>(context, listen: false);\n    final navigator = Navigator.of(context);\n    ProfilesAdapter.instance\n        .getCompanionAuthToken(sessionUuid: sessionUuid)\n        .then((token) async {\n      await user.signIn(token);\n      if (!mounted) {\n        return;\n      }\n      navigator.pop();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return DraggableScrollableSheet(\n        initialChildSize: 0.8,\n        maxChildSize: 0.9,\n        expand: false,\n        builder: (context, controller) {\n          return Padding(\n            padding: const EdgeInsets.all(16),\n            child: Column(children: [\n              Text(\n                widget.isTooOld\n                    ? \"Your browser is too old to support signing in directly. \"\n                        \"Scan this QR code with your phone to sign in on another device.\"\n                    : \"Scan this QR code with your phone to sign in on another device.\",\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 16),\n              QrImageView(\n                backgroundColor: Colors.white,\n                data:\n                    'https://chat.rtirl.com/auth/${widget.provider}/redirect?companion=$sessionUuid',\n                version: QrVersions.auto,\n                size: 200.0,\n              ),\n            ]),\n          );\n        });\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/auth/twitch.dart",
    "content": "import 'dart:async';\n\nimport 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:flutter_web_auth/flutter_web_auth.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/auth/companion_auth.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\n\nfinal url = Uri.https('chat.rtirl.com', '/auth/twitch/redirect');\n\nclass SignInWithTwitch extends StatelessWidget {\n  final void Function()? onStart;\n  final void Function()? onComplete;\n\n  const SignInWithTwitch({\n    super.key,\n    this.onStart,\n    this.onComplete,\n  });\n\n  static Future<bool> isGlobalThisSupported() async {\n    final completer = Completer<bool>();\n    final controller = WebViewController()\n      ..setJavaScriptMode(JavaScriptMode.unrestricted);\n    controller.addJavaScriptChannel(\"response\", onMessageReceived: (message) {\n      completer.complete(message.message == \"true\");\n    });\n    controller.setNavigationDelegate(\n      NavigationDelegate(\n        onPageFinished: (url) {\n          controller.runJavaScript(\n              \"response.postMessage(typeof globalThis !== 'undefined');\");\n        },\n      ),\n    );\n    controller.loadRequest(Uri.parse(\"about:blank\"));\n    return completer.future;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      style: ButtonStyle(\n        backgroundColor: WidgetStateProperty.all(const Color(0xFF6441A5)),\n      ),\n      child: Text(AppLocalizations.of(context)!.signInWithTwitch,\n          style: const TextStyle(\n            color: Colors.white,\n          )),\n      onPressed: () async {\n        final isGlobalThisSupported =\n            await SignInWithTwitch.isGlobalThisSupported();\n        if (!context.mounted) {\n          return;\n        }\n        if (!isGlobalThisSupported) {\n          // we need to sign in via QR code, so show a bottom sheet with a QR code.\n          // generate a uuid\n          showModalBottomSheet<void>(\n            context: context,\n            isScrollControlled: true,\n            shape: const RoundedRectangleBorder(\n              borderRadius: BorderRadius.vertical(top: Radius.circular(16)),\n            ),\n            builder: (context) {\n              return const CompanionAuthWidget(\n                provider: \"twitch\",\n                isTooOld: true,\n              );\n            },\n          );\n          return;\n        }\n        final user = Provider.of<UserModel>(context, listen: false);\n        final scaffoldMessenger = ScaffoldMessenger.of(context);\n\n        final navigator = Navigator.of(context);\n        final localizations = MaterialLocalizations.of(context);\n        final modalBarrierColor =\n            Theme.of(context).bottomSheetTheme.modalBarrierColor;\n        final navigatorContext = navigator.context;\n        if (!navigatorContext.mounted) {\n          return;\n        }\n        final capturedThemes =\n            InheritedTheme.capture(from: context, to: navigatorContext);\n        final retrySnackbar = SnackBar(\n            content: Text(AppLocalizations.of(context)!.signInError),\n            action: SnackBarAction(\n              label: \"Sign in with another device\",\n              onPressed: () {\n                navigator.push(ModalBottomSheetRoute(\n                  builder: (context) {\n                    return const CompanionAuthWidget(\n                      provider: \"twitch\",\n                      isTooOld: false,\n                    );\n                  },\n                  capturedThemes: capturedThemes,\n                  isScrollControlled: true,\n                  barrierOnTapHint: localizations\n                      .scrimOnTapHint(localizations.bottomSheetLabel),\n                  modalBarrierColor: modalBarrierColor,\n                ));\n              },\n            ));\n        onStart?.call();\n        try {\n          await FirebaseAnalytics.instance.logLogin(loginMethod: \"twitch\");\n          final result = await FlutterWebAuth.authenticate(\n              url: url.toString(), callbackUrlScheme: \"com.rtirl.chat\");\n          final token = Uri.parse(result).queryParameters['token'];\n          if (token != null) {\n            await user.signIn(token);\n            // there's a bit of lag between the sign in call completing and the\n            // ui updating to the homepage. delay the onComplete handler so any\n            // loading indicator still shows.\n            Timer(const Duration(seconds: 3), () {\n              onComplete?.call();\n            });\n          } else {\n            onComplete?.call();\n            scaffoldMessenger.showSnackBar(retrySnackbar);\n          }\n        } catch (e) {\n          onComplete?.call();\n          if (!(e is PlatformException && e.code == \"CANCELLED\")) {\n            scaffoldMessenger.showSnackBar(retrySnackbar);\n          }\n        }\n      },\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/channel_search_results.dart",
    "content": "import 'dart:async';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:cloud_functions/cloud_functions.dart';\nimport 'package:flutter/material.dart';\nimport 'package:rtchat/components/image/cross_fade_image.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/channels.dart';\n\nfinal _search = FirebaseFunctions.instance.httpsCallable(\"search\");\n\nFuture<List<SearchResult>> fastSearch() async {\n  // fast query firestore and slow query the functions. tag firestore results\n  // with isPromoted = true.\n  final snapshot = await FirebaseFirestore.instance\n      .collection(\"channels\")\n      .where(\"lastActiveAt\",\n          isGreaterThan: DateTime.now().subtract(const Duration(days: 3)))\n      .orderBy(\"lastActiveAt\", descending: true)\n      .limit(250)\n      .get();\n  return snapshot.docs\n      .where((doc) => doc.data().containsKey(\"displayName\"))\n      .map((doc) {\n    final data = doc.data();\n    final tokens = doc.id.split(\":\");\n    final provider = tokens[0];\n    final channelId = tokens[1];\n    String? title;\n    if (data['title'] != null && data['categoryName'] != null) {\n      title = \"${data['categoryName']} - ${data['title']}\";\n    } else if (data['title'] != null) {\n      title = data['title'];\n    } else if (data['categoryName'] != null) {\n      title = data['categoryName'];\n    }\n    return SearchResult(\n        channelId: channelId,\n        provider: provider,\n        login: data['login'],\n        displayName: data['displayName'],\n        isOnline: data['onlineAt'] != null,\n        imageUrl: Uri.parse(\n            \"https://rtirl.com/pfp.png?provider=$provider&channelId=$channelId\"),\n        title: title,\n        language: data['language'],\n        isPromoted: true);\n  }).toList();\n}\n\nStream<List<SearchResult>> search(String query, bool isShowOnlyOnline) async* {\n  final fast = await fastSearch();\n  final fastFiltered = fast.where((result) =>\n      result.displayName.toLowerCase().contains(query.toLowerCase()) ||\n      result.login.toLowerCase().contains(query.toLowerCase()));\n  final fastRanked = [\n    ...fastFiltered.where((element) => element.isOnline),\n    ...fastFiltered.where((element) => !element.isOnline)\n  ].take(5);\n  yield fastRanked.toList();\n  final slow = await _search(query).then((result) {\n    return (result.data as List<dynamic>)\n        .map((data) => SearchResult(\n            channelId: data['channelId'],\n            provider: data['provider'],\n            login: data['login'],\n            displayName: data['displayName'],\n            isOnline: data['isOnline'],\n            imageUrl: Uri.parse(data['imageUrl']),\n            title: data['title'],\n            language: data['language'],\n            isPromoted: false))\n        .toList();\n  });\n  final slowFiltered = slow.where((result) =>\n      !fastFiltered.any((element) => element.channelId == result.channelId) &&\n      (!isShowOnlyOnline || result.isOnline));\n  yield [...fastRanked, ...slowFiltered];\n}\n\nfinal url = Uri.https('chat.rtirl.com', '/auth/twitch/redirect');\n\nclass SearchResult {\n  final String channelId;\n  final String provider;\n  final String login;\n  final String displayName;\n  final bool isOnline;\n  final Uri imageUrl;\n  final String? title;\n  final bool isPromoted;\n  final String? language;\n\n  const SearchResult(\n      {required this.channelId,\n      required this.provider,\n      required this.login,\n      required this.displayName,\n      required this.isOnline,\n      required this.imageUrl,\n      required this.title,\n      required this.isPromoted,\n      required this.language});\n\n  ResilientNetworkImage get image => ResilientNetworkImage(imageUrl);\n}\n\nclass ChannelSearchResultsWidget extends StatefulWidget {\n  final String query;\n  final bool isShowOnlyOnline;\n  final Function(Channel) onChannelSelect;\n  final ScrollController? controller;\n\n  const ChannelSearchResultsWidget(\n      {super.key,\n      required this.query,\n      required this.onChannelSelect,\n      required this.isShowOnlyOnline,\n      this.controller});\n\n  @override\n  State<ChannelSearchResultsWidget> createState() =>\n      _ChannelSearchResultsWidgetState();\n}\n\nclass _ChannelSearchResultsWidgetState\n    extends State<ChannelSearchResultsWidget> {\n  late Stream<List<SearchResult>> _results;\n  Timer? _debounce;\n\n  @override\n  void initState() {\n    super.initState();\n    _results = search(widget.query, widget.isShowOnlyOnline);\n  }\n\n  @override\n  void didUpdateWidget(covariant ChannelSearchResultsWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.query != widget.query ||\n        oldWidget.isShowOnlyOnline != widget.isShowOnlyOnline) {\n      _debounce?.cancel();\n      _debounce = Timer(const Duration(milliseconds: 500), () {\n        setState(() {\n          _results = search(widget.query, widget.isShowOnlyOnline);\n        });\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _debounce?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      controller: widget.controller,\n      children: [\n        StreamBuilder<List<SearchResult>>(\n          stream: _results,\n          builder: (context, snapshot) {\n            return Column(\n              children: (snapshot.data ?? [])\n                  .map((result) => ListTile(\n                      leading: Container(\n                          height: 48,\n                          width: 48,\n                          decoration: BoxDecoration(\n                            shape: BoxShape.circle,\n                            border: Border.all(\n                              color: result.isOnline\n                                  ? Theme.of(context).colorScheme.secondary\n                                  : Colors.transparent,\n                              width: 2.0,\n                            ),\n                          ),\n                          child: Stack(\n                              alignment: Alignment.center,\n                              clipBehavior: Clip.none,\n                              children: [\n                                ClipRRect(\n                                  borderRadius: BorderRadius.circular(24),\n                                  child: CrossFadeImage(\n                                      placeholder:\n                                          result.image.placeholderImage,\n                                      image: result.image,\n                                      height: 48,\n                                      width: 48),\n                                ),\n                                Positioned(\n                                    right: -4,\n                                    bottom: -4,\n                                    child: result.isPromoted\n                                        ? Container(\n                                            decoration: BoxDecoration(\n                                              color: Theme.of(context)\n                                                  .colorScheme\n                                                  .tertiary,\n                                              borderRadius:\n                                                  BorderRadius.circular(18.0),\n                                            ),\n                                            child: const Icon(\n                                              Icons.keyboard_double_arrow_up,\n                                              color: Colors.green,\n                                              size: 18.0,\n                                            ),\n                                          )\n                                        : Container())\n                              ])),\n                      title: Row(\n                          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                          children: [\n                            Text(result.displayName,\n                                overflow: TextOverflow.ellipsis),\n                            Text(\n                              result.language ?? \"??\",\n                              style: Theme.of(context).textTheme.labelSmall,\n                            ),\n                          ]),\n                      subtitle:\n                          result.title == null ? null : Text(result.title!),\n                      onTap: () {\n                        widget.onChannelSelect(Channel(\n                          \"twitch\",\n                          result.channelId,\n                          result.displayName,\n                        ));\n                      }))\n                  .toList(),\n            );\n          },\n        ),\n      ],\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/chat_panel.dart",
    "content": "import 'dart:async';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/message.dart';\nimport 'package:rtchat/components/chat_history/separator.dart';\nimport 'package:rtchat/components/connection_status.dart';\nimport 'package:rtchat/components/pinnable/reverse_refresh_indicator.dart';\nimport 'package:rtchat/components/pinnable/scroll_view.dart';\nimport 'package:rtchat/components/style_model_theme.dart';\nimport 'package:rtchat/models/adapters/messages.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/messages.dart';\nimport 'package:rtchat/models/messages/message.dart';\nimport 'package:rtchat/models/messages/twitch/channel_point_redemption_event.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\nimport 'package:rtchat/models/messages/twitch/hype_train_event.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/prediction_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_gift_event.dart';\nimport 'package:rtchat/models/messages/twitch/subscription_message_event.dart';\n\nclass RebuildableWidget extends StatefulWidget {\n  final Widget Function(BuildContext) builder;\n  final Set<DateTime> rebuildAt;\n\n  const RebuildableWidget(\n      {super.key, required this.builder, required this.rebuildAt});\n\n  @override\n  State<RebuildableWidget> createState() => _RebuildableWidgetState();\n}\n\nclass _RebuildableWidgetState extends State<RebuildableWidget> {\n  Set<Timer> timers = {};\n\n  @override\n  void initState() {\n    super.initState();\n\n    _setTimers();\n  }\n\n  @override\n  void didUpdateWidget(RebuildableWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n\n    if (!setEquals(oldWidget.rebuildAt, widget.rebuildAt)) {\n      _clearTimers();\n      _setTimers();\n    }\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n\n    _clearTimers();\n  }\n\n  void _setTimers() {\n    final now = DateTime.now();\n    timers = widget.rebuildAt.expand((dateTime) sync* {\n      final duration = dateTime.difference(now);\n      if (!duration.isNegative) {\n        yield Timer(duration, () => setState(() {}));\n      }\n    }).toSet();\n  }\n\n  void _clearTimers() {\n    for (final timer in timers) {\n      timer.cancel();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget.builder(context);\n  }\n}\n\nDateTime? _getExpiration(\n    MessageModel model,\n    EventSubConfigurationModel eventSubConfigurationModel,\n    MessagesModel messagesModel) {\n  if (model is TwitchRaidEventModel) {\n    final raidEventConfig = eventSubConfigurationModel.raidEventConfig;\n    return raidEventConfig.eventDuration > Duration.zero\n        ? model.timestamp.add(raidEventConfig.eventDuration)\n        : null;\n  } else if (model is TwitchHostEventModel) {\n    final hostEventConfig = eventSubConfigurationModel.hostEventConfig;\n    return hostEventConfig.eventDuration > Duration.zero\n        ? model.timestamp.add(hostEventConfig.eventDuration)\n        : null;\n  } else if (model is TwitchFollowEventModel) {\n    final followEventConfig = eventSubConfigurationModel.followEventConfig;\n    return followEventConfig.eventDuration > Duration.zero\n        ? model.timestamp.add(followEventConfig.eventDuration)\n        : null;\n  } else if (model is TwitchCheerEventModel) {\n    final cheerEventConfig = eventSubConfigurationModel.cheerEventConfig;\n    return cheerEventConfig.eventDuration > Duration.zero\n        ? model.timestamp.add(cheerEventConfig.eventDuration)\n        : null;\n  } else if (model is TwitchSubscriptionEventModel ||\n      model is TwitchSubscriptionGiftEventModel ||\n      model is TwitchSubscriptionMessageEventModel) {\n    final subEventConfig = eventSubConfigurationModel.subscriptionEventConfig;\n    return subEventConfig.eventDuration > Duration.zero\n        ? model.timestamp.add(subEventConfig.eventDuration)\n        : null;\n  } else if (model is TwitchPollEventModel) {\n    final pollEventConfig = eventSubConfigurationModel.pollEventConfig;\n    if (model.status == 'archived' || model.status == 'terminated') {\n      return null;\n    }\n    return model.endTimestamp.add(pollEventConfig.eventDuration);\n  } else if (model is TwitchChannelPointRedemptionEventModel) {\n    final channelPointRedemptionEventConfig =\n        eventSubConfigurationModel.channelPointRedemptionEventConfig;\n    final unfulfilledDuration =\n        channelPointRedemptionEventConfig.eventDuration +\n            channelPointRedemptionEventConfig.unfulfilledAdditionalDuration;\n\n    if (model.status == TwitchChannelPointRedemptionStatus.unfulfilled &&\n        unfulfilledDuration > Duration.zero) {\n      return model.timestamp.add(unfulfilledDuration);\n    }\n    if (model.status == TwitchChannelPointRedemptionStatus.fulfilled &&\n        channelPointRedemptionEventConfig.eventDuration > Duration.zero) {\n      return model.timestamp\n          .add(channelPointRedemptionEventConfig.eventDuration);\n    }\n    return null;\n  } else if (model is TwitchHypeTrainEventModel) {\n    final hypetrainEventConfig =\n        eventSubConfigurationModel.hypetrainEventConfig;\n    return model.endTimestamp.add(hypetrainEventConfig.eventDuration);\n  } else if (model is TwitchPredictionEventModel) {\n    final predictionEventConfig =\n        eventSubConfigurationModel.predictionEventConfig;\n\n    if (model.status == 'canceled') {\n      return null;\n    }\n\n    return model.endTime.add(predictionEventConfig.eventDuration);\n  } else if (model is TwitchMessageModel &&\n      model.annotations.announcement != null) {\n    return messagesModel.announcementPinDuration > Duration.zero\n        ? model.timestamp.add(messagesModel.announcementPinDuration)\n        : null;\n  }\n  return null;\n}\n\nclass _ScrollToBottomWidget extends StatelessWidget {\n  final bool show;\n  final void Function() onPressed;\n  final Widget? child;\n\n  const _ScrollToBottomWidget(\n      {required this.show, required this.onPressed, required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedPositioned(\n      duration: const Duration(milliseconds: 300),\n      bottom: show ? 16 : -72,\n      curve: Curves.easeOut,\n      child: Center(\n        child: ElevatedButton(\n            onPressed: onPressed,\n            style: ElevatedButton.styleFrom(\n              shape: const RoundedRectangleBorder(\n                  borderRadius: BorderRadius.all(Radius.circular(32))),\n              padding: const EdgeInsets.all(16),\n            ),\n            child: Row(\n              children: [\n                const Icon(Icons.arrow_downward),\n                child ?? Container(),\n              ],\n            )),\n      ),\n    );\n  }\n}\n\nclass ChatPanelWidget extends StatefulWidget {\n  final Channel channel;\n\n  const ChatPanelWidget({required this.channel, super.key});\n\n  @override\n  State<ChatPanelWidget> createState() => _ChatPanelWidgetState();\n}\n\nclass _ChatPanelWidgetState extends State<ChatPanelWidget>\n    with TickerProviderStateMixin {\n  final GlobalKey<RefreshIndicatorState> _refreshIndicatorKey =\n      GlobalKey<RefreshIndicatorState>();\n\n  final _controller = ScrollController(keepScrollOffset: true);\n\n  // don't render anything after this message if not null.\n  MessageModel? _pauseAt;\n  MessageModel? _lastMessage;\n  var _atBottom = true;\n  var _refreshPending = false;\n  var _showScrollNotification = true;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _controller.addListener(updateScrollPosition);\n  }\n\n  @override\n  void didUpdateWidget(ChatPanelWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n\n    if (oldWidget.channel != widget.channel) {\n      if (_controller.hasClients) {\n        _controller.jumpTo(0);\n      }\n      setState(() {\n        _atBottom = true;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n\n    super.dispose();\n  }\n\n  void updateScrollPosition() async {\n    if (_controller.position.maxScrollExtent - _controller.offset < 100) {\n      if (_refreshPending) {\n        return;\n      }\n      _refreshPending = true;\n      final model = Provider.of<MessagesModel>(context, listen: false);\n      final messenger = ScaffoldMessenger.of(context);\n      final localizations = AppLocalizations.of(context)!;\n      await model.pullMoreMessages();\n      _refreshPending = false;\n      if (_showScrollNotification && model.messages.length > 5000) {\n        messenger.showSnackBar(SnackBar(\n          content: Text(localizations.longScrollNotification),\n          action: SnackBarAction(\n            label: localizations.stfu,\n            onPressed: () {\n              setState(() {\n                _showScrollNotification = false;\n              });\n            },\n          ),\n        ));\n      }\n    }\n    final value = _controller.position.atEdge && _controller.offset == 0;\n    if (_atBottom != value) {\n      setState(() {\n        _atBottom = value;\n        _pauseAt = value ? null : _lastMessage;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      alignment: AlignmentDirectional.topCenter,\n      children: [\n        Consumer2<MessagesModel, EventSubConfigurationModel>(builder:\n            (context, messagesModel, eventSubConfigurationModel, child) {\n          var messages = messagesModel.messages.reversed.toList();\n          _lastMessage = messages.isEmpty ? null : messages.first;\n          if (messages.isEmpty) {\n            return FutureBuilder(\n              future: MessagesAdapter.instance.hasMessages(widget.channel),\n              builder: (BuildContext context, AsyncSnapshot<bool> snapshot) {\n                if (snapshot.hasData && snapshot.data == false) {\n                  return Align(\n                    alignment: Alignment.bottomCenter,\n                    child: Padding(\n                      padding: const EdgeInsets.only(bottom: 8),\n                      child: Text(\n                        AppLocalizations.of(context)!.noMessagesEmptyState,\n                        style: Theme.of(context).textTheme.titleLarge?.copyWith(\n                            color: Theme.of(context).colorScheme.primary,\n                            fontWeight: FontWeight.bold),\n                      ),\n                    ),\n                  );\n                }\n                return const SizedBox();\n              },\n            );\n          }\n          var dropped = 0;\n          if (_pauseAt != null) {\n            final index = messages.indexOf(_pauseAt!);\n            if (index != -1) {\n              dropped = index;\n              messages = messages.sublist(index);\n            }\n          } else {\n            messagesModel.pruneMessages();\n          }\n          final expirations = messages\n              .map((message) => _getExpiration(\n                  message, eventSubConfigurationModel, messagesModel))\n              .toList();\n          return Stack(alignment: Alignment.topCenter, children: [\n            RebuildableWidget(\n                rebuildAt: expirations.whereType<DateTime>().toSet(),\n                builder: (context) {\n                  final now = DateTime.now();\n                  final oneSecondAgo = now.subtract(const Duration(seconds: 1));\n                  return ReverseRefreshIndicator(\n                    key: _refreshIndicatorKey,\n                    onRefresh: () =>\n                        MessagesAdapter.instance.subscribe(widget.channel),\n                    // Pull from top to show refresh indicator.\n                    child: PinnableMessageScrollView(\n                      vsync: this,\n                      controller: _controller,\n                      itemBuilder: (index) => StyleModelTheme(\n                          key: Key(messages[index].messageId),\n                          child: Builder(builder: (context) {\n                            var message = messages[index];\n                            // if the message is a TwitchFollowEventModel, we want to merge adjacents.\n                            // return Container() if the message is not the first and a merged model\n                            // if it is the first. keep in mind that the list is reversed.\n                            if (message is TwitchFollowEventModel) {\n                              if (index != messages.length - 1 &&\n                                  messages[index + 1]\n                                      is TwitchFollowEventModel) {\n                                return Container();\n                              }\n                              // find the last TwitchFollowEventModel\n                              final lastIndex = messages.lastIndexWhere(\n                                  (element) =>\n                                      element is! TwitchFollowEventModel,\n                                  index);\n                              message = TwitchFollowEventModel.merged(messages\n                                  .sublist(lastIndex + 1, index + 1)\n                                  .reversed\n                                  .toList());\n                            }\n                            // twitch will often send multiple subscription messages in a row.\n                            // if we see them, suppress the less informative ones.\n                            if (message is TwitchSubscriptionEventModel) {\n                              // if the next or prev message is a TwitchSubscriptionMessageEventModel by the same user and tier, ignore this one.\n                              if (index != messages.length - 1) {\n                                final next = messages[index + 1];\n                                if (next\n                                        is TwitchSubscriptionMessageEventModel &&\n                                    next.subscriberUserName ==\n                                        message.subscriberUserName &&\n                                    next.tier == message.tier) {\n                                  return Container();\n                                }\n                              }\n                              if (index > 0) {\n                                final prev = messages[index - 1];\n                                if (prev\n                                        is TwitchSubscriptionMessageEventModel &&\n                                    prev.subscriberUserName ==\n                                        message.subscriberUserName &&\n                                    prev.tier == message.tier) {\n                                  return Container();\n                                }\n                              }\n                            }\n                            final messageWidget = ChatHistoryMessage(\n                                message: message, channel: widget.channel);\n                            final showSeparator = messagesModel.separators\n                                .contains(messages.length - index - 1);\n                            // only show separators after the first 50.\n                            if (showSeparator && index > 50) {\n                              return Column(\n                                crossAxisAlignment: CrossAxisAlignment.start,\n                                children: [\n                                  SeparatorWidget(\n                                      widget.channel, message.timestamp),\n                                  messageWidget\n                                ],\n                              );\n                            }\n                            return messageWidget;\n                          })),\n                      findChildIndexCallback: (key) => messages.indexWhere(\n                          (element) => key == Key(element.messageId)),\n                      isPinnedBuilder: (index) {\n                        final expiration = expirations[index];\n                        if (expiration == null ||\n                            // if the message is too expired, it can't be pinned again.\n                            // note: we track unpinned separately to permit animations.\n                            expiration.isBefore(oneSecondAgo)) {\n                          return PinState.notPinnable;\n                        }\n                        return expiration.isAfter(now)\n                            ? PinState.pinned\n                            : PinState.unpinned;\n                      },\n                      count: messages.length,\n                    ),\n                  );\n                }),\n            _ScrollToBottomWidget(\n              show: !_atBottom,\n              onPressed: () async {\n                updateScrollPosition();\n                if (_controller.offset < 2500) {\n                  await _controller.animateTo(0,\n                      duration: const Duration(milliseconds: 200),\n                      curve: Curves.easeInOut);\n                } else {\n                  // jump instead, it's a better user experience.\n                  _controller.jumpTo(0);\n                }\n              },\n              child: AnimatedContainer(\n                  duration: const Duration(milliseconds: 200),\n                  width: dropped == 0 ? 0 : 150,\n                  child: dropped == 0\n                      ? null\n                      : Text(\n                          AppLocalizations.of(context)!\n                              .newMessageCount(dropped),\n                          textAlign: TextAlign.center,\n                          maxLines: 1,\n                        )),\n            ),\n          ]);\n        }),\n        const ConnectionStatusWidget(),\n      ],\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/header_bar.dart",
    "content": "import 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/models/adapters/channels.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/layout.dart';\n\nclass _DurationWidget extends StatelessWidget {\n  final DateTime from;\n  final TextStyle? style;\n\n  const _DurationWidget({this.style, required this.from});\n\n  static String formatDuration(Duration d) {\n    var seconds = d.inSeconds;\n    final days = seconds ~/ Duration.secondsPerDay;\n    seconds -= days * Duration.secondsPerDay;\n    final hours = seconds ~/ Duration.secondsPerHour;\n    seconds -= hours * Duration.secondsPerHour;\n    final minutes = seconds ~/ Duration.secondsPerMinute;\n    seconds -= minutes * Duration.secondsPerMinute;\n\n    final List<String> tokens = [];\n    if (days != 0) {\n      tokens.add('${days}d');\n    }\n    if (tokens.isNotEmpty || hours != 0) {\n      tokens.add('${hours}h');\n    }\n    if (tokens.isNotEmpty || minutes != 0) {\n      tokens.add('${minutes}m');\n    }\n    tokens.add('${seconds}s');\n\n    return tokens.join(' ');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder(\n      stream: Stream.periodic(const Duration(seconds: 1)),\n      builder: (context, snapshot) {\n        final now = DateTime.now();\n        final diff = now.difference(from);\n\n        return Text('${formatDuration(diff)} up', style: style);\n      },\n    );\n  }\n}\n\nclass HeaderBarWidget extends StatefulWidget implements PreferredSizeWidget {\n  final Channel channel;\n\n  final List<Widget>? actions;\n  final void Function(Channel) onChannelSelect;\n\n  const HeaderBarWidget(\n      {super.key,\n      required this.channel,\n      this.actions,\n      required this.onChannelSelect})\n      : preferredSize = const Size.fromHeight(kToolbarHeight);\n\n  @override\n  final Size preferredSize; // default is 56.0\n\n  @override\n  State<HeaderBarWidget> createState() => _HeaderBarWidgetState();\n}\n\nclass _HeaderBarWidgetState extends State<HeaderBarWidget> {\n  late Timer _fadeTimer;\n\n  var _locked = false;\n  var _iteration = 0;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _fadeTimer = Timer.periodic(const Duration(seconds: 5), (_) {\n      if (_locked) {\n        return;\n      }\n      setState(() {\n        _iteration++;\n      });\n    });\n  }\n\n  @override\n  void dispose() {\n    _fadeTimer.cancel();\n\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AppBar(\n        title: GestureDetector(\n            onTap: () => setState(() => _locked = !_locked),\n            child: StreamBuilder<ChannelMetadata?>(\n                stream: ChannelsAdapter.instance.forChannel(widget.channel),\n                builder: (context, snapshot) {\n                  final data = snapshot.data;\n                  return Column(\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      mainAxisAlignment: MainAxisAlignment.end,\n                      children: [\n                        Padding(\n                            padding: const EdgeInsets.symmetric(vertical: 4),\n                            child: Text(\"/${widget.channel.displayName}\",\n                                style: Theme.of(context).textTheme.titleMedium,\n                                overflow: TextOverflow.fade)),\n                        Consumer<LayoutModel>(\n                            builder: (context, layoutModel, child) {\n                          final style = Theme.of(context).textTheme.bodyMedium;\n                          if (data == null) {\n                            return Text(\"...\", style: style);\n                          }\n                          final texts = <Widget>[];\n                          if (layoutModel.isStatsVisible) {\n                            if (data is TwitchChannelMetadata) {\n                              if (data.onlineAt == null) {\n                                texts.add(Text(\n                                    AppLocalizations.of(context)!\n                                        .followerCount(data.followerCount),\n                                    style: style));\n                              } else {\n                                texts.add(Text(\n                                    AppLocalizations.of(context)!\n                                        .viewerCount(data.viewerCount),\n                                    style: style));\n                              }\n                            }\n                          }\n                          if (data.onlineAt != null) {\n                            texts.add(_DurationWidget(\n                                from: data.onlineAt!, style: style));\n                          }\n                          if (texts.isEmpty) {\n                            return Container();\n                          }\n                          return Row(children: [\n                            if (_locked)\n                              const Padding(\n                                  padding: EdgeInsets.only(right: 4),\n                                  child: Icon(Icons.lock_outline, size: 12)),\n                            Expanded(\n                              child: texts[_iteration % texts.length],\n                            )\n                          ]);\n                        }),\n                      ]);\n                })),\n        actions: widget.actions);\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/autocomplete.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/image/resilient_network_image.dart';\nimport 'package:rtchat/models/channels.dart';\nimport 'package:rtchat/models/chat_mode.dart';\nimport 'package:rtchat/models/commands.dart';\nimport 'package:rtchat/models/messages.dart';\nimport 'package:rtchat/models/messages/twitch/emote.dart';\n\nenum _AutocompleteMode {\n  none,\n  emote,\n  slashCommand,\n  bangCommand,\n  mention,\n}\n\nextension _AutocompleteModeExtension on _AutocompleteMode {\n  static _AutocompleteMode forText(String text) {\n    if (text.startsWith(\"!\") || text.isEmpty) {\n      return _AutocompleteMode.bangCommand;\n    } else if (text.startsWith(\"/\")) {\n      return _AutocompleteMode.slashCommand;\n    }\n    // get the last token in the string.\n    final lastToken = text.split(\" \").last;\n    if (lastToken.startsWith(\"@\")) {\n      return _AutocompleteMode.mention;\n    } else {\n      return _AutocompleteMode.emote;\n    }\n  }\n}\n\nclass AutocompleteWidget extends StatefulWidget {\n  final TextEditingController controller;\n  final Function(String) onSend;\n  final Channel channel;\n\n  const AutocompleteWidget(\n      {super.key,\n      required this.controller,\n      required this.onSend,\n      required this.channel});\n\n  @override\n  State<AutocompleteWidget> createState() => _AutocompleteWidgetState();\n}\n\nclass _AutocompleteWidgetState extends State<AutocompleteWidget> {\n  var _autocompleteMode = _AutocompleteMode.none;\n  late Future<List<Emote>> _emotes;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _emotes = getEmotes(widget.channel);\n\n    setState(() => _autocompleteMode =\n        _AutocompleteModeExtension.forText(widget.controller.text));\n    widget.controller.addListener(_onTextChanged);\n  }\n\n  @override\n  void dispose() {\n    widget.controller.removeListener(_onTextChanged);\n\n    super.dispose();\n  }\n\n  void _onTextChanged() {\n    setState(() {\n      _autocompleteMode =\n          _AutocompleteModeExtension.forText(widget.controller.text);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final text = widget.controller.text;\n    switch (_autocompleteMode) {\n      case _AutocompleteMode.none:\n        return Container();\n      case _AutocompleteMode.emote:\n        return FutureBuilder(\n          future: _emotes,\n          builder: (context, snapshot) {\n            final lastToken = text.split(\" \").last;\n            if (!snapshot.hasData || lastToken.isEmpty) {\n              return Container();\n            }\n            return Row(\n              mainAxisAlignment: MainAxisAlignment.start,\n              children: (snapshot.data as List<Emote>)\n                  .where((emote) => emote.code\n                      .toLowerCase()\n                      .startsWith(lastToken.toLowerCase()))\n                  .take(MediaQuery.of(context).size.width ~/ 48)\n                  .map((emote) {\n                return IconButton(\n                    tooltip: emote.code,\n                    onPressed: () {\n                      widget.controller.text = \"${text.substring(\n                        0,\n                        text.length - lastToken.length,\n                      )}${emote.code} \";\n                      // move cursor position\n                      widget.controller.selection = TextSelection.fromPosition(\n                          TextPosition(offset: widget.controller.text.length));\n                    },\n                    splashRadius: 24,\n                    icon: Image(\n                        width: 24,\n                        height: 24,\n                        image: ResilientNetworkImage(emote.uri)));\n              }).toList(),\n            );\n          },\n        );\n      case _AutocompleteMode.slashCommand:\n        return Container(\n          constraints: const BoxConstraints(maxHeight: 200),\n          child: ListView(\n            shrinkWrap: true,\n            padding: const EdgeInsets.symmetric(horizontal: 8),\n            children: ChatMode.values\n                .where((element) =>\n                    element.title.toLowerCase().startsWith(text.toLowerCase()))\n                .map((e) {\n              return ListTile(\n                title: Text(e.title),\n                subtitle: Text(e.subtitle),\n                onTap: () => widget.onSend(e.title),\n              );\n            }).toList(),\n          ),\n        );\n      case _AutocompleteMode.bangCommand:\n        final commandPrefix = text.split(\" \").last.toLowerCase();\n        return Container(\n          constraints: const BoxConstraints(maxHeight: 200),\n          child: ListView(\n              shrinkWrap: true,\n              padding: const EdgeInsets.symmetric(horizontal: 8),\n              children: [\n                Consumer<CommandsModel>(builder: (context, model, child) {\n                  return Wrap(\n                    children: model.commandList\n                        .where((element) =>\n                            element.command.startsWith(commandPrefix))\n                        .map((command) {\n                      return TextButton(\n                        child: Text(command.command),\n                        onPressed: () => widget.onSend(command.command),\n                      );\n                    }).toList(),\n                  );\n                }),\n              ]),\n        );\n      case _AutocompleteMode.mention:\n        final username = text.split(\" \").last.substring(1);\n        return Consumer<MessagesModel>(builder: (context, model, child) {\n          return SingleChildScrollView(\n            scrollDirection: Axis.horizontal,\n            child: Row(\n              children: model.authors\n                  .where((element) => element.login\n                      .toLowerCase()\n                      .contains(username.toLowerCase()))\n                  .map((viewer) {\n                return TextButton(\n                  child: Text(\"@$viewer\"),\n                  onPressed: () {\n                    widget.controller.text = \"${text.substring(\n                      0,\n                      text.length - username.length - 1,\n                    )}@$viewer \";\n                    // move cursor position\n                    widget.controller.selection = TextSelection.fromPosition(\n                        TextPosition(offset: widget.controller.text.length));\n                  },\n                );\n              }).toList(),\n            ),\n          );\n        });\n    }\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/components/scanner_error.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\n\nclass ScannerErrorWidget extends StatelessWidget {\n  const ScannerErrorWidget({super.key, required this.error});\n\n  final MobileScannerException error;\n\n  @override\n  Widget build(BuildContext context) {\n    String errorMessage;\n\n    switch (error.errorCode) {\n      case MobileScannerErrorCode.controllerUninitialized:\n        errorMessage = 'Controller not ready.';\n        break;\n      case MobileScannerErrorCode.permissionDenied:\n        errorMessage = 'Permission denied';\n        break;\n      case MobileScannerErrorCode.unsupported:\n        errorMessage = 'Scanning is unsupported on this device';\n        break;\n      default:\n        errorMessage = 'Generic Error';\n        break;\n    }\n\n    return ColoredBox(\n      color: Colors.black,\n      child: Center(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            const Padding(\n              padding: EdgeInsets.only(bottom: 16),\n              child: Icon(Icons.error, color: Colors.white),\n            ),\n            Text(\n              errorMessage,\n              style: const TextStyle(color: Colors.white),\n            ),\n            Text(\n              error.errorDetails?.message ?? '',\n              style: const TextStyle(color: Colors.white),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/main.dart",
    "content": "import 'dart:async';\nimport 'dart:convert';\n\nimport 'package:audioplayers/audioplayers.dart';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_analytics/firebase_analytics.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:flutter_localized_locales/flutter_localized_locales.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/firebase_options.dart';\nimport 'package:rtchat/models/activity_feed.dart';\nimport 'package:rtchat/models/audio.dart';\nimport 'package:rtchat/models/commands.dart';\nimport 'package:rtchat/models/layout.dart';\nimport 'package:rtchat/models/messages.dart';\nimport 'package:rtchat/models/messages/twitch/badge.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/purchases.dart';\nimport 'package:rtchat/models/qr_code.dart';\nimport 'package:rtchat/models/quick_links.dart';\nimport 'package:rtchat/models/stream_preview.dart';\nimport 'package:rtchat/models/style.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/user.dart';\nimport 'package:rtchat/screens/home.dart';\nimport 'package:rtchat/screens/onboarding.dart';\nimport 'package:rtchat/screens/settings/activity_feed.dart';\nimport 'package:rtchat/screens/settings/audio_sources.dart';\nimport 'package:rtchat/screens/settings/backup.dart';\nimport 'package:rtchat/screens/settings/chat_history.dart';\nimport 'package:rtchat/screens/settings/events.dart';\nimport 'package:rtchat/screens/settings/events/channel_point.dart';\nimport 'package:rtchat/screens/settings/events/cheer.dart';\nimport 'package:rtchat/screens/settings/events/follow.dart';\nimport 'package:rtchat/screens/settings/events/host.dart';\nimport 'package:rtchat/screens/settings/events/hypetrain.dart';\nimport 'package:rtchat/screens/settings/events/poll.dart';\nimport 'package:rtchat/screens/settings/events/prediction.dart';\nimport 'package:rtchat/screens/settings/events/raid.dart';\nimport 'package:rtchat/screens/settings/events/raiding.dart';\nimport 'package:rtchat/screens/settings/events/subscription.dart';\nimport 'package:rtchat/screens/settings/quick_links.dart';\nimport 'package:rtchat/screens/settings/settings.dart';\nimport 'package:rtchat/screens/settings/third_party.dart';\nimport 'package:rtchat/screens/settings/tts.dart';\nimport 'package:rtchat/screens/settings/tts/cloud_tts_purchases.dart';\nimport 'package:rtchat/screens/settings/tts/languages.dart';\nimport 'package:rtchat/screens/settings/tts/voices.dart';\nimport 'package:rtchat/screens/settings/twitch/badges.dart';\nimport 'package:rtchat/themes.dart';\nimport 'package:streaming_shared_preferences/streaming_shared_preferences.dart';\n\nvoid updateChannelSubscription(String? data) {\n  if (data != null) {\n    channelStreamController.add(data);\n  }\n}\n\nStreamController<String> channelStreamController =\n    StreamController<String>.broadcast();\n\nfinal GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);\n  final prefs = await StreamingSharedPreferences.instance;\n\n  // final currentLocale = PlatformDispatcher.instance.locale;\n\n  // await tts_isolate.isolateMain(\n  //     ReceivePort().sendPort, channelStreamController, prefs, currentLocale);\n\n  if (!kDebugMode) {\n    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;\n    PlatformDispatcher.instance.onError = (error, stack) {\n      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n      return true;\n    };\n  }\n\n  // persistence isn't useful to us since we're using Firestore as an event\n  // stream and it uses memory/cache space.\n  FirebaseFirestore.instance.settings =\n      const Settings(persistenceEnabled: false);\n\n  SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);\n  SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(\n    statusBarBrightness: Brightness.dark,\n    systemNavigationBarColor: Colors.transparent,\n  ));\n\n  AudioPlayer.global.setAudioContext(AudioContext(\n    android: const AudioContextAndroid(\n      contentType: AndroidContentType.sonification,\n      usageType: AndroidUsageType.assistanceSonification,\n      audioFocus: AndroidAudioFocus.none,\n    ),\n    iOS: AudioContextIOS(\n      category: AVAudioSessionCategory.ambient,\n    ),\n  ));\n  runApp(App(prefs: prefs));\n}\n\nclass App extends StatefulWidget {\n  final StreamingSharedPreferences prefs;\n\n  static final observer =\n      FirebaseAnalyticsObserver(analytics: FirebaseAnalytics.instance);\n\n  const App({super.key, required this.prefs});\n\n  @override\n  State<App> createState() => _AppState();\n}\n\nclass _AppState extends State<App> {\n  bool _isDiscoModeRunning = false;\n  Timer? _discoModeTimer;\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (context) => UserModel()),\n        ChangeNotifierProvider(create: (context) {\n          final model = ActivityFeedModel.fromJson(jsonDecode(widget.prefs\n              .getString(\"activity_feed\", defaultValue: '{}')\n              .getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs\n                  .setString(\"activity_feed\", jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProvider(create: (context) {\n          final model = LayoutModel.fromJson(jsonDecode(\n              widget.prefs.getString(\"layout\", defaultValue: '{}').getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs.setString('layout', jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProxyProvider<UserModel, TtsModel>(\n          create: (context) {\n            final model = TtsModel.fromJson(jsonDecode(\n                widget.prefs.getString(\"tts\", defaultValue: '{}').getValue()));\n            return model\n              ..addListener(() {\n                widget.prefs.setString('tts', jsonEncode(model.toJson()));\n              });\n          },\n          update: (context, userModel, model) => model!..update(userModel),\n        ),\n        ChangeNotifierProxyProvider2<UserModel, TtsModel, MessagesModel>(\n          create: (context) {\n            final model = MessagesModel.fromJson(\n              jsonDecode(widget.prefs\n                  .getString(\"message_config\", defaultValue: '{}')\n                  .getValue()),\n            );\n            final player = AudioPlayer();\n            model.onMessagePing =\n                () => player.play(AssetSource('message-sound.wav'));\n            model.channel =\n                Provider.of<UserModel>(context, listen: false).activeChannel;\n            model.tts = Provider.of<TtsModel>(context, listen: false);\n            return model\n              ..addListener(() {\n                if (model.isLive && model.messages.isNotEmpty) {\n                  final message = model.messages.last;\n                  if (message is TwitchMessageModel &&\n                      message.message == \"!disco\") {\n                    _discoModeTimer?.cancel();\n                    setState(() => _isDiscoModeRunning = true);\n                    _discoModeTimer = Timer(const Duration(seconds: 5), () {\n                      setState(() => _isDiscoModeRunning = false);\n                    });\n                  }\n                }\n                widget.prefs\n                    .setString(\"message_config\", jsonEncode(model.toJson()));\n              });\n          },\n          update: (context, userModel, ttsModel, model) {\n            model!.channel = userModel.activeChannel;\n            model.tts = ttsModel;\n            return model;\n          },\n          lazy: false,\n        ),\n        ChangeNotifierProvider(create: (context) {\n          final model = QuickLinksModel.fromJson(jsonDecode(widget.prefs\n              .getString(\"quick_links\", defaultValue: '{}')\n              .getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs.setString('quick_links', jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProvider(create: (context) {\n          final model = StyleModel.fromJson(jsonDecode(\n              widget.prefs.getString(\"style\", defaultValue: '{}').getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs.setString('style', jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProvider(create: ((context) {\n          final model = QRModel.fromJson(jsonDecode(\n              widget.prefs.getString(\"qr\", defaultValue: '{}').getValue()));\n\n          return model\n            ..addListener(() {\n              widget.prefs.setString('qr', jsonEncode(model.toJson()));\n            });\n        })),\n        ChangeNotifierProvider(create: (context) {\n          final model = CommandsModel.fromJson(jsonDecode(widget.prefs\n              .getString(\"commands\", defaultValue: '{}')\n              .getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs.setString(\"commands\", jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProvider(create: (context) {\n          final model = EventSubConfigurationModel.fromJson(jsonDecode(widget\n              .prefs\n              .getString(\"event_sub_configs\", defaultValue: '{}')\n              .getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs\n                  .setString('event_sub_configs', jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProxyProvider<UserModel, TwitchBadgeModel>(\n            create: (context) {\n          final model = TwitchBadgeModel.fromJson(jsonDecode(widget.prefs\n              .getString(\"twitch_badge\", defaultValue: '{}')\n              .getValue()));\n          model.channel =\n              Provider.of<UserModel>(context, listen: false).activeChannel;\n          return model\n            ..addListener(() {\n              widget.prefs\n                  .setString('twitch_badge', jsonEncode(model.toJson()));\n            });\n        }, update: (context, userModel, model) {\n          model!.channel = userModel.activeChannel;\n          return model;\n        }),\n        ChangeNotifierProxyProvider<UserModel, AudioModel>(\n            create: (context) {\n              final model = AudioModel.fromJson(jsonDecode(widget.prefs\n                  .getString(\"audio\", defaultValue: '{}')\n                  .getValue()));\n              model.hostChannel =\n                  Provider.of<UserModel>(context, listen: false).userChannel;\n              return model\n                ..addListener(() {\n                  widget.prefs.setString('audio', jsonEncode(model.toJson()));\n                });\n            },\n            update: (context, userModel, model) {\n              model!.hostChannel = userModel.userChannel;\n              return model;\n            },\n            lazy: false),\n        ChangeNotifierProvider<StreamPreviewModel>(create: (context) {\n          final model = StreamPreviewModel.fromJson(jsonDecode(widget.prefs\n              .getString(\"stream_preview\", defaultValue: '{}')\n              .getValue()));\n          return model\n            ..addListener(() {\n              widget.prefs\n                  .setString('stream_preview', jsonEncode(model.toJson()));\n            });\n        }),\n        ChangeNotifierProvider<Purchases>(\n          create: (context) => Purchases(\n            context.read<TtsModel>(),\n          ),\n          lazy: false,\n        ),\n      ],\n      child: Consumer<LayoutModel>(builder: (context, layoutModel, child) {\n        return MaterialApp(\n          navigatorKey: navigatorKey,\n          title: 'RealtimeChat',\n          theme: Themes.lightTheme,\n          darkTheme: Themes.darkTheme,\n          themeMode: layoutModel.themeMode,\n          localizationsDelegates: const [\n            ...AppLocalizations.localizationsDelegates,\n            LocaleNamesLocalizationsDelegate(),\n          ],\n          supportedLocales: AppLocalizations.supportedLocales,\n          navigatorObservers: [App.observer],\n          initialRoute: '/',\n          routes: {\n            '/': (context) {\n              return Consumer<UserModel>(\n                builder: (context, userModel, child) {\n                  if (userModel.isLoading) {\n                    // don't show anything yet.\n                    return Container();\n                  }\n                  final activeChannel = userModel.activeChannel;\n                  if (activeChannel == null) {\n                    return OnboardingScreen(onChannelSelect: (channel) {\n                      userModel.activeChannel = channel;\n                    });\n                  }\n                  return HomeScreen(\n                      isDiscoModeEnabled: _isDiscoModeRunning,\n                      channel: activeChannel,\n                      onChannelSelect: (channel) {\n                        userModel.activeChannel = channel;\n                      });\n                },\n              );\n            },\n            '/settings': (context) => const SettingsScreen(),\n            '/settings/badges': (context) => const TwitchBadgesScreen(),\n            '/settings/activity-feed': (context) => const ActivityFeedScreen(),\n            '/settings/audio-sources': (context) => const AudioSourcesScreen(),\n            '/settings/chat-history': (context) => const ChatHistoryScreen(),\n            '/settings/text-to-speech': (context) => const TextToSpeechScreen(),\n            '/settings/text-to-speech/cloud-tts': (context) =>\n                const CloudTtsPurchasesScreen(),\n            '/settings/text-to-speech/languages': (context) =>\n                const LanguagesScreen(),\n            '/settings/text-to-speech/voices': (context) =>\n                const VoicesScreen(),\n            '/settings/quick-links': (context) => const QuickLinksScreen(),\n            '/settings/backup': (context) => const BackupScreen(),\n            '/settings/third-party': (context) => const ThirdPartyScreen(),\n            '/settings/events': (context) => const EventsScreen(),\n            '/settings/events/follow': (context) => const FollowEventScreen(),\n            '/settings/events/cheer': (context) => const CheerEventScreen(),\n            '/settings/events/subscription': (context) =>\n                const SubscriptionEventScreen(),\n            '/settings/events/raid': (context) => const RaidEventScreen(),\n            '/settings/events/channel-point': (context) =>\n                const ChannelPointRedemptionEventScreen(),\n            '/settings/events/poll': (context) => const PollEventScreen(),\n            '/settings/events/host': (context) => const HostEventScreen(),\n            '/settings/events/hypetrain': (context) =>\n                const HypetrainEventScreen(),\n            '/settings/events/prediction': (context) =>\n                const PredictionEventScreen(),\n            '/settings/events/raiding': (context) => const RaidingEventScreen(),\n          },\n        );\n      }),\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/lib/tts_isolate.dart",
    "content": "import 'dart:async';\nimport 'dart:convert';\nimport 'dart:isolate';\nimport 'dart:ui';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:rtchat/models/tts.dart';\nimport 'package:rtchat/models/messages/twitch/message.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\nimport 'package:rtchat/models/messages/twitch/reply.dart';\nimport 'package:rtchat/tts_plugin.dart';\nimport 'package:streaming_shared_preferences/streaming_shared_preferences.dart';\n\nfinal DateTime ttsTimeStampListener = DateTime.now();\nStreamSubscription? messagesSubscription;\nStreamSubscription? channelSubscription;\n\nFuture<void> isolateMain(\n    SendPort sendPort,\n    StreamController<String> channelStream,\n    StreamingSharedPreferences prefs,\n    Locale currentLocale) async {\n  DartPluginRegistrant.ensureInitialized();\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp();\n\n  final localizations = await AppLocalizations.delegate.load(currentLocale);\n\n  final ttsQueue = TTSQueue();\n\n  final ttsModel = TtsModel.fromJson(\n      jsonDecode(prefs.getString(\"tts\", defaultValue: '{}').getValue()));\n\n  // Listen for changes to the tts preferences and update the isolates ttsModel\n  final ttsPrefs = prefs.getString('tts', defaultValue: '{}');\n  ttsPrefs.listen((value) async {\n    ttsModel.updateFromJson(jsonDecode(value));\n    await TextToSpeechPlugin.updateTTSPreferences(\n        ttsModel.pitch, ttsModel.speed);\n  });\n\n  // Listen for changes to the stream\n  channelSubscription = channelStream.stream.listen((currentChannel) async {\n    if (currentChannel.isEmpty) {\n      await ttsQueue.clear();\n      messagesSubscription?.cancel();\n    } else {\n      messagesSubscription?.cancel();\n      messagesSubscription = FirebaseFirestore.instance\n          .collection('channels')\n          .doc(currentChannel)\n          .collection('messages')\n          .where('timestamp', isGreaterThan: ttsTimeStampListener)\n          .orderBy('timestamp', descending: true)\n          .limit(1)\n          .snapshots()\n          .listen((latestMessage) async {\n        final docs = latestMessage.docs;\n        if (docs.isNotEmpty) {\n          final message = docs.first;\n          final messageData = message.data();\n          if (messageData.containsKey('type')) {\n            final type = messageData['type'] as String?;\n            switch (type) {\n              case \"message\":\n                final messageModel = TwitchMessageModel(\n                    messageId: message.id,\n                    author: TwitchUserModel(\n                      userId: messageData['tags']['user-id'],\n                      login: messageData['author']['displayName'],\n                    ),\n                    message: messageData['message'],\n                    reply: messageData['reply'] != null\n                        ? TwitchMessageReplyModel(\n                            messageId: messageData['reply']['messageId'],\n                            message: messageData['reply']['message'],\n                            author: TwitchUserModel(\n                              userId: messageData['reply']['userId'],\n                              displayName: messageData['reply']['displayName'],\n                              login: messageData['reply']['userLogin'],\n                            ),\n                          )\n                        : null,\n                    tags: messageData['tags'],\n                    annotations: TwitchMessageAnnotationsModel.fromMap(\n                        messageData['annotations']),\n                    thirdPartyEmotes: [],\n                    timestamp: messageData['timestamp'].toDate(),\n                    deleted: false,\n                    channelId: messageData['channelId']);\n                // Check if the message is from a bot and if bot messages should be muted\n                if (ttsModel.isBotMuted && messageModel.author.isBot) {\n                  return; // Skip vocalization for bot messages\n                }\n                final finalMessage = ttsModel.getVocalization(\n                  localizations,\n                  messageModel,\n                  includeAuthorPrelude: !ttsModel.isPreludeMuted,\n                );\n                if (finalMessage.isNotEmpty) {\n                  // Pass the speech rate and volume values to the TTS engine before vocalizing.\n                  await ttsQueue.speak(message.id, finalMessage,\n                      speed: ttsModel.speed * 1.2,\n                      volume: ttsModel.pitch,\n                      timestamp: messageModel.timestamp);\n                }\n                break;\n              case \"stream.offline\":\n                await ttsQueue.clear();\n                await ttsQueue.speak(\n                  message.id,\n                  \"Stream went offline, disabling text to speech\",\n                );\n                await ttsQueue.disableTts();\n                messagesSubscription?.cancel();\n                break;\n            }\n          }\n        }\n      });\n    }\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/audio_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/audio.dart';\n\nvoid main() {\n  TestWidgetsFlutterBinding.ensureInitialized();\n\n  test(\"AudioModel json roundtrip\", () {\n    final model = AudioModel.fromJson({});\n    final want = model.toJson();\n    final got = AudioModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/layout_test.dart",
    "content": "import 'package:flutter/services.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/layout.dart';\n\nvoid main() {\n  // WidgetsFlutterBinding.ensureInitialized();\n\n  final List<MethodCall> log = [];\n\n  tearDown(() {\n    log.clear();\n  });\n\n  testWidgets(\"LayoutModel json roundtrip\", (tester) async {\n    tester.binding.defaultBinaryMessenger\n        .setMockMethodCallHandler(SystemChannels.platform, (methodCall) {\n      log.add(methodCall);\n      return null;\n    });\n\n    final model = LayoutModel.fromJson({});\n\n    final want = model.toJson();\n    final got = LayoutModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n\n  testWidgets(\"setting orientation propagates to system\", (tester) async {\n    tester.binding.defaultBinaryMessenger\n        .setMockMethodCallHandler(SystemChannels.platform, (methodCall) {\n      log.add(methodCall);\n      return null;\n    });\n\n    final model = LayoutModel.fromJson({});\n\n    expect(log, hasLength(0));\n\n    model.preferredOrientation = PreferredOrientation.portrait;\n\n    expect(log, hasLength(1));\n    expect(\n        log.last,\n        isMethodCall(\n          'SystemChrome.setPreferredOrientations',\n          arguments: [\n            \"DeviceOrientation.portraitUp\",\n            \"DeviceOrientation.portraitDown\"\n          ],\n        ));\n\n    model.preferredOrientation = PreferredOrientation.landscape;\n\n    expect(log, hasLength(2));\n    expect(\n        log.last,\n        isMethodCall(\n          'SystemChrome.setPreferredOrientations',\n          arguments: [\n            \"DeviceOrientation.landscapeLeft\",\n            \"DeviceOrientation.landscapeRight\"\n          ],\n        ));\n\n    model.preferredOrientation = PreferredOrientation.system;\n\n    expect(log, hasLength(3));\n    expect(\n        log.last,\n        isMethodCall(\n          'SystemChrome.setPreferredOrientations',\n          arguments: [],\n        ));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/quick_links_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/quick_links.dart';\n\nvoid main() {\n  test(\"QuickLinksModel json roundtrip\", () {\n    final model = QuickLinksModel.fromJson({});\n    final want = model.toJson();\n    final got = QuickLinksModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n\n  test(\"QuickLinksModel Youtube Link\", () {\n    final model = QuickLinksModel.fromJson({\n      'sources': [\n        {\n          'url': 'https://www.youtube.com/',\n          'icon': 'link',\n          'label': 'YouTube',\n        },\n      ],\n    });\n    final want = model.toJson();\n    final got = QuickLinksModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/activity_feed_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/activity_feed.dart';\n\nvoid main() {\n  test(\"ActivityFeedModel json roundtrip\", () {\n    final model = ActivityFeedModel.fromJson({});\n    final want = model.toJson();\n    final got = ActivityFeedModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/messages/twitch/messages_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/messages.dart';\n\nvoid main() {\n  test(\"TwitchMessageConfig json roundtrip empty json\", () {\n    final model = MessagesModel.fromJson({});\n    final want = model.toJson();\n    final got = MessagesModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n\n  test(\"TwitchMessageConfig json roundtrip with sample\", () {\n    final json = {\n      'modMessageDuration': 6,\n      'vipMessageDuration': 6,\n    };\n    final model = MessagesModel.fromJson(json);\n    final want = model.toJson();\n    final got = MessagesModel.fromJson(model.toJson()).toJson();\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/messages/twitch/hype_train_test.dart",
    "content": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/messages/twitch/hype_train_event.dart';\n\nTwitchHypeTrainEventModel createHypeTrainModel(\n    {required DateTime timestamp,\n    required String messageId,\n    required int level,\n    required int progress,\n    required int goal,\n    required int total,\n    bool isSuccessful = false,\n    bool hasEnded = false}) {\n  return TwitchHypeTrainEventModel(\n      timestamp: timestamp,\n      messageId: \"channel.hype_train-$messageId\",\n      level: level,\n      progress: progress,\n      goal: goal,\n      total: total,\n      isSuccessful: isSuccessful,\n      hasEnded: hasEnded,\n      startTimestamp: DateTime.now(),\n      endTimestamp: DateTime.now());\n}\n\nMap<String, dynamic> createData(\n    String id, int level, int progress, int goal, int total) {\n  return {\n    'timestamp': Timestamp.fromDate(DateTime.now()),\n    'event': {\n      'id': id,\n      'level': level,\n      'progress': progress,\n      'goal': goal,\n      'total': total,\n      'started_at': '2020-07-15T17:16:03.17106713Z',\n      'expires_at': '2020-07-15T17:16:13.17106713Z'\n    }\n  };\n}\n\nMap<String, dynamic> createEndData(int level, int total) {\n  return {\n    'timestamp': Timestamp.fromDate(DateTime.now()),\n    'event': {\n      'level': level,\n      'total': total,\n      'started_at': '2020-07-15T17:16:03.17106713Z',\n      'ended_at': '2020-07-15T17:16:13.17106713Z'\n    }\n  };\n}\n\nvoid main() {\n  group(\"parse progress events\", () {\n    test('progress event should return new event', () {\n      final initialModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 2,\n          progress: 123,\n          goal: 200,\n          total: 123);\n      final expectedModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 2,\n          progress: 126,\n          goal: 200,\n          total: 126);\n      final data = createData('123', 2, 126, 200, 126);\n      expect(initialModel.withProgress(data), expectedModel);\n    });\n\n    test('duplicate progress event should match initial event', () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 2,\n          progress: 123,\n          goal: 200,\n          total: 123);\n      final data = createData('123', 2, 123, 200, 123);\n\n      expect(model.withProgress(data), model);\n    });\n\n    test('out of order progress event should match initial event', () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 2,\n          progress: 123,\n          goal: 200,\n          total: 123);\n      final data = createData('123', 2, 100, 200, 100);\n\n      expect(model.withProgress(data), model);\n    });\n  });\n\n  group(\"parse end events\", () {\n    test('unsuccessful lvl 5 end event should finalize as lvl 4 event', () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 5,\n          progress: 123,\n          goal: 200,\n          total: 123);\n      final expectedModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 4,\n          progress: 123,\n          goal: 200,\n          total: 123,\n          isSuccessful: true,\n          hasEnded: true);\n      final data = createEndData(5, 123);\n\n      var withEnd = model.withEnd(data);\n      expect(withEnd, expectedModel);\n    });\n\n    test('successful lvl 5 end event should finalize as lvl 5 event', () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 5,\n          progress: 200,\n          goal: 200,\n          total: 200);\n      final expectedModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 5,\n          progress: 200,\n          goal: 200,\n          total: 200,\n          isSuccessful: true,\n          hasEnded: true);\n      final data = createEndData(5, 200);\n\n      var withEnd = model.withEnd(data);\n      expect(withEnd, expectedModel);\n    });\n\n    test(\n        'unsuccessful lvl 1 end event should finalize as unsuccesful lvl 1 event',\n        () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 1,\n          progress: 100,\n          goal: 200,\n          total: 100);\n      final expectedModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 1,\n          progress: 100,\n          goal: 200,\n          total: 100,\n          isSuccessful: false,\n          hasEnded: true);\n      final data = createEndData(1, 100);\n\n      var withEnd = model.withEnd(data);\n      expect(withEnd, expectedModel);\n    });\n\n    test(\n        'unsuccessful lvl 2 end event should finalize as successful lvl 2 event',\n        () {\n      final model = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 2,\n          progress: 100,\n          goal: 200,\n          total: 100);\n      final expectedModel = createHypeTrainModel(\n          timestamp: DateTime.now(),\n          messageId: '123',\n          level: 1,\n          progress: 100,\n          goal: 200,\n          total: 100,\n          isSuccessful: true,\n          hasEnded: true);\n      final data = createEndData(2, 100);\n\n      var withEnd = model.withEnd(data);\n      expect(withEnd, expectedModel);\n    });\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/messages/twitch/eventsub_configuration_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/messages/twitch/eventsub_configuration.dart';\n\nvoid main() {\n  test(\"EventSubConfigurationModel json roundtrip empty json\", () {\n    final model = EventSubConfigurationModel.fromJson({});\n    final want = model.toJson();\n    final got = EventSubConfigurationModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n\n  test(\"EventSubConfigurationModel json roundtrip\", () {\n    final json = {\n      'followEventConfig': {'showEvent': true, 'eventDuration': 28},\n      'subscriptionEventConfig': {\n        'showEvent': true,\n        'showIndividualGifts': true,\n        'eventDuration': 30\n      },\n      'cheerEventConfig': {'showEvent': false, 'eventDuration': 30},\n      'raidEventConfig': {\n        'showEvent': true,\n        'eventDuration': 6,\n        'enableShoutoutButton': true\n      },\n      'pollEventConfig': {'showEvent': true, 'eventDuration': 6},\n      'channelPointRedemptionEventConfig': {\n        'showEvent': true,\n        'eventDuration': 6,\n        'unfulfilledAdditionalDuration': 0\n      },\n      'hypetrainEventConfig': {'showEvent': true, 'eventDuration': 6},\n      'predictionEventConfig': {'showEvent': true, 'eventDuration': 6}\n    };\n    final model = EventSubConfigurationModel.fromJson(json);\n    final want = model.toJson();\n    final got = EventSubConfigurationModel.fromJson(model.toJson()).toJson();\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/models/style_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/models/style.dart';\n\nvoid main() {\n  test(\"StyleModel json roundtrip\", () {\n    final model = StyleModel.fromJson({});\n    final want = model.toJson();\n    final got = StyleModel.fromJson(model.toJson()).toJson();\n\n    expect(got, equals(want));\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/components/l10n.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nimport 'package:flutter_localized_locales/flutter_localized_locales.dart';\n\nclass TestLocalizations extends StatelessWidget {\n  final Widget child;\n  const TestLocalizations({super.key, required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Localizations(\n      delegates: const [\n        ...AppLocalizations.localizationsDelegates,\n        LocaleNamesLocalizationsDelegate(),\n      ],\n      locale: const Locale('en'),\n      child: child,\n    );\n  }\n}"
  },
  {
    "file": "/root/development/rtchat/test/components/chat_history/twitch/prediction_event_test.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/twitch/prediction_event.dart';\nimport 'package:rtchat/models/messages/twitch/prediction_event.dart';\nimport 'package:rtchat/models/style.dart';\n\nvoid main() {\n  testWidgets('started prediction should have title and 0 progress',\n      (WidgetTester tester) async {\n    final model = TwitchPredictionEventModel(\n        timestamp: DateTime.now(),\n        messageId: 'prediction1',\n        title: 'Begin prediction',\n        status: 'in_progress',\n        endTime: DateTime.now(),\n        outcomes: [\n          TwitchPredictionOutcomeModel('outcome1', 0, 'pink', 'Heads'),\n          TwitchPredictionOutcomeModel('outcome2', 0, 'blue', 'Tails')\n        ]);\n    await tester.pumpWidget(buildWidget(model));\n\n    final findTitle = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Begin prediction');\n\n    final findPinkOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Heads');\n\n    final findBlueOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Tails');\n\n    final findProgressIndicator = find.byType(LinearProgressIndicator);\n\n    final findIcon = find.byIcon(Icons.emoji_events_outlined);\n\n    expect(findTitle, findsOneWidget);\n    expect(findPinkOutcome, findsOneWidget);\n    expect(findBlueOutcome, findsOneWidget);\n    expect(findIcon, findsNothing);\n    expect(findProgressIndicator, findsNWidgets(2));\n  });\n\n  testWidgets('updated prediction should have over zero progress',\n      (WidgetTester tester) async {\n    final model = TwitchPredictionEventModel(\n        timestamp: DateTime.now(),\n        messageId: 'prediction1',\n        title: 'In Progress prediction',\n        status: 'in_progress',\n        endTime: DateTime.now(),\n        outcomes: [\n          TwitchPredictionOutcomeModel('outcome1', 2, 'pink', 'Yay'),\n          TwitchPredictionOutcomeModel('outcome2', 2, 'blue', 'Nay')\n        ]);\n    await tester.pumpWidget(buildWidget(model));\n\n    final findTitle = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText &&\n        widget.text.toPlainText() == 'In Progress prediction');\n\n    final findPinkOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Yay');\n\n    final findBlueOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Nay');\n\n    final findPercentage = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == '50%');\n\n    final findProgressIndicator = find.byType(LinearProgressIndicator);\n\n    final findIcon = find.byIcon(Icons.emoji_events_outlined);\n\n    expect(findTitle, findsOneWidget);\n    expect(findPinkOutcome, findsOneWidget);\n    expect(findBlueOutcome, findsOneWidget);\n    expect(findIcon, findsNothing);\n    expect(findPercentage, findsNWidgets(2));\n    expect(findProgressIndicator, findsNWidgets(2));\n  });\n\n  testWidgets(\n      'resolved prediction should have over zero progress and winner icon',\n      (WidgetTester tester) async {\n    final model = TwitchPredictionEventModel(\n        timestamp: DateTime.now(),\n        messageId: 'prediction1',\n        title: 'Resolved prediction',\n        status: 'resolved',\n        winningOutcomeId: 'outcome1',\n        endTime: DateTime.now(),\n        outcomes: [\n          TwitchPredictionOutcomeModel('outcome1', 2, 'pink', 'Yes'),\n          TwitchPredictionOutcomeModel('outcome2', 1, 'blue', 'No')\n        ]);\n    await tester.pumpWidget(buildWidget(model));\n\n    final findTitle = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText &&\n        widget.text.toPlainText() == 'Resolved prediction');\n\n    final findPinkOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'Yes');\n\n    final findBlueOutcome = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText && widget.text.toPlainText() == 'No');\n\n    final findProgressIndicator = find.byType(LinearProgressIndicator);\n\n    final findIcon = find.byIcon(Icons.emoji_events_outlined);\n\n    expect(findTitle, findsOneWidget);\n    expect(findPinkOutcome, findsOneWidget);\n    expect(findBlueOutcome, findsOneWidget);\n    expect(findIcon, findsOneWidget);\n    expect(findProgressIndicator, findsNWidgets(2));\n  });\n\n  testWidgets('canceled prediction should be empty',\n      (WidgetTester tester) async {\n    final model = TwitchPredictionEventModel(\n        timestamp: DateTime.now(),\n        messageId: 'prediction1',\n        title: 'Unresolved prediction',\n        status: 'canceled',\n        endTime: DateTime.now(),\n        outcomes: [\n          TwitchPredictionOutcomeModel('outcome1', 1, 'pink', 'Yes'),\n          TwitchPredictionOutcomeModel('outcome2', 1, 'blue', 'No')\n        ]);\n    await tester.pumpWidget(buildWidget(model));\n\n    final findContainer = find.byType(Container);\n    final findIcon = find.byIcon(Icons.emoji_events_outlined);\n\n    expect(findContainer, findsOneWidget);\n    expect(findIcon, findsNothing);\n  });\n}\n\nChangeNotifierProvider<StyleModel> buildWidget(\n    TwitchPredictionEventModel model) {\n  return ChangeNotifierProvider<StyleModel>.value(\n    value: StyleModel.fromJson({\n      'fontSize': 20.0,\n      'lightnessBoost': 0.179,\n      'isDeletedMessagesVisible': true\n    }),\n    child: Directionality(\n        textDirection: TextDirection.ltr,\n        child: MediaQuery(\n            data: const MediaQueryData(),\n            child: TwitchPredictionEventWidget(model))),\n  );\n}"
  },
  {
    "file": "/root/development/rtchat/test/components/chat_history/twitch/cheer_event_test.dart",
    "content": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:rtchat/components/chat_history/twitch/cheer_event.dart';\n\nvoid main() {\n  final bit_10 =\n      Uri.parse(\"https://cdn.twitchalerts.com/twitch-bits/images/hd/10.gif\");\n  final bit_100 =\n      Uri.parse(\"https://cdn.twitchalerts.com/twitch-bits/images/hd/100.gif\");\n  final bit_1000 =\n      Uri.parse(\"https://cdn.twitchalerts.com/twitch-bits/images/hd/1000.gif\");\n  final bit_5000 =\n      Uri.parse(\"https://cdn.twitchalerts.com/twitch-bits/images/hd/5000.gif\");\n  final bit_10000 =\n      Uri.parse(\"https://cdn.twitchalerts.com/twitch-bits/images/hd/10000.gif\");\n  final bit_100000 = Uri.parse(\n      \"https://cdn.twitchalerts.com/twitch-bits/images/hd/100000.gif\");\n  group('bits_10', () {\n    test('cheer 1 bits', () {\n      final actual = getCorrespondingImageUrl(1);\n      expect(actual, bit_10);\n    });\n    test('cheer 10 bits', () {\n      final actual = getCorrespondingImageUrl(10);\n      expect(actual, bit_10);\n    });\n    test('cheer 50 bits', () {\n      final actual = getCorrespondingImageUrl(50);\n      expect(actual, bit_10);\n    });\n    test('cheer 78 bits', () {\n      final actual = getCorrespondingImageUrl(78);\n      expect(actual, bit_10);\n    });\n  });\n\n  group(\"bits_100\", () {\n    test('cheer 100 bits', () {\n      final actual = getCorrespondingImageUrl(100);\n      expect(actual, bit_100);\n    });\n\n    test('cheer 300 bits', () {\n      final actual = getCorrespondingImageUrl(300);\n      expect(actual, bit_100);\n    });\n\n    test('cheer 488 bits', () {\n      final actual = getCorrespondingImageUrl(488);\n      expect(actual, bit_100);\n    });\n    test('cheer 999 bits', () {\n      final actual = getCorrespondingImageUrl(999);\n      expect(actual, bit_100);\n    });\n  });\n\n  group(\"bits_1000\", () {\n    test('cheer 1000 bits', () {\n      final actual = getCorrespondingImageUrl(1000);\n      expect(actual, bit_1000);\n    });\n    test('cheer 1234 bits', () {\n      final actual = getCorrespondingImageUrl(1234);\n      expect(actual, bit_1000);\n    });\n    test('cheer 3333 bits', () {\n      final actual = getCorrespondingImageUrl(3333);\n      expect(actual, bit_1000);\n    });\n    test('cheer 4999 bits', () {\n      final actual = getCorrespondingImageUrl(4999);\n      expect(actual, bit_1000);\n    });\n  });\n\n  group(\"bits_5000\", () {\n    test('cheer 5000 bits', () {\n      final actual = getCorrespondingImageUrl(5000);\n      expect(actual, bit_5000);\n    });\n    test('cheer 5001 bits', () {\n      final actual = getCorrespondingImageUrl(5001);\n      expect(actual, bit_5000);\n    });\n    test('cheer 7133 bits', () {\n      final actual = getCorrespondingImageUrl(7133);\n      expect(actual, bit_5000);\n    });\n    test('cheer 9999 bits', () {\n      final actual = getCorrespondingImageUrl(9999);\n      expect(actual, bit_5000);\n    });\n  });\n\n  group(\"bits_10000\", () {\n    test('cheer 10000 bits', () {\n      final actual = getCorrespondingImageUrl(10000);\n      expect(actual, bit_10000);\n    });\n\n    test('cheer 32134 bits', () {\n      final actual = getCorrespondingImageUrl(32134);\n      expect(actual, bit_10000);\n    });\n    test('cheer 59999 bits', () {\n      final actual = getCorrespondingImageUrl(59999);\n      expect(actual, bit_10000);\n    });\n    test('cheer 99999 bits', () {\n      final actual = getCorrespondingImageUrl(99999);\n      expect(actual, bit_10000);\n    });\n  });\n\n  group(\"bits_100000\", () {\n    test('cheer 100000 bits', () {\n      final actual = getCorrespondingImageUrl(100000);\n      expect(actual, bit_100000);\n    });\n    test('cheer 100001 bits', () {\n      final actual = getCorrespondingImageUrl(100001);\n      expect(actual, bit_100000);\n    });\n    test('cheer 999999 bits', () {\n      final actual = getCorrespondingImageUrl(999999);\n      expect(actual, bit_100000);\n    });\n    test('cheer 314123432 bits', () {\n      final actual = getCorrespondingImageUrl(314123432);\n      expect(actual, bit_100000);\n    });\n  });\n}"
  },
  {
    "file": "/root/development/rtchat/test/components/chat_history/twitch/host_event_test.dart",
    "content": "import 'dart:io';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/twitch/host_event.dart';\nimport 'package:rtchat/models/messages/twitch/event.dart';\nimport 'package:rtchat/models/messages/twitch/user.dart';\nimport 'package:rtchat/models/style.dart';\n\nimport '../../l10n.dart';\n\nvoid main() {\n  AutomatedTestWidgetsFlutterBinding();\n  HttpOverrides.global = null;\n  testWidgets('host event should have channel name and viewer count',\n      (WidgetTester tester) async {\n    final model = TwitchHostEventModel(\n      timestamp: DateTime.now(),\n      messageId: \"testMessageId\",\n      from: const TwitchUserModel(\n          userId: '158394109', login: \"automux\", displayName: \"automux\"),\n      viewers: 10,\n    );\n    await tester.pumpWidget(buildWidget(model));\n\n    await tester.pumpAndSettle();\n\n    final findText = find.byWidgetPredicate((Widget widget) =>\n        widget is RichText &&\n        widget.text.toPlainText() == \"automux is hosting with a party of 10.\");\n\n    expect(findText, findsOneWidget);\n  });\n}\n\nWidget buildWidget(TwitchHostEventModel model) {\n  return TestLocalizations(\n    child: ChangeNotifierProvider<StyleModel>.value(\n        value: StyleModel.fromJson({\n          \"fontSize\": 20.0,\n          \"lightnessBoost\": 0.179,\n          \"isDeletedMessagesVisible\": true\n        }),\n        child: Directionality(\n            textDirection: TextDirection.ltr,\n            child: MediaQuery(\n                data: const MediaQueryData(),\n                child: TwitchHostEventWidget(model)))),\n  );\n}"
  },
  {
    "file": "/root/development/rtchat/test/components/chat_history/twitch/channel_point_event_test.dart",
    "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:provider/provider.dart';\nimport 'package:rtchat/components/chat_history/twitch/channel_point_event.dart';\nimport 'package:rtchat/models/messages/twitch/channel_point_redemption_event.dart';\nimport 'package:rtchat/models/style.dart';\n\nimport '../../l10n.dart';\n\nvoid main() {\n  testWidgets(\n      'fulfilled channel point redemption should have done icon and message',\n      (WidgetTester tester) async {\n    final model = TwitchChannelPointRedemptionEventModel(\n        timestamp: DateTime.now(),\n        messageId: \"testMessageId\",\n        redeemerUsername: \"automux\",\n        status: TwitchChannelPointRedemptionStatus.fulfilled,\n        rewardName: \"Sprint\",\n        rewardCost: 100,\n        userInput: null);\n    await tester.pumpWidget(buildWidget(model));\n\n    await tester.pumpAndSettle();\n\n    final findText = find.byWidgetPredicate((Widget widget) {\n      return widget is RichText &&\n          widget.text.toPlainText() ==\n              'automux redeemed Sprint for 100 points.';\n    });\n\n    final findIcon = find.byIcon(Icons.done);\n\n    expect(findText, findsOneWidget);\n    expect(findIcon, findsOneWidget);\n  });\n\n  testWidgets(\n      'unfulfilled channel point redemption should have timer icon and message',\n      (WidgetTester tester) async {\n    final model = TwitchChannelPointRedemptionEventModel(\n        timestamp: DateTime.now(),\n        messageId: \"testMessageId\",\n        redeemerUsername: \"automux\",\n        status: TwitchChannelPointRedemptionStatus.unfulfilled,\n        rewardName: \"WaTeER\",\n        rewardCost: 350,\n        userInput: \"user input Kappa\");\n    await tester.pumpWidget(buildWidget(model));\n\n    await tester.pumpAndSettle();\n\n    final findText = find.byWidgetPredicate((Widget widget) {\n      return widget is RichText &&\n          widget.text.toPlainText() ==\n              'automux redeemed WaTeER for 350 points. user input Kappa';\n    });\n\n    final findIcon = find.byIcon(Icons.timer);\n\n    expect(findText, findsOneWidget);\n    expect(findIcon, findsOneWidget);\n  });\n}\n\nWidget buildWidget(TwitchChannelPointRedemptionEventModel model) {\n  return TestLocalizations(\n      child: ChangeNotifierProvider<StyleModel>.value(\n    value: StyleModel.fromJson({\n      \"fontSize\": 20.0,\n      \"lightnessBoost\": 0.179,\n      \"isDeletedMessagesVisible\": true\n    }),\n    child: Directionality(\n        textDirection: TextDirection.ltr,\n        child: MediaQuery(\n            data: const MediaQueryData(),\n            child: TwitchChannelPointRedemptionEventWidget(model))),\n  ));\n}"
  }
]